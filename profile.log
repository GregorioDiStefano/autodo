SCRIPT  /usr/share/nvim/runtime/filetype.vim
Sourced 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2018 Feb 14
                            
                            " Listen very carefully, I will say this only once
    2              0.000006 if exists("did_load_filetypes")
    2              0.000002   finish
                            endif
                            let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            augroup filetypedetect
                            
                            " Ignored extensions
                            if exists("*fnameescape")
                            au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
                            au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
                            au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
                            elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
                            if !exists("g:ft_ignore_pat")
                              let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
                            endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
                            func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Vim help file
                            au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt setf help
                            
                            " Abaqus or Trasys
                            au BufNewFile,BufRead *.inp			call dist#ft#Check_inp()
                            
                            " A-A-P recipe
                            au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
                            au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
                            au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
                            au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
                            au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
                            au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
                            au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
                            au BufNewFile,BufRead *.gpr			setf ada
                            
                            " AHDL
                            au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
                            au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
                            au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
                            au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
                            au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
                            au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
                            au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
                            au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
                            au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
                            au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
                            au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
                            au BufNewFile,BufRead apt.conf		       setf aptconf
                            au BufNewFile,BufRead */.aptitude/config       setf aptconf
                            au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
                            au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
                            au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
                            au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
                            au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
                            au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
                            au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
                            au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
                            au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call dist#ft#FTasm()
                            
                            " Macro (VAX)
                            au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
                            au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
                            au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
                            au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
                            au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
                            au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
                            au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
                            au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
                            au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
                            au BufNewFile,BufRead *.bas			call dist#ft#FTVB("basic")
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
                            au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
                            au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
                            au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
                            au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
                            au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
                            au BufNewFile,BufRead *.btm			call dist#ft#FTbtm()
                            
                            " BC calculator
                            au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
                            au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
                            au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
                            au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
                            " sudoedit uses namedXXXX.conf
                            au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key	setf named
                            
                            " BIND zone
                            au BufNewFile,BufRead named.root		setf bindzone
                            au BufNewFile,BufRead *.db			call dist#ft#BindzoneCheck('')
                            
                            " Blank
                            au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
                            au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " Bazel (http://bazel.io)
                            autocmd BufRead,BufNewFile *.bzl,WORKSPACE 	setf bzl
                            if has("fname_case")
                              " There is another check for BUILD further below.
                              autocmd BufRead,BufNewFile BUILD		setf bzl
                            endif
                            
                            " C or lpc
                            au BufNewFile,BufRead *.c			call dist#ft#FTlpc()
                            
                            " Calendar
                            au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
                            au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
                            au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
                            au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
                            au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
                            au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
                            au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
                            au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
                            au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
                            au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
                            au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
                            au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
                            au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
                            au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
                            au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
                            if has("fname_case")
                              au BufNewFile,BufRead *.C,*.H setf cpp
                            endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
                            au BufNewFile,BufRead *.h			call dist#ft#FTheader()
                            
                            " Ch (CHscript)
                            au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
                            au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
                            au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
                            au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
                            au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
                            au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
                            au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
                            au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
                            au BufNewFile,BufRead *.ch			call dist#ft#FTchange()
                            
                            " ChordPro
                            au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
                            au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
                            au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
                            au BufNewFile,BufRead *.ent			call dist#ft#FTent()
                            
                            " Clipper (or FoxPro; could also be eviews)
                            au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
                            au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
                            au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
                            au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
                            au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
                            au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
                            au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
                            au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
                            au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
                            au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
                            au BufNewFile,BufRead *.cu			setf cuda
                            
                            " Dockerfile
                            au BufNewFile,BufRead Dockerfile,*.Dockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
                            au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
                            au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
                            au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
                            au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()
                            if has("fname_case")
                               au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
                            endif
                            
                            " Lynx config files
                            au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
                            au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
                            au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
                            au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
                            au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
                            au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
                            au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
                            au BufNewFile,BufRead *.pld			setf cupl
                            au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
                            au BufNewFile,BufRead */debian/control		setf debcontrol
                            au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
                            au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
                            au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
                            au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
                            au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
                            au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
                            au BufNewFile,BufRead *.d			call dist#ft#DtraceCheck()
                            
                            " Desktop files
                            au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
                            au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
                            au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
                            au BufNewFile,BufRead *.diff,*.rej		setf diff
                            au BufNewFile,BufRead *.patch
                            	\ if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |
                            	\   setf gitsendemail |
                            	\ else |
                            	\   setf diff |
                            	\ endif
                            
                            " Dircolors
                            au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
                            au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
                            au BufNewFile,BufRead *.com			call dist#ft#BindzoneCheck('dcl')
                            
                            " DOT
                            au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
                            au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
                            au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
                            au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
                            au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
                            au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
                            au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
                            au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
                            au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
                            au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
                            au BufNewFile,BufRead *.ed\(f\|if\|o\)		setf edif
                            au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " EditorConfig (close enough to dosini)
                            au BufNewFile,BufRead .editorconfig		setf dosini
                            
                            " Embedix Component Description
                            au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
                            au BufNewFile,BufRead *.e,*.E			call dist#ft#FTe()
                            
                            " Elinks configuration
                            au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
                            " ERicsson LANGuage; Yaws is erlang too
                            au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
                            au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
                            au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
                            au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
                            au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
                            au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
                            au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
                            au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
                            au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
                            au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
                            au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
                            au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
                            au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
                            au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
                            au BufNewFile,BufRead auto.master		setf conf
                            au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
                            au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
                            au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
                            if has("fname_case")
                              au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
                            endif
                            au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
                            au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
                            au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
                            au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
                            au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
                            au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
                            au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
                            au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
                            au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
                            au BufNewFile,BufRead */.config/git/config	setf gitconfig
                            if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
                            endif
                            au BufNewFile,BufRead git-rebase-todo		setf gitrebase
                            au BufRead,BufNewFile .gitsendemail.msg.??????	setf gitsendemail
                            au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
                            au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
                            au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
                            au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
                            au BufNewFile,BufRead */.gnupg/options		setf gpg
                            au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
                            au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
                            endif
                            
                            " gnash(1) configuration files
                            au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
                            au BufNewFile,BufRead gitolite.conf		setf gitolite
                            au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
                            au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
                            au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
                            au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
                            au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
                            au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
                            au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
                            au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
                            au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
                            au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
                            au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
                            au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
                            au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
                            au BufNewFile,BufRead *.lhs			setf lhaskell
                            au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
                            au BufNewFile,BufRead *.ht			setf haste
                            au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
                            au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
                            au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
                            au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
                            au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
                            
                            " HTML with Ruby - eRuby
                            au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
                            au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
                            au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
                            au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
                            au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
                            au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
                            au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
                            au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
                            au BufNewFile,BufRead *.idl			call dist#ft#FTidl()
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
                            au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
                            au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
                            au BufNewFile,BufRead .indent.pro		setf indent
                            au BufNewFile,BufRead indent.pro		call dist#ft#ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
                            au BufNewFile,BufRead *.pro			call dist#ft#ProtoCheck('idlang')
                            
                            " Indent RC
                            au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
                            au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
                            au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
                            au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
                            au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c 	setf upstreamlog
                            au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
                            au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
                            au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
                            au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
                            au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
                            au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
                            au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
                            au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
                            au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
                            au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
                            au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
                            au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
                            au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
                            au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
                            
                            " Java Server Pages
                            au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
                            au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
                            au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
                            au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
                            au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
                            au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
                            au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " Kixtart
                            au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
                            au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
                            au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
                            au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
                            au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
                            au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
                            au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
                            au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
                            au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
                            au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
                            au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
                            au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
                            au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
                            au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
                            au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
                            au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
                            au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
                            au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
                            if has("fname_case")
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
                            else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
                            endif
                            
                            " SBCL implementation of Common Lisp
                            au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
                            au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
                            au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
                            au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
                            au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
                            au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
                            au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
                            au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
                            au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
                            au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
                            au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
                            au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
                            au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
                            au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
                            au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
                            au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
                            au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
                            au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
                            au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
                            au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
                            au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
                            au BufNewFile,BufRead *.man			setf nroff
                            
                            " Man config
                            au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
                            au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
                            au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
                            au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
                            au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Mathematica, Matlab, Murphi or Objective C
                            au BufNewFile,BufRead *.m			call dist#ft#FTm()
                            
                            " Mathematica notebook
                            au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
                            au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
                            au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
                            au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
                            au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
                            au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
                            au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
                            au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
                            au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
                            au BufNewFile,BufRead *.mms			call dist#ft#FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
                            au BufNewFile,BufRead *.mmp			setf mmp
                            
                            " Modsim III (or LambdaProlog)
                            au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
                            au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
                            au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
                            au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
                            au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
                            au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
                            au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
                            au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
                            au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
                            au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
                            au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
                            au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
                            au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
                            au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
                            au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
                            au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " N1QL
                            au BufRead,BufNewfile *.n1ql,*.nql		setf n1ql
                            
                            " Nano
                            au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
                            au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Noemutt setup file
                            au BufNewFile,BufRead Neomuttrc			setf neomuttrc
                            
                            " Netrc
                            au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
                            au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
                            au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
                            au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
                            au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
                            au BufNewFile,BufRead *.[1-9]			call dist#ft#FTnroff()
                            
                            " Nroff or Objective C++
                            au BufNewFile,BufRead *.mm			call dist#ft#FTmm()
                            
                            " Not Quite C
                            au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSE - Nmap Script Engine - uses Lua syntax
                            au BufNewFile,BufRead *.nse			setf lua
                            
                            " NSIS
                            au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
                            au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
                            au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
                            au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
                            au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
                            au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
                            au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
                            au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
                            au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
                            au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
                            au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
                            au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
                            au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
                            au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " PCMK - HAE - crm configure edit 
                            au BufNewFile,BufRead *.pcmk 			setf pcmk
                            
                            " Perl
                            if has("fname_case")
                              au BufNewFile,BufRead *.pl,*.PL		call dist#ft#FTpl()
                            else
                              au BufNewFile,BufRead *.pl			call dist#ft#FTpl()
                            endif
                            au BufNewFile,BufRead *.plx,*.al,*.psgi		setf perl
                            au BufNewFile,BufRead *.p6,*.pm6,*.pl6		setf perl6
                            
                            " Perl, XPM or XPM2
                            au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
                            au BufNewFile,BufRead *.pod			setf pod
                            au BufNewFile,BufRead *.pod6			setf pod6
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
                            au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
                            au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
                            au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
                            au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
                            au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
                            au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
                            au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
                            au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
                            au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
                            au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
                            au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
                            au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
                            au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
                            au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
                            au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
                            au BufNewFile,BufRead *.inc			call dist#ft#FTinc()
                            
                            " Printcap and Termcap
                            au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
                            au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
                            au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
                            au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
                            au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
                            au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
                            au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
                            au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
                            au BufNewFile,BufRead *.w			call dist#ft#FTprogress_cweb()
                            
                            " Progress or assembly
                            au BufNewFile,BufRead *.i			call dist#ft#FTprogress_asm()
                            
                            " Progress or Pascal
                            au BufNewFile,BufRead *.p			call dist#ft#FTprogress_pascal()
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
                            au BufNewFile,BufRead *.psf			setf psf
                            au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
                            au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
                            au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
                            au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
                            au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
                            au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup Files
                            " Quixote (Python-based web framework)
                            au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
                            
                            " Radiance
                            au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
                            au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
                            au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
                            au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
                            au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
                            au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
                            au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
                            if has("fname_case")
                              au BufNewFile,BufRead *.s,*.S			setf r
                            else
                              au BufNewFile,BufRead *.s			setf r
                            endif
                            
                            " R Help file
                            if has("fname_case")
                              au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
                              au BufNewFile,BufRead *.rd			setf rhelp
                            endif
                            
                            " R noweb file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
                            endif
                            
                            " R Markdown file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
                            else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
                            endif
                            
                            " R reStructuredText file
                            if has("fname_case")
                              au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
                            else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
                            endif
                            
                            " Rexx, Rebol or R
                            au BufNewFile,BufRead *.r,*.R				call dist#ft#FTr()
                            
                            " Remind
                            au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
                            au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
                            au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
                            au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
                            au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
                            au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
                            au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
                            au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
                            au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
                            au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
                            au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
                            au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rust
                            au BufNewFile,BufRead *.rs			setf rust
                            
                            " Rackup
                            au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
                            au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
                            au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
                            au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
                            au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
                            au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
                            au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
                            au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
                            au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scala
                            au BufNewFile,BufRead *.scala			setf scala
                            
                            " SBT - Scala Build Tool
                            au BufNewFile,BufRead *.sbt			setf sbt
                            
                            " Scilab
                            au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
                            au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
                            au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
                            au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
                            au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
                            au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
                            au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
                            au BufNewFile,BufRead *.mc			call dist#ft#McSetf()
                            
                            " Services
                            au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
                            au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
                            au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
                            au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
                            au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
                            au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
                            au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
                            au BufNewFile,BufRead catalog			setf catalog
                            au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
                            au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")
                            au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")
                            au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
                            au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call dist#ft#SetFileTypeSH("bash") |
                            	\ endif
                            
                            " tcsh scripts
                            au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
                            au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
                            
                            " Z-Shell script
                            au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
                            au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
                            au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
                            au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
                            au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
                            au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
                            au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
                            au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
                            au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
                            au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
                            au BufNewFile,BufRead .slrnrc			setf slrnrc
                            au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
                            au BufNewFile,BufRead *.st			setf st
                            au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
                            au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
                            au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
                            au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
                            au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
                            au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
                            au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
                            au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
                            au BufNewFile,BufRead *.rules			call dist#ft#FTRules()
                            
                            " Spec (Linux RPM)
                            au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
                            au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
                            au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
                            au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
                            au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
                            au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
                            au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
                            au BufNewFile,BufRead *.sql			call dist#ft#SQL()
                            
                            " SQLJ
                            au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
                            au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
                            au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
                            au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
                            au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
                            " Also *.class, but not when it's a Java bytecode file
                            au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
                            " SMCL
                            au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
                            au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
                            au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
                            au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
                            au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
                            au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}	setf systemd
                            
                            " Synopsys Design Constraints
                            au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
                            au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
                            au BufNewFile,BufRead *.svg			setf svg
                            
                            " Tads (or Nroff or Perl test file)
                            au BufNewFile,BufRead *.t
                            	\ if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
                            
                            " Tags
                            au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
                            au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
                            au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
                            au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
                            au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
                            au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
                            au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language
                            au BufRead,BufNewFile *.ttl			setf teraterm
                            
                            " Terminfo
                            au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
                            au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
                            au BufNewFile,BufRead *.tex			call dist#ft#FTtex()
                            
                            " ConTeXt
                            au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
                            
                            " Texinfo
                            au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
                            au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
                            au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
                            au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " tmux configuration
                            au BufNewFile,BufRead {.,}tmux*.conf		setf tmux
                            
                            " TPP - Text Presentation Program
                            au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
                            au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
                            au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
                            au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
                            au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
                            au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " Tutor mode
                            au BufNewFile,BufReadPost *.tutor		setf tutor
                            
                            " TWIG files
                            au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
                            au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
                            au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
                            au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
                            au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
                            au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
                            au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
                            au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
                            au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
                            au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
                            au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
                            au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
                            au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
                            au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
                            au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
                            au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
                            au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
                            au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
                            au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
                            au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
                            au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
                            au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
                            au BufNewFile,BufRead *.frm			call dist#ft#FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
                            au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
                            au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
                            au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
                            au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
                            au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
                            au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
                            au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
                            au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
                            au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WPL
                            au BufNewFile,BufRead *.wpl			setf xml
                            
                            " WvDial
                            au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
                            au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
                            au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
                            au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
                            au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
                            au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
                            au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
                            au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
                            au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
                            au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
                            au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
                            au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
                            au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
                            au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
                            au BufNewFile,BufRead *.msc,*.msf		setf xmath
                            au BufNewFile,BufRead *.ms
                            	\ if !dist#ft#FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
                            au BufNewFile,BufRead *.xml			call dist#ft#FTxml()
                            
                            " XMI (holding UML models) is also XML
                            au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
                            au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
                            au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
                            au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
                            au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
                            au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
                            au BufNewFile,BufRead *.xlf			setf xml
                            au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
                            au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
                            au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
                            au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
                            au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
                            au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
                            au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
                            au BufNewFile,BufRead *.y			call dist#ft#FTy()
                            
                            " Yaml
                            au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
                            au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
                            au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
                            au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
                            au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call dist#ft#FThtml()
                            "   zsql (zope sql method)
                            au BufNewFile,BufRead *.zsql			call dist#ft#SQL()
                            
                            " Z80 assembler asz80
                            au BufNewFile,BufRead *.z8a			setf z8a
                            
                            augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
                            if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
                            augroup filetypedetect
                            au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
                            au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
                            au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
                            au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
                            au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
                            au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
                            au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " Bazel build file
                            if !has("fname_case")
                              au BufNewFile,BufRead BUILD			setf bzl
                            endif
                            
                            " BIND zone
                            au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
                            au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
                            au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
                            au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
                            au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
                            au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
                            au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
                            au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
                            au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
                            au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
                            au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
                            au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
                            au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
                            au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
                            au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
                            au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
                            au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
                            au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
                            au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
                            au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
                            au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
                            au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
                            au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Neomutt setup file
                            au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
                            au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')
                            
                            " Nroff macros
                            au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
                            au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
                            au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
                            au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
                            au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
                            au BufRead,BufNewFile *.rdf			call dist#ft#Redif()
                            
                            " Remind
                            au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
                            au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
                            au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
                            au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
                            au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
                            au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
                            au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
                            au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
                            au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
                            au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
                            au BufNewFile,BufRead *.text,README setf text
                            
                            " Help files match *.txt but should have a last line that is a modeline. 
                            au BufNewFile,BufRead *.txt
                                    \  if getline('$') !~ 'vim:.*ft=help'
                                    \|   setf text
                                    \| endif       
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
                            runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
                            augroup END
                            
                            " Generic configuration file. Use FALLBACK, it's just guessing!
                            au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf FALLBACK conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
                            if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
                            endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
                            func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/ftplugin.vim
Sourced 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    2              0.000006 if exists("did_load_ftplugin")
    2              0.000001   finish
                            endif
                            let did_load_ftplugin = 1
                            
                            augroup filetypeplugin
                              au FileType * call s:LoadFTPlugin()
                            
                              func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
                            augroup END

SCRIPT  /usr/share/nvim/runtime/indent.vim
Sourced 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000003 if exists("did_indent_on")
    1              0.000001   finish
                            endif
                            let did_indent_on = 1
                            
                            augroup filetypeindent
                              au FileType * call s:LoadIndent()
                              func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
                            augroup END

SCRIPT  /usr/share/nvim/runtime/syntax/syncolor.vim
Sourced 4 times
Total time:   0.000870
 Self time:   0.000870

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    4              0.000017 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    3              0.000011   command -nargs=* SynColor hi <args>
    3              0.000008   command -nargs=* SynLink hi link <args>
    3              0.000003 else
    1              0.000001   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
                              elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    1              0.000003     command -nargs=* SynColor hi <args>
    1              0.000003     command -nargs=* SynLink hi! link <args>
    1              0.000001   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    1              0.000001 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    4              0.000007 if &background == "dark"
    4              0.000031   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    4              0.000024   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    4              0.000058   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    4              0.000028   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    4              0.000021   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    4              0.000021   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    4              0.000025   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    4              0.000019   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    4              0.000021   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    4              0.000003 else
                              SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
                              SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            endif
    4              0.000109 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    4              0.000064 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    4              0.000015 SynLink String		Constant
    4              0.000010 SynLink Character	Constant
    4              0.000013 SynLink Number		Constant
    4              0.000009 SynLink Boolean		Constant
    4              0.000013 SynLink Float		Number
    4              0.000013 SynLink Function	Identifier
    4              0.000009 SynLink Conditional	Statement
    4              0.000009 SynLink Repeat		Statement
    4              0.000009 SynLink Label		Statement
    4              0.000015 SynLink Operator	Statement
    4              0.000010 SynLink Keyword		Statement
    4              0.000009 SynLink Exception	Statement
    4              0.000008 SynLink Include		PreProc
    4              0.000008 SynLink Define		PreProc
    4              0.000009 SynLink Macro		PreProc
    4              0.000008 SynLink PreCondit	PreProc
    4              0.000012 SynLink StorageClass	Type
    4              0.000012 SynLink Structure	Type
    4              0.000012 SynLink Typedef		Type
    4              0.000009 SynLink Tag		Special
    4              0.000013 SynLink SpecialChar	Special
    4              0.000014 SynLink Delimiter	Special
    4              0.000009 SynLink SpecialComment	Special
    4              0.000008 SynLink Debug		Special
                            
    4              0.000005 delcommand SynColor
    4              0.000007 delcommand SynLink

SCRIPT  /home/greg/.config/nvim/plugged/NeoSolarized/colors/NeoSolarized.vim
Sourced 1 time
Total time:   0.005031
 Self time:   0.004609

count  total (s)   self (s)
                            " Name:     NeoSolarized: Colorscheme for truecolor vim
                            " Author:   iCyMind <icyminnd@gmail.com>
                            " URL:      https://github.com/iCyMind/NeoSolarized
                            " License:  MIT
                            " Modified: Mon Sep 26 14:45:22 CST 2016
                            
                            " Usage "{{{
                            "
                            " ---------------------------------------------------------------------
                            " ABOUT:
                            " ---------------------------------------------------------------------
                            " Solarized is a carefully designed selective contrast colorscheme with dual
                            " light and dark modes that runs in both GUI, 256 and 16 color modes.
                            "
                            " But the origin solarized does not support truecolor terminal. NeoSolarized
                            " is a fixed colorscheme for neovim/vim which running in truecolor supported
                            " terminal.
                            "
                            " ---------------------------------------------------------------------
                            " OPTIONS:
                            " ---------------------------------------------------------------------
                            " g:neosolarized_contrast
                            " g:neosolarized_visibility
                            " g:neosolarized_diffmode
                            " g:neosolarized_termtrans
                            " g:neosolarized_bold
                            " g:neosolarized_underline
                            " g:neosolarized_italic
                            "
                            " ---------------------------------------------------------------------
                            " INSTALLATION:
                            " ---------------------------------------------------------------------
                            " move the NeoSolarized.vim to your VIMRUNTIME by manual or plugin manager
                            "
                            " MODIFY VIMRC:
                            "
                            " After either Option 1 or Option 2 above, put the following two lines in your
                            " .vimrc:
                            "
                            "     syntax enable
                            "     set background=dark
                            "     colorscheme NeoSolarized
                            "
                            " or, for the light background mode of Solarized:
                            "
                            "     syntax enable
                            "     set background=light
                            "     colorscheme NeoSolarized
                            "
                            " I like to have a different background in GUI and terminal modes, so I can use
                            " the following if-then. However, I find vim's background autodetection to be
                            " pretty good and, at least with MacVim, I can leave this background value
                            " assignment out entirely and get the same results.
                            "
                            "     if has('gui_running')
                            "       set background=light
                            "     else
                            "       set background=dark
                            "     endif
                            "
                            " See the Solarized homepage at http://ethanschoonover.com/solarized for
                            " screenshots which will help you select either the light or dark background.
                            "
                            " ---------------------------------------------------------------------
                            " COLOR VALUES
                            " ---------------------------------------------------------------------
                            " Download palettes and files from: http://ethanschoonover.com/solarized
                            "
                            " L\*a\*b values are canonical (White D65, Reference D50), other values are
                            " matched in sRGB space.
                            "
                            " SOLARIZED HEX     16/8 TERMCOL  XTERM/HEX   L*A*B      sRGB        HSB
                            " --------- ------- ---- -------  ----------- ---------- ----------- -----------
                            " base03    #002b36  8/4 brblack  234 #1c1c1c 15 -12 -12   0  43  54 193 100  21
                            " base02    #073642  0/4 black    235 #262626 20 -12 -12   7  54  66 192  90  26
                            " base01    #586e75 10/7 brgreen  240 #4e4e4e 45 -07 -07  88 110 117 194  25  46
                            " base00    #657b83 11/7 bryellow 241 #585858 50 -07 -07 101 123 131 195  23  51
                            " base0     #839496 12/6 brblue   244 #808080 60 -06 -03 131 148 150 186  13  59
                            " base1     #93a1a1 14/4 brcyan   245 #8a8a8a 65 -05 -02 147 161 161 180   9  63
                            " base2     #eee8d5  7/7 white    254 #d7d7af 92 -00  10 238 232 213  44  11  93
                            " base3     #fdf6e3 15/7 brwhite  230 #ffffd7 97  00  10 253 246 227  44  10  99
                            " yellow    #b58900  3/3 yellow   136 #af8700 60  10  65 181 137   0  45 100  71
                            " orange    #cb4b16  9/3 brred    166 #d75f00 50  50  55 203  75  22  18  89  80
                            " red       #dc322f  1/1 red      160 #d70000 50  65  45 220  50  47   1  79  86
                            " magenta   #d33682  5/5 magenta  125 #af005f 50  65 -05 211  54 130 331  74  83
                            " violet    #6c71c4 13/5 brmagenta 61 #5f5faf 50  15 -45 108 113 196 237  45  77
                            " blue      #268bd2  4/4 blue      33 #0087ff 55 -10 -45  38 139 210 205  82  82
                            " cyan      #2aa198  6/6 cyan      37 #00afaf 60 -35 -05  42 161 152 175  74  63
                            " green     #859900  2/2 green     64 #5f8700 60 -20  65 133 153   0  68 100  60
                            "
                            " ---------------------------------------------------------------------
                            " COLORSCHEME HACKING
                            " ---------------------------------------------------------------------
                            "
                            " Useful commands for testing colorschemes:
                            " :source $VIMRUNTIME/syntax/hitest.vim
                            " :help highlight-groups
                            " :help cterm-colors
                            " :help group-name
                            "
                            " Useful links for developing colorschemes:
                            " http://www.vim.org/scripts/script.php?script_id=2937
                            " http://vimcasts.org/episodes/creating-colorschemes-for-vim/
                            " http://www.frexx.de/xterm-256-notes/"
                            "
                            " }}}
                            
                            " Default option values"{{{
                            " ---------------------------------------------------------------------
                            
    1              0.000006 let g:neosolarized_contrast = get(g:, "neosolarized_contrast", "normal")
    1              0.000003 let g:neosolarized_visibility = get(g:, "neosolarized_visibility", "normal")
    1              0.000003 let g:neosolarized_diffmode = get(g:, "neosolarized_diffmode", "normal")
    1              0.000003 let g:neosolarized_bold = get(g:, "neosolarized_bold", 1)
    1              0.000003 let g:neosolarized_underline = get(g:, "neosolarized_underline", 1)
    1              0.000003 let g:neosolarized_italic = get(g:, "neosolarized_italic", 0)
    1              0.000003 let g:neosolarized_termtrans = get(g:, "neosolarized_termtrans", 0)
    1              0.000003 let g:neosolarized_vertSplitBgTrans = get(g:, "neosolarized_vertSplitBgTrans", 1)
                            
                            "}}}
                            
                            " Colorscheme initialization "{{{
                            " ---------------------------------------------------------------------
    1   0.001436   0.001219 hi clear
    1              0.000003 if exists("syntax_on")
    1   0.000330   0.000125   syntax reset
    1              0.000001 endif
    1              0.000002 let colors_name = "NeoSolarized"
                            
                            "}}}
                            
                            " GUI & CSApprox hexadecimal palettes"{{{
                            " ---------------------------------------------------------------------
                            "
                            " Set gui and terminal at the same time.
    1              0.000002     let s:gui_mode       = "gui"
    1              0.000002     let s:gui_base03      = "#002b36"
    1              0.000001     let s:gui_base02      = "#073642"
    1              0.000001     let s:gui_base01      = "#586e75"
    1              0.000001     let s:gui_base00      = "#657b83"
    1              0.000001     let s:gui_base0       = "#839496"
    1              0.000001     let s:gui_base1       = "#93a1a1"
    1              0.000002     let s:gui_base2       = "#eee8d5"
    1              0.000001     let s:gui_base3       = "#fdf6e3"
    1              0.000001     let s:gui_yellow      = "#b58900"
    1              0.000001     let s:gui_orange      = "#cb4b16"
    1              0.000001     let s:gui_red         = "#dc322f"
    1              0.000001     let s:gui_magenta     = "#d33682"
    1              0.000001     let s:gui_violet      = "#6c71c4"
    1              0.000002     let s:gui_blue        = "#268bd2"
    1              0.000001     let s:gui_cyan        = "#2aa198"
    1              0.000002     let s:gui_green       = "#719e07" "experimental
                                "let s:green       = "#859900" "original
                            
    1              0.000001     let s:term_mode       = "cterm"
    1              0.000001     let s:term_base03      = "8"
    1              0.000001     let s:term_base02      = "0"
    1              0.000001     let s:term_base01      = "10"
    1              0.000001     let s:term_base00      = "11"
    1              0.000001     let s:term_base0       = "12"
    1              0.000001     let s:term_base1       = "14"
    1              0.000001     let s:term_base2       = "7"
    1              0.000001     let s:term_base3       = "15"
    1              0.000001     let s:term_yellow      = "3"
    1              0.000001     let s:term_orange      = "9"
    1              0.000001     let s:term_red         = "1"
    1              0.000001     let s:term_magenta     = "5"
    1              0.000001     let s:term_violet      = "13"
    1              0.000001     let s:term_blue        = "4"
    1              0.000001     let s:term_cyan        = "6"
    1              0.000001     let s:term_green       = "2"
                            
                            "}}}
                            
                            " Formatting options and null values for passthrough effect "{{{
                            " ---------------------------------------------------------------------
    1              0.000001     let s:gui_none        = "NONE"
    1              0.000001     let s:term_none       = "NONE"
    1              0.000002     let s:n               = "NONE"
    1              0.000001     let s:c               = ",undercurl"
    1              0.000001     let s:r               = ",reverse"
    1              0.000001     let s:s               = ",standout"
    1              0.000001     let s:ou              = ""
    1              0.000001     let s:ob              = ""
                            "}}}
                            
                            " Background value based on termtrans setting "{{{
                            " ---------------------------------------------------------------------
    1              0.000005 if (has("gui_running") || g:neosolarized_termtrans == 0)
    1              0.000002     let s:gui_back        = s:gui_base03
    1              0.000003     let s:term_back        = s:term_base03
    1              0.000001 else
                                let s:gui_back        = "NONE"
                                let s:term_back        = "NONE"
                            endif
                            "}}}
                            
                            " Alternate light scheme "{{{
                            " ---------------------------------------------------------------------
    1              0.000001 if &background == "light"
                                " GUI
                                let s:gui_temp03    =   s:gui_base03
                                let s:gui_temp02    =   s:gui_base02
                                let s:gui_temp01    =   s:gui_base01
                                let s:gui_temp00    =   s:gui_base00
                                let s:gui_base03    =   s:gui_base3
                                let s:gui_base02    =   s:gui_base2
                                let s:gui_base01    =   s:gui_base1
                                let s:gui_base00    =   s:gui_base0
                                let s:gui_base0     =   s:gui_temp00
                                let s:gui_base1     =   s:gui_temp01
                                let s:gui_base2     =   s:gui_temp02
                                let s:gui_base3     =   s:gui_temp03
                                if (s:gui_back != "NONE")
                                    let s:gui_back  =   s:gui_base03
                                endif
                            
                                " terminal
                                let s:term_temp03   =   s:term_base03
                                let s:term_temp02   =   s:term_base02
                                let s:term_temp01   =   s:term_base01
                                let s:term_temp00   =   s:term_base00
                                let s:term_base03   =   s:term_base3
                                let s:term_base02   =   s:term_base2
                                let s:term_base01   =   s:term_base1
                                let s:term_base00   =   s:term_base0
                                let s:term_base0    =   s:term_temp00
                                let s:term_base1    =   s:term_temp01
                                let s:term_base2    =   s:term_temp02
                                let s:term_base3    =   s:term_temp03
                                if (s:term_back != "NONE")
                                    let s:term_back =   s:term_base03
                                endif
                            endif
                            "}}}
                            
                            " Optional contrast schemes "{{{
                            " ---------------------------------------------------------------------
    1              0.000002 if g:neosolarized_contrast == "high"
                                let s:gui_base01      = s:gui_base00
                                let s:gui_base00      = s:gui_base0
                                let s:gui_base0       = s:gui_base1
                                let s:gui_base1       = s:gui_base2
                                let s:gui_base2       = s:gui_base3
                                let s:gui_back        = s:gui_back
                            
                                let s:term_base01      = s:term_base00
                                let s:term_base00      = s:term_base0
                                let s:term_base0       = s:term_base1
                                let s:term_base1       = s:term_base2
                                let s:term_base2       = s:term_base3
                                let s:term_back        = s:term_back
                            endif
    1              0.000001 if g:neosolarized_contrast == "low"
                                let s:gui_back        = s:gui_base02
                                let s:term_back        = s:term_base02
                                let s:ou          = ",underline"
                            endif
                            "}}}
                            
                            " Overrides dependent on user specified values and environment "{{{
                            " ---------------------------------------------------------------------
    1              0.000002 if (g:neosolarized_bold == 0 || &t_Co == 8 )
                                let s:b           = ""
                                let s:bb          = ",bold"
                            else
    1              0.000002     let s:b           = ",bold"
    1              0.000002     let s:bb          = ""
    1              0.000001 endif
                            
    1              0.000002 if g:neosolarized_underline == 0
                                let s:u           = ""
                            else
    1              0.000002     let s:u           = ",underline"
    1              0.000001 endif
                            
    1              0.000001 if g:neosolarized_italic == 0
    1              0.000002     let s:i           = ""
    1              0.000001 else
                                let s:i           = ",italic"
                            endif
                            "}}}
                            
                            " Highlighting primitives"{{{
                            " ---------------------------------------------------------------------
                            
    1              0.000007 exe "let s:bg_none      = ' "   .   "guibg=".s:gui_none     .   " ctermbg=".s:term_none      .   "'"
    1              0.000006 exe "let s:bg_back      = ' "   .   "guibg=".s:gui_back     .   " ctermbg=".s:term_back      .   "'"
    1              0.000006 exe "let s:bg_base03    = ' "   .   "guibg=".s:gui_base03   .   " ctermbg=".s:term_base03    .   "'"
    1              0.000005 exe "let s:bg_base02    = ' "   .   "guibg=".s:gui_base02   .   " ctermbg=".s:term_base02    .   "'"
    1              0.000005 exe "let s:bg_base01    = ' "   .   "guibg=".s:gui_base01   .   " ctermbg=".s:term_base01    .   "'"
    1              0.000005 exe "let s:bg_base00    = ' "   .   "guibg=".s:gui_base00   .   " ctermbg=".s:term_base00    .   "'"
    1              0.000005 exe "let s:bg_base0     = ' "   .   "guibg=".s:gui_base0    .   " ctermbg=".s:term_base0     .   "'"
    1              0.000005 exe "let s:bg_base1     = ' "   .   "guibg=".s:gui_base1    .   " ctermbg=".s:term_base1     .   "'"
    1              0.000005 exe "let s:bg_base2     = ' "   .   "guibg=".s:gui_base2    .   " ctermbg=".s:term_base2     .   "'"
    1              0.000005 exe "let s:bg_base3     = ' "   .   "guibg=".s:gui_base3    .   " ctermbg=".s:term_base3     .   "'"
    1              0.000005 exe "let s:bg_green     = ' "   .   "guibg=".s:gui_green    .   " ctermbg=".s:term_green     .   "'"
    1              0.000005 exe "let s:bg_yellow    = ' "   .   "guibg=".s:gui_yellow   .   " ctermbg=".s:term_yellow    .   "'"
    1              0.000006 exe "let s:bg_orange    = ' "   .   "guibg=".s:gui_orange   .   " ctermbg=".s:term_orange    .   "'"
    1              0.000005 exe "let s:bg_red       = ' "   .   "guibg=".s:gui_red      .   " ctermbg=".s:term_red       .   "'"
    1              0.000006 exe "let s:bg_magenta   = ' "   .   "guibg=".s:gui_magenta  .   " ctermbg=".s:term_magenta   .   "'"
    1              0.000005 exe "let s:bg_violet    = ' "   .   "guibg=".s:gui_violet   .   " ctermbg=".s:term_violet    .   "'"
    1              0.000006 exe "let s:bg_blue      = ' "   .   "guibg=".s:gui_blue     .   " ctermbg=".s:term_blue      .   "'"
    1              0.000005 exe "let s:bg_cyan      = ' "   .   "guibg=".s:gui_cyan     .   " ctermbg=".s:term_cyan      .   "'"
                            
    1              0.000006 exe "let s:fg_none      = ' "   .   "guifg=".s:gui_none     .   " ctermfg=".s:term_none      .   "'"
    1              0.000005 exe "let s:fg_back      = ' "   .   "guifg=".s:gui_back     .   " ctermfg=".s:term_back      .   "'"
    1              0.000005 exe "let s:fg_base03    = ' "   .   "guifg=".s:gui_base03   .   " ctermfg=".s:term_base03    .   "'"
    1              0.000005 exe "let s:fg_base02    = ' "   .   "guifg=".s:gui_base02   .   " ctermfg=".s:term_base02    .   "'"
    1              0.000005 exe "let s:fg_base01    = ' "   .   "guifg=".s:gui_base01   .   " ctermfg=".s:term_base01    .   "'"
    1              0.000005 exe "let s:fg_base00    = ' "   .   "guifg=".s:gui_base00   .   " ctermfg=".s:term_base00    .   "'"
    1              0.000005 exe "let s:fg_base0     = ' "   .   "guifg=".s:gui_base0    .   " ctermfg=".s:term_base0     .   "'"
    1              0.000005 exe "let s:fg_base1     = ' "   .   "guifg=".s:gui_base1    .   " ctermfg=".s:term_base1     .   "'"
    1              0.000005 exe "let s:fg_base2     = ' "   .   "guifg=".s:gui_base2    .   " ctermfg=".s:term_base2     .   "'"
    1              0.000005 exe "let s:fg_base3     = ' "   .   "guifg=".s:gui_base3    .   " ctermfg=".s:term_base3     .   "'"
    1              0.000005 exe "let s:fg_green     = ' "   .   "guifg=".s:gui_green    .   " ctermfg=".s:term_green     .   "'"
    1              0.000005 exe "let s:fg_yellow    = ' "   .   "guifg=".s:gui_yellow   .   " ctermfg=".s:term_yellow    .   "'"
    1              0.000005 exe "let s:fg_orange    = ' "   .   "guifg=".s:gui_orange   .   " ctermfg=".s:term_orange    .   "'"
    1              0.000005 exe "let s:fg_red       = ' "   .   "guifg=".s:gui_red      .   " ctermfg=".s:term_red       .   "'"
    1              0.000005 exe "let s:fg_magenta   = ' "   .   "guifg=".s:gui_magenta  .   " ctermfg=".s:term_magenta   .   "'"
    1              0.000005 exe "let s:fg_violet    = ' "   .   "guifg=".s:gui_violet   .   " ctermfg=".s:term_violet    .   "'"
    1              0.000005 exe "let s:fg_blue      = ' "   .   "guifg=".s:gui_blue     .   " ctermfg=".s:term_blue      .   "'"
    1              0.000005 exe "let s:fg_cyan      = ' "   .   "guifg=".s:gui_cyan     .   " ctermfg=".s:term_cyan      .   "'"
                            
    1              0.000004 exe "let s:fmt_none     = ' "   .   "gui=NONE"          .   " cterm=NONE"           .   "'"
    1              0.000005 exe "let s:fmt_bold     = ' "   .   "gui=NONE".s:b      .   " cterm=NONE".s:b       .   "'"
    1              0.000006 exe "let s:fmt_bldi     = ' "   .   "gui=NONE".s:b      .   " cterm=NONE".s:b       .   "'"
    1              0.000005 exe "let s:fmt_undr     = ' "   .   "gui=NONE".s:u      .   " cterm=NONE".s:u       .   "'"
    1              0.000006 exe "let s:fmt_undb     = ' "   .   "gui=NONE".s:u.s:b  .   " cterm=NONE".s:u.s:b   .   "'"
    1              0.000005 exe "let s:fmt_undi     = ' "   .   "gui=NONE".s:u      .   " cterm=NONE".s:u       .   "'"
    1              0.000005 exe "let s:fmt_uopt     = ' "   .   "gui=NONE".s:ou     .   " cterm=NONE".s:ou      .   "'"
    1              0.000005 exe "let s:fmt_curl     = ' "   .   "gui=NONE".s:c      .   " cterm=NONE".s:c       .   "'"
    1              0.000005 exe "let s:fmt_ital     = ' "   .   "gui=NONE".s:i      .   " cterm=NONE".s:i       .   "'"
    1              0.000005 exe "let s:fmt_stnd     = ' "   .   "gui=NONE".s:s      .   " cterm=NONE".s:s       .   "'"
    1              0.000005 exe "let s:fmt_revr     = ' "   .   "gui=NONE".s:r      .   " cterm=NONE".s:r       .   "'"
    1              0.000006 exe "let s:fmt_revb     = ' "   .   "gui=NONE".s:r.s:b  .   " cterm=NONE".s:r.s:b   .   "'"
                            " revbb (reverse bold for bright colors) is only set to actual bold in low
                            " color terminals (t_co=8, such as OS X Terminal.app) and should only be used
                            " with colors 8-15.
    1              0.000007 exe "let s:fmt_revbb    = ' "   .   "gui=NONE".s:r.s:bb     .   " cterm=NONE".s:r.s:bb      .   "'"
    1              0.000007 exe "let s:fmt_revbbu   = ' "   .   "gui=NONE".s:r.s:bb.s:u .   " cterm=NONE".s:r.s:bb.s:u  .   "'"
                            
    1              0.000006 if has("gui_running") || has("termguicolors") && &termguicolors
    1              0.000004     exe "let s:sp_none      = ' guisp="     .       s:gui_none      .   "'"
    1              0.000004     exe "let s:sp_back      = ' guisp="     .       s:gui_back      .   "'"
    1              0.000004     exe "let s:sp_base03    = ' guisp="     .       s:gui_base03    .   "'"
    1              0.000004     exe "let s:sp_base02    = ' guisp="     .       s:gui_base02    .   "'"
    1              0.000004     exe "let s:sp_base01    = ' guisp="     .       s:gui_base01    .   "'"
    1              0.000004     exe "let s:sp_base00    = ' guisp="     .       s:gui_base00    .   "'"
    1              0.000004     exe "let s:sp_base0     = ' guisp="     .       s:gui_base0     .   "'"
    1              0.000003     exe "let s:sp_base1     = ' guisp="     .       s:gui_base1     .   "'"
    1              0.000004     exe "let s:sp_base2     = ' guisp="     .       s:gui_base2     .   "'"
    1              0.000004     exe "let s:sp_base3     = ' guisp="     .       s:gui_base3     .   "'"
    1              0.000005     exe "let s:sp_green     = ' guisp="     .       s:gui_green     .   "'"
    1              0.000004     exe "let s:sp_yellow    = ' guisp="     .       s:gui_yellow    .   "'"
    1              0.000004     exe "let s:sp_orange    = ' guisp="     .       s:gui_orange    .   "'"
    1              0.000004     exe "let s:sp_red       = ' guisp="     .       s:gui_red       .   "'"
    1              0.000004     exe "let s:sp_magenta   = ' guisp="     .       s:gui_magenta   .   "'"
    1              0.000004     exe "let s:sp_violet    = ' guisp="     .       s:gui_violet    .   "'"
    1              0.000004     exe "let s:sp_blue      = ' guisp="     .       s:gui_blue      .   "'"
    1              0.000003     exe "let s:sp_cyan      = ' guisp="     .       s:gui_cyan      .   "'"
    1              0.000001 else
                                let s:sp_none           =   ""
                                let s:sp_back           =   ""
                                let s:sp_base03         =   ""
                                let s:sp_base02         =   ""
                                let s:sp_base01         =   ""
                                let s:sp_base00         =   ""
                                let s:sp_base0          =   ""
                                let s:sp_base1          =   ""
                                let s:sp_base2          =   ""
                                let s:sp_base3          =   ""
                                let s:sp_green          =   ""
                                let s:sp_yellow         =   ""
                                let s:sp_orange         =   ""
                                let s:sp_red            =   ""
                                let s:sp_magenta        =   ""
                                let s:sp_violet         =   ""
                                let s:sp_blue           =   ""
                                let s:sp_cyan           =   ""
                            endif
                            
                            "}}}
                            
                            " Basic highlighting"{{{
                            " ---------------------------------------------------------------------
                            " note that link syntax to avoid duplicate configuration doesn't work with the
                            " exe compiled formats
                            
    1              0.000248 exe "hi! Normal"         .s:fmt_none   .s:fg_base0  .s:bg_back
                            
    1              0.000007 exe "hi! Comment"        .s:fmt_ital   .s:fg_base01 .s:bg_none
                            "       *Comment         any comment
                            
    1              0.000007 exe "hi! Constant"       .s:fmt_none   .s:fg_cyan   .s:bg_none
                            "       *Constant        any constant
                            "        String          a string constant: "this is a string"
                            "        Character       a character constant: 'c', '\n'
                            "        Number          a number constant: 234, 0xff
                            "        Boolean         a boolean constant: TRUE, false
                            "        Float           a floating point constant: 2.3e10
                            
    1              0.000008 exe "hi! Identifier"     .s:fmt_none   .s:fg_blue   .s:bg_none
                            "       *Identifier      any variable name
                            "        Function        function name (also: methods for classes)
                            "
    1              0.000007 exe "hi! Statement"      .s:fmt_none   .s:fg_green  .s:bg_none
                            "       *Statement       any statement
                            "        Conditional     if, then, else, endif, switch, etc.
                            "        Repeat          for, do, while, etc.
                            "        Label           case, default, etc.
                            "        Operator        "sizeof", "+", "*", etc.
                            "        Keyword         any other keyword
                            "        Exception       try, catch, throw
                            
    1              0.000006 exe "hi! PreProc"        .s:fmt_none   .s:fg_orange .s:bg_none
                            "       *PreProc         generic Preprocessor
                            "        Include         preprocessor #include
                            "        Define          preprocessor #define
                            "        Macro           same as Define
                            "        PreCondit       preprocessor #if, #else, #endif, etc.
                            
    1              0.000007 exe "hi! Type"           .s:fmt_none   .s:fg_yellow .s:bg_none
                            "       *Type            int, long, char, etc.
                            "        StorageClass    static, register, volatile, etc.
                            "        Structure       struct, union, enum, etc.
                            "        Typedef         A typedef
                            
    1              0.000006 exe "hi! Special"        .s:fmt_none   .s:fg_red    .s:bg_none
                            "       *Special         any special symbol
                            "        SpecialChar     special character in a constant
                            "        Tag             you can use CTRL-] on this
                            "        Delimiter       character that needs attention
                            "        SpecialComment  special things inside a comment
                            "        Debug           debugging statements
                            
    1              0.000007 exe "hi! Underlined"     .s:fmt_none   .s:fg_violet .s:bg_none
                            "       *Underlined      text that stands out, HTML links
                            
    1              0.000006 exe "hi! Ignore"         .s:fmt_none   .s:fg_none   .s:bg_none
                            "       *Ignore          left blank, hidden  |hl-Ignore|
                            
    1              0.000008 exe "hi! Error"          .s:fmt_bold   .s:fg_red    .s:bg_none
                            "       *Error           any erroneous construct
                            
    1              0.000006 exe "hi! Todo"           .s:fmt_bold   .s:fg_magenta.s:bg_none
                            "       *Todo            anything that needs extra attention; mostly the
                            "                        keywords TODO FIXME and XXX
                            "
                            "}}}
                            
                            " Extended highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000003 if  (g:neosolarized_visibility=="high")
                                exe "hi! SpecialKey" .s:fmt_revr   .s:fg_red    .s:bg_none
                                exe "hi! NonText"    .s:fmt_bold   .s:fg_red    .s:bg_none
                            elseif  (g:neosolarized_visibility=="low")
                                exe "hi! SpecialKey" .s:fmt_bold   .s:fg_base02 .s:bg_none
                                exe "hi! NonText"    .s:fmt_bold   .s:fg_base02 .s:bg_none
                            else
    1              0.000010     exe "hi! SpecialKey" .s:fmt_bold   .s:fg_base00 .s:bg_base02
    1              0.000009     exe "hi! NonText"    .s:fmt_bold   .s:fg_base00 .s:bg_none
    1              0.000001 endif
    1              0.000010 exe "hi! StatusLine"     .s:fmt_none   .s:fg_base1  .s:bg_base02 .s:fmt_revbb
    1              0.000009 exe "hi! StatusLineNC"   .s:fmt_none   .s:fg_base00 .s:bg_base02 .s:fmt_revbb
    1              0.000011 exe "hi! Visual"         .s:fmt_none   .s:fg_base01 .s:bg_base03 .s:fmt_revbb
    1              0.000008 exe "hi! Directory"      .s:fmt_none   .s:fg_blue   .s:bg_none
    1              0.000008 exe "hi! ErrorMsg"       .s:fmt_revr   .s:fg_red    .s:bg_none
    1              0.000008 exe "hi! IncSearch"      .s:fmt_stnd   .s:fg_orange .s:bg_none
    1              0.000008 exe "hi! Search"         .s:fmt_revr   .s:fg_yellow .s:bg_none
    1              0.000008 exe "hi! MoreMsg"        .s:fmt_none   .s:fg_blue   .s:bg_none
    1              0.000008 exe "hi! ModeMsg"        .s:fmt_none   .s:fg_blue   .s:bg_none
    1              0.000008 exe "hi! LineNr"         .s:fmt_none   .s:fg_base01 .s:bg_base02
    1              0.000008 exe "hi! Question"       .s:fmt_bold   .s:fg_cyan   .s:bg_none
    1              0.000002 if (g:neosolarized_vertSplitBgTrans == 1)
    1              0.000008     exe "hi! VertSplit"  .s:fmt_none   .s:fg_base00 .s:bg_none
    1              0.000001 else
                                exe "hi! VertSplit"  .s:fmt_none   .s:fg_base00 .s:bg_base00
                            endif
    1              0.000011 exe "hi! Title"          .s:fmt_bold   .s:fg_orange .s:bg_none
    1              0.000012 exe "hi! VisualNOS"      .s:fmt_stnd   .s:fg_none   .s:bg_base02 .s:fmt_revbb
    1              0.000009 exe "hi! WarningMsg"     .s:fmt_bold   .s:fg_red    .s:bg_none
    1              0.000010 exe "hi! WildMenu"       .s:fmt_none   .s:fg_base2  .s:bg_base02 .s:fmt_revbb
    1              0.000011 exe "hi! Folded"         .s:fmt_bold   .s:fg_base0  .s:bg_base02  .s:sp_base03
    1              0.000008 exe "hi! FoldColumn"     .s:fmt_none   .s:fg_base0  .s:bg_base02
                            
    1              0.000002 if (g:neosolarized_diffmode=="high")
                                exe "hi! DiffAdd"        .s:fmt_revr   .s:fg_green  .s:bg_none
                                exe "hi! DiffChange"     .s:fmt_revr   .s:fg_yellow .s:bg_none
                                exe "hi! DiffDelete"     .s:fmt_revr   .s:fg_red    .s:bg_none
                                exe "hi! DiffText"       .s:fmt_revr   .s:fg_blue   .s:bg_none
                            elseif  (g:neosolarized_diffmode=="low")
                                exe "hi! DiffAdd"        .s:fmt_undr   .s:fg_green  .s:bg_none   .s:sp_green
                                exe "hi! DiffChange"     .s:fmt_undr   .s:fg_yellow .s:bg_none   .s:sp_yellow
                                exe "hi! DiffDelete"     .s:fmt_bold   .s:fg_red    .s:bg_none
                                exe "hi! DiffText"       .s:fmt_undr   .s:fg_blue   .s:bg_none   .s:sp_blue
                            else " normal
    1              0.000010     exe "hi! DiffAdd"        .s:fmt_bold   .s:fg_green  .s:bg_base02 .s:sp_green
    1              0.000010     exe "hi! DiffChange"     .s:fmt_bold   .s:fg_yellow .s:bg_base02 .s:sp_yellow
    1              0.000008     exe "hi! DiffDelete"     .s:fmt_bold   .s:fg_red    .s:bg_base02
    1              0.000010     exe "hi! DiffText"       .s:fmt_bold   .s:fg_blue   .s:bg_base02 .s:sp_blue
    1              0.000001 endif
                            
    1              0.000008 exe "hi! SignColumn"     .s:fmt_none   .s:fg_base0  .s:bg_none
    1              0.000008 exe "hi! Conceal"        .s:fmt_none   .s:fg_blue   .s:bg_none
    1              0.000009 exe "hi! SpellBad"       .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_red
    1              0.000009 exe "hi! SpellCap"       .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_violet
    1              0.000009 exe "hi! SpellRare"      .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_cyan
    1              0.000009 exe "hi! SpellLocal"     .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_yellow
    1              0.000009 exe "hi! Pmenu"          .s:fmt_none   .s:fg_base0  .s:bg_base02  .s:fmt_revbb
    1              0.000009 exe "hi! PmenuSel"       .s:fmt_none   .s:fg_base01 .s:bg_base2   .s:fmt_revbb
    1              0.000009 exe "hi! PmenuSbar"      .s:fmt_none   .s:fg_base2  .s:bg_base0   .s:fmt_revbb
    1              0.000009 exe "hi! PmenuThumb"     .s:fmt_none   .s:fg_base0  .s:bg_base03  .s:fmt_revbb
    1              0.000010 exe "hi! TabLine"        .s:fmt_none   .s:fg_base0  .s:bg_base02  .s:sp_base0
    1              0.000009 exe "hi! TabLineFill"    .s:fmt_none   .s:fg_base0  .s:bg_base02  .s:sp_base0
    1              0.000010 exe "hi! TabLineSel"     .s:fmt_none   .s:fg_base01  .s:bg_base2  .s:sp_base0  .s:fmt_revr
    1              0.000008 exe "hi! CursorColumn"   .s:fmt_none   .s:fg_none   .s:bg_base02
    1              0.000011 exe "hi! CursorLine"     .s:fmt_uopt   .s:fg_none   .s:bg_base02  .s:sp_base1
    1              0.000009 exe "hi! CursorLineNr"   .s:fmt_uopt   .s:fg_none   .s:bg_base02  .s:sp_base1
    1              0.000008 exe "hi! ColorColumn"    .s:fmt_none   .s:fg_none   .s:bg_base02
    1              0.000010 exe "hi! Cursor"         .s:fmt_none   .s:fg_base03 .s:bg_base0
    1              0.000005 hi! link lCursor Cursor
    1              0.000008 exe "hi! MatchParen"     .s:fmt_bold   .s:fg_red    .s:bg_base01
                            
                            "}}}
                            
                            " vim syntax highlighting "{{{
                            " ---------------------------------------------------------------------
                            "exe "hi! vimLineComment" . s:fg_base01 .s:bg_none   .s:fmt_ital
                            "hi! link vimComment Comment
                            "hi! link vimLineComment Comment
    1              0.000005 hi! link vimVar Identifier
    1              0.000004 hi! link vimFunc Function
    1              0.000004 hi! link vimUserFunc Function
    1              0.000004 hi! link helpSpecial Special
    1              0.000005 hi! link vimSet Normal
    1              0.000005 hi! link vimSetEqual Normal
    1              0.000009 exe "hi! vimCommentString"  .s:fmt_none    .s:fg_violet .s:bg_none
    1              0.000008 exe "hi! vimCommand"        .s:fmt_none    .s:fg_yellow .s:bg_none
    1              0.000009 exe "hi! vimCmdSep"         .s:fmt_bold    .s:fg_blue   .s:bg_none
    1              0.000010 exe "hi! helpExample"       .s:fmt_none    .s:fg_base1  .s:bg_none
    1              0.000009 exe "hi! helpOption"        .s:fmt_none    .s:fg_cyan   .s:bg_none
    1              0.000008 exe "hi! helpNote"          .s:fmt_none    .s:fg_magenta.s:bg_none
    1              0.000008 exe "hi! helpVim"           .s:fmt_none    .s:fg_magenta.s:bg_none
    1              0.000009 exe "hi! helpHyperTextJump" .s:fmt_undr    .s:fg_blue   .s:bg_none
    1              0.000009 exe "hi! helpHyperTextEntry".s:fmt_none    .s:fg_green  .s:bg_none
    1              0.000008 exe "hi! vimIsCommand"      .s:fmt_none    .s:fg_base00 .s:bg_none
    1              0.000008 exe "hi! vimSynMtchOpt"     .s:fmt_none    .s:fg_yellow .s:bg_none
    1              0.000008 exe "hi! vimSynType"        .s:fmt_none    .s:fg_cyan   .s:bg_none
    1              0.000008 exe "hi! vimHiLink"         .s:fmt_none    .s:fg_blue   .s:bg_none
    1              0.000022 exe "hi! vimHiGroup"        .s:fmt_none    .s:fg_blue   .s:bg_none
    1              0.000010 exe "hi! vimGroup"          .s:fmt_undb    .s:fg_blue   .s:bg_none
                            "}}}
                            
                            " diff highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000004 hi! link diffAdded Statement
    1              0.000005 hi! link diffLine Identifier
                            "}}}
                            
                            " git & gitcommit highlighting "{{{
                            "git
                            "exe "hi! gitDateHeader"
                            "exe "hi! gitIdentityHeader"
                            "exe "hi! gitIdentityKeyword"
                            "exe "hi! gitNotesHeader"
                            "exe "hi! gitReflogHeader"
                            "exe "hi! gitKeyword"
                            "exe "hi! gitIdentity"
                            "exe "hi! gitEmailDelimiter"
                            "exe "hi! gitEmail"
                            "exe "hi! gitDate"
                            "exe "hi! gitMode"
                            "exe "hi! gitHashAbbrev"
                            "exe "hi! gitHash"
                            "exe "hi! gitReflogMiddle"
                            "exe "hi! gitReference"
                            "exe "hi! gitStage"
                            "exe "hi! gitType"
                            "exe "hi! gitDiffAdded"
                            "exe "hi! gitDiffRemoved"
                            "gitcommit
                            "exe "hi! gitcommitSummary"
    1              0.000009 exe "hi! gitcommitComment"      .s:fmt_ital     .s:fg_base01    .s:bg_none
    1              0.000004 hi! link gitcommitUntracked gitcommitComment
    1              0.000004 hi! link gitcommitDiscarded gitcommitComment
    1              0.000004 hi! link gitcommitSelected  gitcommitComment
    1              0.000009 exe "hi! gitcommitUnmerged"     .s:fmt_bold     .s:fg_green     .s:bg_none
    1              0.000009 exe "hi! gitcommitOnBranch"     .s:fmt_bold     .s:fg_base01    .s:bg_none
    1              0.000009 exe "hi! gitcommitBranch"       .s:fmt_bold     .s:fg_magenta   .s:bg_none
    1              0.000004 hi! link gitcommitNoBranch gitcommitBranch
    1              0.000009 exe "hi! gitcommitDiscardedType".s:fmt_none     .s:fg_red       .s:bg_none
    1              0.000009 exe "hi! gitcommitSelectedType" .s:fmt_none     .s:fg_green     .s:bg_none
                            "exe "hi! gitcommitUnmergedType"
                            "exe "hi! gitcommitType"
                            "exe "hi! gitcommitNoChanges"
                            "exe "hi! gitcommitHeader"
    1              0.000008 exe "hi! gitcommitHeader"       .s:fmt_none     .s:fg_base01    .s:bg_none
    1              0.000009 exe "hi! gitcommitUntrackedFile".s:fmt_bold     .s:fg_cyan      .s:bg_none
    1              0.000009 exe "hi! gitcommitDiscardedFile".s:fmt_bold     .s:fg_red       .s:bg_none
    1              0.000010 exe "hi! gitcommitSelectedFile" .s:fmt_bold     .s:fg_green     .s:bg_none
    1              0.000009 exe "hi! gitcommitUnmergedFile" .s:fmt_bold     .s:fg_yellow    .s:bg_none
    1              0.000009 exe "hi! gitcommitFile"         .s:fmt_bold     .s:fg_base0     .s:bg_none
    1              0.000004 hi! link gitcommitDiscardedArrow gitcommitDiscardedFile
    1              0.000004 hi! link gitcommitSelectedArrow  gitcommitSelectedFile
    1              0.000004 hi! link gitcommitUnmergedArrow  gitcommitUnmergedFile
                            "exe "hi! gitcommitArrow"
                            "exe "hi! gitcommitOverflow"
                            "exe "hi! gitcommitBlank"
                            " }}}
                            "
                            " html highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000008 exe "hi! htmlTag"           .s:fmt_none .s:fg_base01 .s:bg_none
    1              0.000009 exe "hi! htmlEndTag"        .s:fmt_none .s:fg_base01 .s:bg_none
    1              0.000009 exe "hi! htmlTagN"          .s:fmt_bold .s:fg_base1  .s:bg_none
    1              0.000009 exe "hi! htmlTagName"       .s:fmt_bold .s:fg_blue   .s:bg_none
    1              0.000011 exe "hi! htmlSpecialTagName".s:fmt_ital .s:fg_blue   .s:bg_none
    1              0.000009 exe "hi! htmlArg"           .s:fmt_none .s:fg_base00 .s:bg_none
    1              0.000009 exe "hi! javaScript"        .s:fmt_none .s:fg_yellow .s:bg_none
                            "}}}
                            
                            " perl highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000011 exe "hi! perlHereDoc"    . s:fg_base1  .s:bg_back   .s:fmt_none
    1              0.000009 exe "hi! perlVarPlain"   . s:fg_yellow .s:bg_back   .s:fmt_none
    1              0.000009 exe "hi! perlStatementFileDesc". s:fg_cyan.s:bg_back.s:fmt_none
                            
                            "}}}
                            
                            " tex highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000009 exe "hi! texStatement"   . s:fg_cyan   .s:bg_back   .s:fmt_none
    1              0.000009 exe "hi! texMathZoneX"   . s:fg_yellow .s:bg_back   .s:fmt_none
    1              0.000009 exe "hi! texMathMatcher" . s:fg_yellow .s:bg_back   .s:fmt_none
    1              0.000006 exe "hi! texMathMatcher" . s:fg_yellow .s:bg_back   .s:fmt_none
    1              0.000009 exe "hi! texRefLabel"    . s:fg_yellow .s:bg_back   .s:fmt_none
                            "}}}
                            
                            " ruby highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000009 exe "hi! rubyDefine"     . s:fg_base1  .s:bg_back   .s:fmt_bold
                            "rubyInclude
                            "rubySharpBang
                            "rubyAccess
                            "rubyPredefinedVariable
                            "rubyBoolean
                            "rubyClassVariable
                            "rubyBeginEnd
                            "rubyRepeatModifier
                            "hi! link rubyArrayDelimiter    Special  " [ , , ]
                            "rubyCurlyBlock  { , , }
                            
                            "hi! link rubyClass             Keyword
                            "hi! link rubyModule            Keyword
                            "hi! link rubyKeyword           Keyword
                            "hi! link rubyOperator          Operator
                            "hi! link rubyIdentifier        Identifier
                            "hi! link rubyInstanceVariable  Identifier
                            "hi! link rubyGlobalVariable    Identifier
                            "hi! link rubyClassVariable     Identifier
                            "hi! link rubyConstant          Type
                            "}}}
                            
                            " haskell syntax highlighting"{{{
                            " ---------------------------------------------------------------------
                            " For use with syntax/haskell.vim : Haskell Syntax File
                            " http://www.vim.org/scripts/script.php?script_id=3034
                            " See also Steffen Siering's github repository:
                            " http://github.com/urso/dotrc/blob/master/vim/syntax/haskell.vim
                            " ---------------------------------------------------------------------
                            "
                            " Treat True and False specially, see the plugin referenced above
    1              0.000002 let hs_highlight_boolean=1
                            " highlight delims, see the plugin referenced above
    1              0.000001 let hs_highlight_delimiters=1
                            
    1              0.000009 exe "hi! cPreCondit". s:fg_orange.s:bg_none   .s:fmt_none
                            
    1              0.000009 exe "hi! VarId"    . s:fg_blue   .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! ConId"    . s:fg_yellow .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! hsImport" . s:fg_magenta.s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! hsString" . s:fg_base00 .s:bg_none   .s:fmt_none
                            
    1              0.000009 exe "hi! hsStructure"        . s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000008 exe "hi! hs_hlFunctionName"  . s:fg_blue   .s:bg_none
    1              0.000009 exe "hi! hsStatement"        . s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! hsImportLabel"      . s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! hs_OpFunctionName"  . s:fg_yellow .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! hs_DeclareFunction" . s:fg_orange .s:bg_none   .s:fmt_none
    1              0.000008 exe "hi! hsVarSym"           . s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000011 exe "hi! hsType"             . s:fg_yellow .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! hsTypedef"          . s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! hsModuleName"       . s:fg_green  .s:bg_none   .s:fmt_undr
    1              0.000009 exe "hi! hsModuleStartLabel" . s:fg_magenta.s:bg_none   .s:fmt_none
    1              0.000006 hi! link hsImportParams      Delimiter
    1              0.000006 hi! link hsDelimTypeExport   Delimiter
    1              0.000001 hi! link hsModuleStartLabel  hsStructure
    1              0.000004 hi! link hsModuleWhereLabel  hsModuleStartLabel
                            
                            " following is for the haskell-conceal plugin
                            " the first two items don't have an impact, but better safe
    1              0.000009 exe "hi! hsNiceOperator"     . s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000006 exe "hi! hsniceoperator"     . s:fg_cyan   .s:bg_none   .s:fmt_none
                            
                            "}}}
                            
                            " pandoc markdown syntax highlighting "{{{
                            " ---------------------------------------------------------------------
                            
                            "PandocHiLink pandocNormalBlock
    1              0.000009 exe "hi! pandocTitleBlock"               .s:fg_blue   .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocTitleBlockTitle"          .s:fg_blue   .s:bg_none   .s:fmt_bold
    1              0.000010 exe "hi! pandocTitleComment"             .s:fg_blue   .s:bg_none   .s:fmt_bold
    1              0.000011 exe "hi! pandocComment"                  .s:fg_base01 .s:bg_none   .s:fmt_ital
    1              0.000010 exe "hi! pandocVerbatimBlock"            .s:fg_yellow .s:bg_none   .s:fmt_none
    1              0.000004 hi! link pandocVerbatimBlockDeep         pandocVerbatimBlock
    1              0.000004 hi! link pandocCodeBlock                 pandocVerbatimBlock
    1              0.000005 hi! link pandocCodeBlockDelim            pandocVerbatimBlock
    1              0.000009 exe "hi! pandocBlockQuote"               .s:fg_blue   .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! pandocBlockQuoteLeader1"        .s:fg_blue   .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! pandocBlockQuoteLeader2"        .s:fg_cyan   .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! pandocBlockQuoteLeader3"        .s:fg_yellow .s:bg_none   .s:fmt_none
    1              0.000011 exe "hi! pandocBlockQuoteLeader4"        .s:fg_red    .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocBlockQuoteLeader5"        .s:fg_base0  .s:bg_none   .s:fmt_none
    1              0.000011 exe "hi! pandocBlockQuoteLeader6"        .s:fg_base01 .s:bg_none   .s:fmt_none
    1              0.000009 exe "hi! pandocListMarker"               .s:fg_magenta.s:bg_none   .s:fmt_none
    1              0.000011 exe "hi! pandocListReference"            .s:fg_magenta.s:bg_none   .s:fmt_undr
                            
                            " Definitions
                            " ---------------------------------------------------------------------
    1              0.000002 let s:fg_pdef = s:fg_violet
    1              0.000009 exe "hi! pandocDefinitionBlock"              .s:fg_pdef  .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! pandocDefinitionTerm"               .s:fg_pdef  .s:bg_none  .s:fmt_stnd
    1              0.000010 exe "hi! pandocDefinitionIndctr"             .s:fg_pdef  .s:bg_none  .s:fmt_bold
    1              0.000009 exe "hi! pandocEmphasisDefinition"           .s:fg_pdef  .s:bg_none  .s:fmt_ital
    1              0.000010 exe "hi! pandocEmphasisNestedDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_bold
    1              0.000010 exe "hi! pandocStrongEmphasisNestedDefinition"   .s:fg_pdef.s:bg_none.s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisEmphasisDefinition" .s:fg_pdef.s:bg_none.s:fmt_bldi
    1              0.000010 exe "hi! pandocStrikeoutDefinition"          .s:fg_pdef  .s:bg_none  .s:fmt_revr
    1              0.000010 exe "hi! pandocVerbatimInlineDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! pandocSuperscriptDefinition"        .s:fg_pdef  .s:bg_none  .s:fmt_none
    1              0.000009 exe "hi! pandocSubscriptDefinition"          .s:fg_pdef  .s:bg_none  .s:fmt_none
                            
                            " Tables
                            " ---------------------------------------------------------------------
    1              0.000002 let s:fg_ptable = s:fg_blue
    1              0.000009 exe "hi! pandocTable"                        .s:fg_ptable.s:bg_none  .s:fmt_none
    1              0.000009 exe "hi! pandocTableStructure"               .s:fg_ptable.s:bg_none  .s:fmt_none
    1              0.000010 hi! link pandocTableStructureTop             pandocTableStructre
    1              0.000005 hi! link pandocTableStructureEnd             pandocTableStructre
    1              0.000010 exe "hi! pandocTableZebraLight"              .s:fg_ptable.s:bg_base03.s:fmt_none
    1              0.000010 exe "hi! pandocTableZebraDark"               .s:fg_ptable.s:bg_base02.s:fmt_none
    1              0.000009 exe "hi! pandocEmphasisTable"                .s:fg_ptable.s:bg_none  .s:fmt_ital
    1              0.000011 exe "hi! pandocEmphasisNestedTable"          .s:fg_ptable.s:bg_none  .s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisTable"          .s:fg_ptable.s:bg_none  .s:fmt_bold
    1              0.000010 exe "hi! pandocStrongEmphasisNestedTable"    .s:fg_ptable.s:bg_none  .s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisEmphasisTable"  .s:fg_ptable.s:bg_none  .s:fmt_bldi
    1              0.000010 exe "hi! pandocStrikeoutTable"               .s:fg_ptable.s:bg_none  .s:fmt_revr
    1              0.000010 exe "hi! pandocVerbatimInlineTable"          .s:fg_ptable.s:bg_none  .s:fmt_none
    1              0.000009 exe "hi! pandocSuperscriptTable"             .s:fg_ptable.s:bg_none  .s:fmt_none
    1              0.000009 exe "hi! pandocSubscriptTable"               .s:fg_ptable.s:bg_none  .s:fmt_none
                            
                            " Headings
                            " ---------------------------------------------------------------------
    1              0.000002 let s:fg_phead = s:fg_orange
    1              0.000010 exe "hi! pandocHeading"                      .s:fg_phead .s:bg_none.s:fmt_bold
    1              0.000010 exe "hi! pandocHeadingMarker"                .s:fg_yellow.s:bg_none.s:fmt_bold
    1              0.000010 exe "hi! pandocEmphasisHeading"              .s:fg_phead .s:bg_none.s:fmt_bldi
    1              0.000010 exe "hi! pandocEmphasisNestedHeading"        .s:fg_phead .s:bg_none.s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisHeading"        .s:fg_phead .s:bg_none.s:fmt_bold
    1              0.000010 exe "hi! pandocStrongEmphasisNestedHeading"  .s:fg_phead .s:bg_none.s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisEmphasisHeading".s:fg_phead .s:bg_none.s:fmt_bldi
    1              0.000014 exe "hi! pandocStrikeoutHeading"             .s:fg_phead .s:bg_none.s:fmt_revr
    1              0.000010 exe "hi! pandocVerbatimInlineHeading"        .s:fg_phead .s:bg_none.s:fmt_bold
    1              0.000010 exe "hi! pandocSuperscriptHeading"           .s:fg_phead .s:bg_none.s:fmt_bold
    1              0.000010 exe "hi! pandocSubscriptHeading"             .s:fg_phead .s:bg_none.s:fmt_bold
                            
                            " Links
                            " ---------------------------------------------------------------------
    1              0.000010 exe "hi! pandocLinkDelim"                .s:fg_base01 .s:bg_none   .s:fmt_none
    1              0.000011 exe "hi! pandocLinkLabel"                .s:fg_blue   .s:bg_none   .s:fmt_undr
    1              0.000011 exe "hi! pandocLinkText"                 .s:fg_blue   .s:bg_none   .s:fmt_undb
    1              0.000010 exe "hi! pandocLinkURL"                  .s:fg_base00 .s:bg_none   .s:fmt_undr
    1              0.000010 exe "hi! pandocLinkTitle"                .s:fg_base00 .s:bg_none   .s:fmt_undi
    1              0.000011 exe "hi! pandocLinkTitleDelim"           .s:fg_base01 .s:bg_none   .s:fmt_undi   .s:sp_base00
    1              0.000011 exe "hi! pandocLinkDefinition"           .s:fg_cyan   .s:bg_none   .s:fmt_undr   .s:sp_base00
    1              0.000031 exe "hi! pandocLinkDefinitionID"         .s:fg_blue   .s:bg_none   .s:fmt_bold
    1              0.000012 exe "hi! pandocImageCaption"             .s:fg_violet .s:bg_none   .s:fmt_undb
    1              0.000019 exe "hi! pandocFootnoteLink"             .s:fg_green  .s:bg_none   .s:fmt_undr
    1              0.000010 exe "hi! pandocFootnoteDefLink"          .s:fg_green  .s:bg_none   .s:fmt_bold
    1              0.000010 exe "hi! pandocFootnoteInline"           .s:fg_green  .s:bg_none   .s:fmt_undb
    1              0.000010 exe "hi! pandocFootnote"                 .s:fg_green  .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocCitationDelim"            .s:fg_magenta.s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocCitation"                 .s:fg_magenta.s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocCitationID"               .s:fg_magenta.s:bg_none   .s:fmt_undr
    1              0.000010 exe "hi! pandocCitationRef"              .s:fg_magenta.s:bg_none   .s:fmt_none
                            
                            " Main Styles
                            " ---------------------------------------------------------------------
    1              0.000010 exe "hi! pandocStyleDelim"               .s:fg_base01 .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! pandocEmphasis"                 .s:fg_base0  .s:bg_none  .s:fmt_ital
    1              0.000011 exe "hi! pandocEmphasisNested"           .s:fg_base0  .s:bg_none  .s:fmt_bldi
    1              0.000011 exe "hi! pandocStrongEmphasis"           .s:fg_base0  .s:bg_none  .s:fmt_bold
    1              0.000010 exe "hi! pandocStrongEmphasisNested"     .s:fg_base0  .s:bg_none  .s:fmt_bldi
    1              0.000010 exe "hi! pandocStrongEmphasisEmphasis"   .s:fg_base0  .s:bg_none  .s:fmt_bldi
    1              0.000010 exe "hi! pandocStrikeout"                .s:fg_base01 .s:bg_none  .s:fmt_revr
    1              0.000010 exe "hi! pandocVerbatimInline"           .s:fg_yellow .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! pandocSuperscript"              .s:fg_violet .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! pandocSubscript"                .s:fg_violet .s:bg_none  .s:fmt_none
                            
    1              0.000010 exe "hi! pandocRule"                     .s:fg_blue   .s:bg_none  .s:fmt_bold
    1              0.000010 exe "hi! pandocRuleLine"                 .s:fg_blue   .s:bg_none  .s:fmt_bold
    1              0.000012 exe "hi! pandocEscapePair"               .s:fg_red    .s:bg_none  .s:fmt_bold
    1              0.000006 exe "hi! pandocCitationRef"              .s:fg_magenta.s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocNonBreakingSpace"         . s:fg_red   .s:bg_none  .s:fmt_revr
    1              0.000005 hi! link pandocEscapedCharacter          pandocEscapePair
    1              0.000005 hi! link pandocLineBreak                 pandocEscapePair
                            
                            " Embedded Code
                            " ---------------------------------------------------------------------
    1              0.000010 exe "hi! pandocMetadataDelim"            .s:fg_base01 .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocMetadata"                 .s:fg_blue   .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! pandocMetadataKey"              .s:fg_blue   .s:bg_none   .s:fmt_none
    1              0.000006 exe "hi! pandocMetadata"                 .s:fg_blue   .s:bg_none   .s:fmt_bold
    1              0.000007 hi! link pandocMetadataTitle             pandocMetadata
                            
                            "}}}
                            
                            " neomake highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000010 exe "hi! NeomakeErrorSign"          . s:fg_orange   .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! NeomakeWarningSign"        . s:fg_yellow   .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! NeomakeMessageSign"        . s:fg_cyan     .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! NeomakeNeomakeInfoSign"    . s:fg_green    .s:bg_none   .s:fmt_none
                            
                            "}}}
                            
                            " gitgutter highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000011 exe "hi! GitGutterAdd"              . s:fg_green    .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! GitGutterChange"           . s:fg_yellow   .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! GitGutterDelete"           . s:fg_red      .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! GitGutterChangeDelete"     . s:fg_red      .s:bg_none  .s:fmt_none
                            " }}}"
                            
                            " signify highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000010 exe "hi! SignifySignAdd"            . s:fg_green    .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! SignifySignChange"         . s:fg_yellow   .s:bg_none  .s:fmt_none
    1              0.000010 exe "hi! SignifySignDelete"         . s:fg_red      .s:bg_none  .s:fmt_none
    1              0.000011 exe "hi! SignifySignChangeDelete"   . s:fg_red      .s:bg_none  .s:fmt_none
                            " }}}"
                            
                            " ALE highlighting "{{{
                            " ---------------------------------------------------------------------
    1              0.000010 exe "hi! ALEErrorSign"          . s:fg_orange   .s:bg_none   .s:fmt_none
    1              0.000010 exe "hi! ALEWarningSign"        . s:fg_yellow   .s:bg_none   .s:fmt_none
                            " }}}"
                            
                            " NeoVim terminal buffer colours "{{{
                            " ---------------------------------------------------------------------
    1              0.000002 let g:terminal_color_0 = s:gui_base03
    1              0.000002 let g:terminal_color_1 = s:gui_red
    1              0.000002 let g:terminal_color_2 = s:gui_green
    1              0.000002 let g:terminal_color_3 = s:gui_yellow
    1              0.000003 let g:terminal_color_4 = s:gui_blue
    1              0.000002 let g:terminal_color_5 = s:gui_magenta
    1              0.000002 let g:terminal_color_6 = s:gui_cyan
    1              0.000002 let g:terminal_color_7 = s:gui_base2
    1              0.000002 let g:terminal_color_8 = s:gui_base02
    1              0.000002 let g:terminal_color_9 = s:gui_orange
    1              0.000002 let g:terminal_color_10 = s:gui_base01
    1              0.000002 let g:terminal_color_11 = s:gui_base00
    1              0.000002 let g:terminal_color_12 = s:gui_base0
    1              0.000002 let g:terminal_color_13 = s:gui_violet
    1              0.000002 let g:terminal_color_14 = s:gui_base1
    1              0.000009 let g:terminal_color_15 = s:gui_base3
                            "}}}
                            
                            " Utility autocommand "{{{
                            " ---------------------------------------------------------------------
                            " In cases where Solarized is initialized inside a terminal vim session and
                            " then transferred to a gui session via the command `:gui`, the gui vim process
                            " does not re-read the colorscheme (or .vimrc for that matter) so any `has_gui`
                            " related code that sets gui specific values isn't executed.
                            "
                            " Currently, Solarized sets only the cterm or gui values for the colorscheme
                            " depending on gui or terminal mode. It's possible that, if the following
                            " autocommand method is deemed excessively poor form, that approach will be
                            " used again and the autocommand below will be dropped.
                            "
                            " However it seems relatively benign in this case to include the autocommand
                            " here. It fires only in cases where vim is transferring from terminal to gui
                            " mode (detected with the script scope s:vmode variable). It also allows for
                            " other potential terminal customizations that might make gui mode suboptimal.
                            "
    1              0.000006 autocmd GUIEnter * if (has('gui_running')) | exe "colorscheme " . g:colors_name | endif
                            "}}}
                            
                            " License "{{{
                            " ---------------------------------------------------------------------
                            "
                            " Copyright (c) 2011 Ethan Schoonover
                            " Copyright (c) 2016 iCyMind
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to deal
                            " in the Software without restriction, including without limitation the rights
                            " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            " copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                            " THE SOFTWARE.
                            "
                            " vim: set foldmethod=marker foldlevel=0:
                            "}}}

SCRIPT  /home/greg/.config/nvim/plugged/vim-sensible/plugin/sensible.vim
Sourced 1 time
Total time:   0.000762
 Self time:   0.000710

count  total (s)   self (s)
                            " sensible.vim - Defaults everyone can agree on
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.2
                            
    1              0.000005 if exists('g:loaded_sensible') || &compatible
                              finish
                            else
    1              0.000003   let g:loaded_sensible = 'yes'
    1              0.000001 endif
                            
    1              0.000002 if has('autocmd')
    1   0.000414   0.000363   filetype plugin indent on
    1              0.000001 endif
    1              0.000006 if has('syntax') && !exists('g:syntax_on')
                              syntax enable
                            endif
                            
                            " Use :help 'option' to see the documentation for the given option.
                            
    1              0.000002 set autoindent
    1              0.000002 set backspace=indent,eol,start
    1              0.000002 set complete-=i
    1              0.000001 set smarttab
                            
    1              0.000002 set nrformats-=octal
                            
    1              0.000004 if !has('nvim') && &ttimeoutlen == -1
                              set ttimeout
                              set ttimeoutlen=100
                            endif
                            
    1              0.000001 set incsearch
                            " Use <C-L> to clear the highlighting of :set hlsearch.
    1              0.000005 if maparg('<C-L>', 'n') ==# ''
    1              0.000008   nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
    1              0.000001 endif
                            
    1              0.000002 set laststatus=2
    1              0.000001 set ruler
    1              0.000001 set wildmenu
                            
    1              0.000001 if !&scrolloff
    1              0.000001   set scrolloff=1
    1              0.000001 endif
    1              0.000001 if !&sidescrolloff
    1              0.000002   set sidescrolloff=5
    1              0.000001 endif
    1              0.000020 set display+=lastline
                            
    1              0.000003 if &encoding ==# 'latin1' && has('gui_running')
                              set encoding=utf-8
                            endif
                            
    1              0.000001 if &listchars ==# 'eol:$'
                              set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
                            endif
                            
    1              0.000002 if v:version > 703 || v:version == 703 && has("patch541")
    1              0.000002   set formatoptions+=j " Delete comment character when joining commented lines
    1              0.000001 endif
                            
    1              0.000002 if has('path_extra')
    1              0.000003   setglobal tags-=./tags tags-=./tags; tags^=./tags;
    1              0.000001 endif
                            
    1              0.000005 if &shell =~# 'fish$' && (v:version < 704 || v:version == 704 && !has('patch276'))
                              set shell=/usr/bin/env\ bash
                            endif
                            
    1              0.000001 set autoread
                            
    1              0.000001 if &history < 1000
                              set history=1000
                            endif
    1              0.000001 if &tabpagemax < 50
                              set tabpagemax=50
                            endif
    1              0.000002 if !empty(&viminfo)
    1              0.000002   set viminfo^=!
    1              0.000001 endif
    1              0.000005 set sessionoptions-=options
                            
                            " Allow color schemes to do bright colors without forcing bold.
    1              0.000003 if &t_Co == 8 && $TERM !~# '^linux\|^Eterm'
                              set t_Co=16
                            endif
                            
                            " Load matchit.vim, but only if the user hasn't installed a newer version.
    1              0.000194 if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
                              runtime! macros/matchit.vim
                            endif
                            
    1              0.000003 inoremap <C-U> <C-G>u<C-U>
                            
                            " vim:set ft=vim et sw=2:

SCRIPT  /home/greg/.config/nvim/plugged/vim-go/plugin/go.vim
Sourced 1 time
Total time:   0.000753
 Self time:   0.000304

count  total (s)   self (s)
                            " install necessary Go tools
    1              0.000003 if exists("g:go_loaded_install")
                              finish
                            endif
    1              0.000003 let g:go_loaded_install = 1
                            
                            " Not using the has('patch-7.4.1689') syntax because that wasn't added until
                            " 7.4.237, and we want to be sure this works for everyone (this is also why
                            " we're not using utils#EchoError()).
                            "
                            " Version 7.4.1689 was chosen because that's what the most recent Ubuntu LTS
                            " release (16.04) uses.
    1   0.000505   0.000056 if
                                  \ go#config#VersionWarning() != 0 &&
                                  \ (v:version < 704 || (v:version == 704 && !has('patch1689')))
                                  \ && !has('nvim')
                              echohl Error
                              echom "vim-go requires Vim 7.4.1689 or Neovim, but you're using an older version."
                              echom "Please update your Vim for the best vim-go experience."
                              echom "If you really want to continue you can set this to make the error go away:"
                              echom "    let g:go_version_warning = 0"
                              echom "Note that some features may error out or behave incorrectly."
                              echom "Please do not report bugs unless you're using Vim 7.4.1689 or newer."
                              echohl None
                            
                              " Make sure people see this.
                              sleep 2
                            endif
                            
                            " these packages are used by vim-go and can be automatically installed if
                            " needed by the user with GoInstallBinaries
    1              0.000032 let s:packages = {
                                  \ 'asmfmt':        ['github.com/klauspost/asmfmt/cmd/asmfmt'],
                                  \ 'dlv':           ['github.com/derekparker/delve/cmd/dlv'],
                                  \ 'errcheck':      ['github.com/kisielk/errcheck'],
                                  \ 'fillstruct':    ['github.com/davidrjenni/reftools/cmd/fillstruct'],
                                  \ 'gocode':        ['github.com/nsf/gocode', {'windows': ['-ldflags', '-H=windowsgui']}],
                                  \ 'godef':         ['github.com/rogpeppe/godef'],
                                  \ 'gogetdoc':      ['github.com/zmb3/gogetdoc'],
                                  \ 'goimports':     ['golang.org/x/tools/cmd/goimports'],
                                  \ 'golint':        ['github.com/golang/lint/golint'],
                                  \ 'gometalinter':  ['github.com/alecthomas/gometalinter'],
                                  \ 'gomodifytags':  ['github.com/fatih/gomodifytags'],
                                  \ 'gorename':      ['golang.org/x/tools/cmd/gorename'],
                                  \ 'gotags':        ['github.com/jstemmer/gotags'],
                                  \ 'guru':          ['golang.org/x/tools/cmd/guru'],
                                  \ 'impl':          ['github.com/josharian/impl'],
                                  \ 'keyify':        ['github.com/dominikh/go-tools/cmd/keyify'],
                                  \ 'motion':        ['github.com/fatih/motion'],
                                  \ 'iferr':         ['github.com/koron/iferr'],
                            \ }
                            
                            " These commands are available on any filetypes
    1              0.000007 command! -nargs=* -complete=customlist,s:complete GoInstallBinaries call s:GoInstallBinaries(-1, <f-args>)
    1              0.000005 command! -nargs=* -complete=customlist,s:complete GoUpdateBinaries  call s:GoInstallBinaries(1, <f-args>)
    1              0.000004 command! -nargs=? -complete=dir GoPath call go#path#GoPath(<f-args>)
                            
    1              0.000003 fun! s:complete(lead, cmdline, cursor)
                              return filter(keys(s:packages), 'strpart(v:val, 0, len(a:lead)) == a:lead')
                            endfun
                            
                            " GoInstallBinaries downloads and installs binaries defined in s:packages to
                            " $GOBIN or $GOPATH/bin. GoInstallBinaries will update already installed
                            " binaries only if updateBinaries = 1. By default, all packages in s:packages
                            " will be installed, but the set can be limited by passing the desired
                            " packages in the unnamed arguments.
    1              0.000002 function! s:GoInstallBinaries(updateBinaries, ...)
                              let err = s:CheckBinaries()
                              if err != 0
                                return
                              endif
                            
                              if go#path#Default() == ""
                                echohl Error
                                echomsg "vim.go: $GOPATH is not set and 'go env GOPATH' returns empty"
                                echohl None
                                return
                              endif
                            
                              let go_bin_path = go#path#BinPath()
                            
                              " change $GOBIN so go get can automatically install to it
                              let $GOBIN = go_bin_path
                            
                              " old_path is used to restore users own path
                              let old_path = $PATH
                            
                              " vim's executable path is looking in PATH so add our go_bin path to it
                              let $PATH = go_bin_path . go#util#PathListSep() . $PATH
                            
                              " when shellslash is set on MS-* systems, shellescape puts single quotes
                              " around the output string. cmd on Windows does not handle single quotes
                              " correctly. Unsetting shellslash forces shellescape to use double quotes
                              " instead.
                              let resetshellslash = 0
                              if has('win32') && &shellslash
                                let resetshellslash = 1
                                set noshellslash
                              endif
                            
                              let l:cmd = ['go', 'get', '-v']
                              if get(g:, "go_get_update", 1) != 0
                                let l:cmd += ['-u']
                              endif
                            
                              " Filter packages from arguments (if any).
                              let l:packages = {}
                              if a:0 > 0
                                for l:bin in a:000
                                  let l:pkg = get(s:packages, l:bin, [])
                                  if len(l:pkg) == 0
                                    call go#util#EchoError('unknown binary: ' . l:bin)
                                    return
                                  endif
                                  let l:packages[l:bin] = l:pkg
                                endfor
                              else
                                let l:packages = s:packages
                              endif
                            
                              let l:platform = ''
                              if go#util#IsWin()
                                let l:platform = 'windows'
                              endif
                            
                              for [binary, pkg] in items(l:packages)
                                let l:importPath = pkg[0]
                            
                                let l:run_cmd = copy(l:cmd)
                                if len(l:pkg) > 1 && get(l:pkg[1], l:platform, '') isnot ''
                                  let l:run_cmd += get(l:pkg[1], l:platform, '')
                                endif
                            
                                let binname = "go_" . binary . "_bin"
                            
                                let bin = binary
                                if exists("g:{binname}")
                                  let bin = g:{binname}
                                endif
                            
                                if !executable(bin) || a:updateBinaries == 1
                                  if a:updateBinaries == 1
                                    echo "vim-go: Updating " . binary . ". Reinstalling ". importPath . " to folder " . go_bin_path
                                  else
                                    echo "vim-go: ". binary ." not found. Installing ". importPath . " to folder " . go_bin_path
                                  endif
                            
                                  let [l:out, l:err] = go#util#Exec(l:run_cmd + [l:importPath])
                                  if l:err
                                    echom "Error installing " . l:importPath . ": " . l:out
                                  endif
                                endif
                              endfor
                            
                              " restore back!
                              let $PATH = old_path
                              if resetshellslash
                                set shellslash
                              endif
                            endfunction
                            
                            " CheckBinaries checks if the necessary binaries to install the Go tool
                            " commands are available.
    1              0.000002 function! s:CheckBinaries()
                              if !executable('go')
                                echohl Error | echomsg "vim-go: go executable not found." | echohl None
                                return -1
                              endif
                            
                              if !executable('git')
                                echohl Error | echomsg "vim-go: git executable not found." | echohl None
                                return -1
                              endif
                            endfunction
                            
                            " Autocommands
                            " ============================================================================
                            "
    1              0.000001 function! s:echo_go_info()
                              if !get(g:, "go_echo_go_info", 1)
                                return
                              endif
                            
                              if !exists('v:completed_item') || empty(v:completed_item)
                                return
                              endif
                              let item = v:completed_item
                            
                              if !has_key(item, "info")
                                return
                              endif
                            
                              if empty(item.info)
                                return
                              endif
                            
                              redraws! | echo "vim-go: " | echohl Function | echon item.info | echohl None
                            endfunction
                            
    1              0.000001 function! s:auto_type_info()
                              " GoInfo automatic update
                              if get(g:, "go_auto_type_info", 0)
                                call go#tool#Info(1)
                              endif
                            endfunction
                            
    1              0.000001 function! s:auto_sameids()
                              " GoSameId automatic update
                              if get(g:, "go_auto_sameids", 0)
                                call go#guru#SameIds()
                              endif
                            endfunction
                            
    1              0.000001 function! s:fmt_autosave()
                              " Go code formatting on save
                              if get(g:, "go_fmt_autosave", 1)
                                call go#fmt#Format(-1)
                              endif
                            endfunction
                            
    1              0.000001 function! s:asmfmt_autosave()
                              " Go asm formatting on save
                              if get(g:, "go_asmfmt_autosave", 0)
                                call go#asmfmt#Format()
                              endif
                            endfunction
                            
    1              0.000001 function! s:metalinter_autosave()
                              " run gometalinter on save
                              if get(g:, "go_metalinter_autosave", 0)
                                call go#lint#Gometa(1)
                              endif
                            endfunction
                            
    1              0.000001 function! s:template_autocreate()
                              " create new template from scratch
                              if get(g:, "go_template_autocreate", 1)
                                call go#template#create()
                              endif
                            endfunction
                            
    1              0.000001 augroup vim-go
    1              0.000019   autocmd!
                            
    1              0.000004   autocmd CursorHold *.go call s:auto_type_info()
    1              0.000002   autocmd CursorHold *.go call s:auto_sameids()
                            
                              " Echo the identifier information when completion is done. Useful to see
                              " the signature of a function, etc...
    1              0.000003   if exists('##CompleteDone')
    1              0.000003     autocmd CompleteDone *.go call s:echo_go_info()
    1              0.000001   endif
                            
    1              0.000003   autocmd BufWritePre *.go call s:fmt_autosave()
    1              0.000003   autocmd BufWritePre *.s call s:asmfmt_autosave()
    1              0.000003   autocmd BufWritePost *.go call s:metalinter_autosave()
    1              0.000004   autocmd BufNewFile *.go call s:template_autocreate()
                              " clear SameIds when the buffer is unloaded so that loading another buffer
                              " in the same window doesn't highlight the most recently matched
                              " identifier's positions.
    1              0.000002   autocmd BufWinEnter *.go call go#guru#ClearSameIds()
                            
    1              0.000007   autocmd BufEnter *.go
                                    \  if go#config#AutodetectGopath() && !exists('b:old_gopath')
                                    \|   let b:old_gopath = exists('$GOPATH') ? $GOPATH : -1
                                    \|   let $GOPATH = go#path#Detect()
                                    \| endif
    1              0.000005   autocmd BufLeave *.go
                                    \  if exists('b:old_gopath')
                                    \|   if b:old_gopath isnot -1
                                    \|     let $GOPATH = b:old_gopath
                                    \|   endif
                                    \|   unlet b:old_gopath
                                    \| endif
    1              0.000001 augroup end
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/greg/.config/nvim/plugged/vim-go/autoload/go/config.vim
Sourced 1 time
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
    1              0.000003 function! go#config#AutodetectGopath() abort
                            	return get(g:, 'go_autodetect_gopath', 0)
                            endfunction
                            
    1              0.000001 function! go#config#ListTypeCommands() abort
                              return get(g:, 'go_list_type_commands', {})
                            endfunction
                            
    1              0.000001 function! go#config#VersionWarning() abort
                              return get(g:, 'go_version_warning', 1)
                            endfunction
                            
    1              0.000001 function! go#config#BuildTags() abort
                              return get(g:, 'go_build_tags', '')
                            endfunction
                            
    1              0.000002 function! go#config#SetBuildTags(value) abort
                              if a:value is ''
                                silent! unlet g:go_build_tags
                                return
                              endif
                            
                              let g:go_build_tags = a:value
                            endfunction
                            
    1              0.000002 function! go#config#TestTimeout() abort
                             return get(g:, 'go_test_timeout', '10s')
                            endfunction
                            
    1              0.000001 function! go#config#TestShowName() abort
                              return get(g:, 'go_test_show_name', 0)
                            endfunction
                            
    1              0.000001 function! go#config#TermHeight() abort
                              return get(g:, 'go_term_height', winheight(0))
                            endfunction
                            
    1              0.000001 function! go#config#TermWidth() abort
                              return get(g:, 'go_term_width', winwidth(0))
                            endfunction
                            
    1              0.000001 function! go#config#TermMode() abort
                              return get(g:, 'go_term_mode', 'vsplit')
                            endfunction
                            
    1              0.000001 function! go#config#TermEnabled() abort
                              return get(g:, 'go_term_enabled', 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetTermEnabled(value) abort
                              let g:go_term_enabled = a:value
                            endfunction
                            
    1              0.000001 function! go#config#TemplateUsePkg() abort
                              return get(g:, 'go_template_use_pkg', 0)
                            endfunction
                            
    1              0.000001 function! go#config#TemplateTestFile() abort
                              return get(g:, 'go_template_test_file', "hello_world_test.go")
                            endfunction
                            
    1              0.000001 function! go#config#TemplateFile() abort
                              return get(g:, 'go_template_file', "hello_world.go")
                            endfunction
                            
    1              0.000001 function! go#config#StatuslineDuration() abort
                              return get(g:, 'go_statusline_duration', 60000)
                            endfunction
                            
    1              0.000001 function! go#config#SnippetEngine() abort
                              return get(g:, 'go_snippet_engine', 'automatic')
                            endfunction
                            
    1              0.000001 function! go#config#PlayBrowserCommand() abort
                                if go#util#IsWin()
                                    let go_play_browser_command = '!start rundll32 url.dll,FileProtocolHandler %URL%'
                                elseif go#util#IsMac()
                                    let go_play_browser_command = 'open %URL%'
                                elseif executable('xdg-open')
                                    let go_play_browser_command = 'xdg-open %URL%'
                                elseif executable('firefox')
                                    let go_play_browser_command = 'firefox %URL% &'
                                elseif executable('chromium')
                                    let go_play_browser_command = 'chromium %URL% &'
                                else
                                    let go_play_browser_command = ''
                                endif
                            
                                return get(g:, 'go_play_browser_command', go_play_browser_command)
                            endfunction
                            
    1              0.000001 function! go#config#MetalinterDeadline() abort
                              " gometalinter has a default deadline of 5 seconds only when asynchronous
                              " jobs are not supported.
                            
                              let deadline = '5s'
                              if go#util#has_job() && has('lambda')
                                let deadline = ''
                              endif
                            
                              return get(g:, 'go_metalinter_deadline', deadline)
                            endfunction
                            
    1              0.000001 function! go#config#ListType() abort
                              return get(g:, 'go_list_type', '')
                            endfunction
                            
    1              0.000001 function! go#config#ListAutoclose() abort
                              return get(g:, 'go_list_autoclose', 1)
                            endfunction
                            
    1              0.000001 function! go#config#InfoMode() abort
                              return get(g:, 'go_info_mode', 'gocode')
                            endfunction
                            
    1              0.000001 function! go#config#GuruScope() abort
                              let scope = get(g:, 'go_guru_scope', [])
                            
                              if !empty(scope)
                                " strip trailing slashes for each path in scope. bug:
                                " https://github.com/golang/go/issues/14584
                                let scopes = go#util#StripTrailingSlash(scope)
                              endif
                            
                              return scope
                            endfunction
                            
    1              0.000001 function! go#config#SetGuruScope(scope) abort
                              if empty(a:scope)
                                if exists('g:go_guru_scope')
                                  unlet g:go_guru_scope
                                endif
                              else
                                let g:go_guru_scope = a:scope
                              endif
                            endfunction
                            
    1              0.000002 function! go#config#GocodeUnimportedPackages() abort
                              return get(g:, 'go_gocode_unimported_packages', 0)
                            endfunction
                            
    1              0.000008 let s:sock_type = (has('win32') || has('win64')) ? 'tcp' : 'unix'
    1              0.000002 function! go#config#GocodeSocketType() abort
                              return get(g:, 'go_gocode_socket_type', s:sock_type)
                            endfunction
                            
    1              0.000001 function! go#config#GocodeProposeBuiltins() abort
                              return get(g:, 'go_gocode_propose_builtins', 1)
                            endfunction
                            
    1              0.000001 function! go#config#GocodeAutobuild() abort
                              return get(g:, 'go_gocode_autobuild', 1)
                            endfunction
                            
    1              0.000003 function! go#config#EchoCommandInfo() abort
                              return get(g:, 'go_echo_command_info', 1)
                            endfunction
                            
    1              0.000001 function! go#config#DocUrl() abort
                              let godoc_url = get(g:, 'go_doc_url', 'https://godoc.org')
                              if godoc_url isnot 'https://godoc.org'
                                " strip last '/' character if available
                                let last_char = strlen(godoc_url) - 1
                                if godoc_url[last_char] == '/'
                                  let godoc_url = strpart(godoc_url, 0, last_char)
                                endif
                                " custom godoc installations expect /pkg before package names
                                let godoc_url .= "/pkg"
                              endif
                              return godoc_url
                            endfunction
                            
    1              0.000001 function! go#config#DefReuseBuffer() abort
                              return get(g:, 'go_def_reuse_buffer', 0)
                            endfunction
                            
    1              0.000001 function! go#config#DefMode() abort
                              return get(g:, 'go_def_mode', 'guru')
                            endfunction
                            
    1              0.000001 function! go#config#DeclsIncludes() abort
                              return get(g:, 'go_decls_includes', 'func,type')
                            endfunction
                            
    1              0.000001 function! go#config#Debug() abort
                              return get(g:, 'go_debug', [])
                            endfunction
                            
    1              0.000001 function! go#config#DebugWindows() abort
                              return get(g:, 'go_debug_windows', {
                                        \ 'stack': 'leftabove 20vnew',
                                        \ 'out':   'botright 10new',
                                        \ 'vars':  'leftabove 30vnew',
                                        \ }
                                     \ )
                            
                            endfunction
                            
    1              0.000001 function! go#config#DebugAddress() abort
                              return get(g:, 'go_debug_address', '127.0.0.1:8181')
                            endfunction
                            
    1              0.000001 function! go#config#DebugCommands() abort
                              " make sure g:go_debug_commands is set so that it can be added to easily.
                              let g:go_debug_commands = get(g:, 'go_debug_commands', {})
                              return g:go_debug_commands
                            endfunction
                            
    1              0.000001 function! go#config#SetDebugDiag(value) abort
                              let g:go_debug_diag = a:value
                            endfunction
                            
    1              0.000001 function! go#config#AutoSameids() abort
                                return get(g:, 'go_auto_sameids', 0)
                            endfunction
                            
    1              0.000001 function! go#config#SetAutoSameids(value) abort
                              let g:go_auto_sameids = a:value
                            endfunction
                            
    1              0.000001 function! go#config#AddtagsTransform() abort
                              return get(g:, 'go_addtags_transform', "snakecase")
                            endfunction
                            
    1              0.000001 function! go#config#TemplateAutocreate() abort
                              return get(g:, "go_template_autocreate", 1)
                            endfunction
                            
    1              0.000002 function! go#config#SetTemplateAutocreate(value) abort
                              let g:go_template_autocreate = a:value
                            endfunction
                            
    1              0.000001 function! go#config#MetalinterCommand() abort
                              return get(g:, "go_metalinter_command", "")
                            endfunction
                            
    1              0.000002 function! go#config#MetalinterAutosaveEnabled() abort
                              return get(g:, 'go_metalinter_autosave_enabled', ['vet', 'golint'])
                            endfunction
                            
    1              0.000003 function! go#config#MetalinterEnabled() abort
                              return get(g:, "go_metalinter_enabled", ['vet', 'golint', 'errcheck'])
                            endfunction
                            
    1              0.000001 function! go#config#MetalinterDisabled() abort
                              return get(g:, "go_metalinter_disabled", [])
                            endfunction
                            
    1              0.000001 function! go#config#GolintBin() abort
                              return get(g:, "go_golint_bin", "golint")
                            endfunction
                            
    1              0.000001 function! go#config#ErrcheckBin() abort
                              return get(g:, "go_errcheck_bin", "errcheck")
                            endfunction
                            
    1              0.000001 function! go#config#MetalinterAutosave() abort
                              return get(g:, "go_metalinter_autosave", 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetMetalinterAutosave(value) abort
                              let g:go_metalinter_autosave = a:value
                            endfunction
                            
    1              0.000001 function! go#config#ListHeight() abort
                              return get(g:, "go_list_height", 0)
                            endfunction
                            
    1              0.000001 function! go#config#FmtAutosave() abort
                            	return get(g:, "go_fmt_autosave", 1)
                            endfunction
                            
    1              0.000001 function! go#config#SetFmtAutosave(value) abort
                              let g:go_fmt_autosave = a:value
                            endfunction
                            
    1              0.000001 function! go#config#AsmfmtAutosave() abort
                              return get(g:, "go_asmfmt_autosave", 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetAsmfmtAutosave(value) abort
                              let g:go_asmfmt_autosave = a:value
                            endfunction
                            
    1              0.000001 function! go#config#DocMaxHeight() abort
                              return get(g:, "go_doc_max_height", 20)
                            endfunction
                            
    1              0.000001 function! go#config#AutoTypeInfo() abort
                              return get(g:, "go_auto_type_info", 0)
                            endfunction
                            
    1              0.000002 function! go#config#SetAutoTypeInfo(value) abort
                              let g:go_auto_type_info = a:value
                            endfunction
                            
    1              0.000001 function! go#config#AlternateMode() abort
                              return get(g:, "go_alternate_mode", "edit")
                            endfunction
                            
    1              0.000001 function! go#config#DeclsMode() abort
                              return get(g:, "go_decls_mode", "")
                            endfunction
                            
    1              0.000001 function! go#config#DocCommand() abort
                              return get(g:, "go_doc_command", ["godoc"])
                            endfunction
                            
    1              0.000001 function! go#config#FmtCommand() abort
                              return get(g:, "go_fmt_command", "gofmt")
                            endfunction
                            
    1              0.000001 function! go#config#FmtOptions() abort
                              return get(g:, "go_fmt_options", {})
                            endfunction
                            
    1              0.000001 function! go#config#FmtFailSilently() abort
                              return get(g:, "go_fmt_fail_silently", 0)
                            endfunction
                            
    1              0.000001 function! go#config#FmtExperimental() abort
                              return get(g:, "go_fmt_experimental", 0 )
                            endfunction
                            
    1              0.000001 function! go#config#PlayOpenBrowser() abort
                              return get(g:, "go_play_open_browser", 1)
                            endfunction
                            
    1              0.000001 function! go#config#GorenameBin() abort
                              return get(g:, "go_gorename_bin", "gorename")
                            endfunction
                            
    1              0.000001 function! go#config#GorenamePrefill() abort
                              return get(g:, "go_gorename_prefill", 'expand("<cword>") =~# "^[A-Z]"' .
                                      \ '? go#util#pascalcase(expand("<cword>"))' .
                                      \ ': go#util#camelcase(expand("<cword>"))')
                            endfunction
                            
    1              0.000002 function! go#config#TextobjIncludeFunctionDoc() abort
                              return get(g:, "go_textobj_include_function_doc", 1)
                            endfunction
                            
    1              0.000001 function! go#config#TextobjIncludeVariable() abort
                              return get(g:, "go_textobj_include_variable", 1)
                            endfunction
                            
    1              0.000001 function! go#config#BinPath() abort
                              return get(g:, "go_bin_path", "")
                            endfunction
                            
    1              0.000002 function! go#config#HighlightArrayWhitespaceError() abort
                              return get(g:, 'go_highlight_array_whitespace_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightChanWhitespaceError() abort
                              return get(g:, 'go_highlight_chan_whitespace_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightExtraTypes() abort
                              return get(g:, 'go_highlight_extra_types', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightSpaceTabError() abort
                              return get(g:, 'go_highlight_space_tab_error', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightTrailingWhitespaceError() abort
                              return get(g:, 'go_highlight_trailing_whitespace_error', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightOperators() abort
                              return get(g:, 'go_highlight_operators', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightFunctions() abort
                              return get(g:, 'go_highlight_functions', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFunctionArguments() abort
                              return get(g:, 'go_highlight_function_arguments', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightFunctionCalls() abort
                              return get(g:, 'go_highlight_function_calls', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFields() abort
                              return get(g:, 'go_highlight_fields', 0)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightTypes() abort
                              return get(g:, 'go_highlight_types', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightBuildConstraints() abort
                              return get(g:, 'go_highlight_build_constraints', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightStringSpellcheck() abort
                              return get(g:, 'go_highlight_string_spellcheck', 1)
                            endfunction
                            
    1              0.000002 function! go#config#HighlightFormatStrings() abort
                              return get(g:, 'go_highlight_format_strings', 1)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightGenerateTags() abort
                              return get(g:, 'go_highlight_generate_tags', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightVariableAssignments() abort
                              return get(g:, 'go_highlight_variable_assignments', 0)
                            endfunction
                            
    1              0.000001 function! go#config#HighlightVariableDeclarations() abort
                              return get(g:, 'go_highlight_variable_declarations', 0)
                            endfunction
                            
    1              0.000002 function go#config#FoldEnable(...) abort
                              if a:0 > 0
                                return index(go#config#FoldEnable(), a:1) > -1
                              endif
                              return get(g:, 'go_fold_enable', ['block', 'import', 'varconst', 'package_comment'])
                            endfunction
                            
                            " Set the default value. A value of "1" is a shortcut for this, for
                            " compatibility reasons.
    1              0.000003 if exists("g:go_gorename_prefill") && g:go_gorename_prefill == 1
                              unlet g:go_gorename_prefill
                            endif
                            
                            " vim: sw=2 ts=2 et

SCRIPT  /home/greg/.config/nvim/plugged/neoformat/plugin/neoformat.vim
Sourced 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000011 command! -nargs=? -bar -range=% -bang -complete=customlist,neoformat#CompleteFormatters Neoformat
                                        \ call neoformat#Neoformat(<bang>0, <q-args>, <line1>, <line2>)

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/plugin/airline.vim
Sourced 1 time
Total time:   0.001991
 Self time:   0.000283

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000009 if &cp || v:version < 702 || (exists('g:loaded_airline') && g:loaded_airline)
                              finish
                            endif
    1              0.000003 let g:loaded_airline = 1
                            
    1              0.000004 let s:airline_initialized = 0
    1              0.000002 function! s:init()
                              if s:airline_initialized
                                return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')
                            endfunction
                            
    1              0.000012 let s:active_winnr = -1
    1              0.000002 function! s:on_window_changed()
                              let s:active_winnr = winnr()
                            
                              if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
                              let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
                              if get(g:, 'airline_last_window_changed', []) == l:key
                                    \ && &stl is# '%!airline#statusline('.s:active_winnr.')'
                                    \ && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
                                return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()
                            endfunction
                            
    1              0.000001 function! s:on_colorscheme_changed()
                              call s:init()
                              unlet! g:airline#highlighter#normal_fg_hi
                              call airline#highlighter#reset_hlcache()
                              let g:airline_gui_mode = airline#init#gui_mode()
                              if !s:theme_in_vimrc
                                call airline#switch_matching_theme()
                              endif
                            
                              " couldn't find a match, or theme was defined, just refresh
                              call airline#load_theme()
                            endfunction
                            
    1   0.000253   0.000059 function! airline#cmdwinenter(...)
                              call airline#extensions#apply_left_override('Command Line', '')
                            endfunction
                            
    1              0.000001 function! s:airline_toggle()
                              if exists("#airline")
                                augroup airline
                                  au!
                                augroup END
                                augroup! airline
                            
                                if exists("s:stl")
                                  let &stl = s:stl
                                endif
                                call airline#highlighter#reset_hlcache()
                            
                                call airline#util#doautocmd('AirlineToggledOff')
                              else
                                let s:stl = &statusline
                                augroup airline
                                  autocmd!
                            
                                  autocmd CmdwinEnter *
                                        \ call airline#add_statusline_func('airline#cmdwinenter')
                                        \ | call <sid>on_window_changed()
                                  autocmd CmdwinLeave * call airline#remove_statusline_func('airline#cmdwinenter')
                            
                                  autocmd GUIEnter,ColorScheme * call <sid>on_colorscheme_changed()
                                  if exists("##OptionSet")
                                    " Make sure that g_airline_gui_mode is refreshed
                                    autocmd OptionSet termguicolors call <sid>on_colorscheme_changed()
                                  endif
                                  " Set all statuslines to inactive
                                  autocmd FocusLost * call airline#update_statusline_focuslost()
                                  " Refresh airline for :syntax off
                                  autocmd SourcePre */syntax/syntax.vim
                                        \ call airline#extensions#tabline#buffers#invalidate()
                                  autocmd VimEnter,WinEnter,BufWinEnter,FileType,BufUnload *
                                        \ call <sid>on_window_changed()
                                  if exists('##CompleteDone')
                                    autocmd CompleteDone * call <sid>on_window_changed()
                                  endif
                                  " non-trivial number of external plugins use eventignore=all, so we need to account for that
                                  autocmd CursorMoved *
                                        \   if winnr() != s:active_winnr
                                        \ |   call <sid>on_window_changed()
                                        \ | endif
                            
                                  autocmd VimResized * unlet! w:airline_lastmode | :call <sid>airline_refresh()
                                  if exists('*timer_start') && exists('*funcref')
                                    " do not trigger FocusGained on startup, it might erase the intro screen (see #1817)
                                    " needs funcref() (needs 7.4.2137) and timers (7.4.1578)
                                    let Handler=funcref('<sid>FocusGainedHandler')
                                    let s:timer=timer_start(5000, Handler)
                                  else
                                    autocmd FocusGained * unlet! w:airline_lastmode | :call <sid>airline_refresh()
                                  endif
                            
                                  if exists("##TerminalOpen")
                                    " Using the same function with the TermOpen autocommand
                                    " breaks for Neovim see #1828, looks like a neovim bug.
                                    autocmd TerminalOpen * :call airline#load_theme() " reload current theme for Terminal, forces the terminal extension to be loaded
                                  endif
                                  autocmd TabEnter * :unlet! w:airline_lastmode | let w:airline_active=1
                                  autocmd BufWritePost */autoload/airline/themes/*.vim
                                        \ exec 'source '.split(globpath(&rtp, 'autoload/airline/themes/'.g:airline_theme.'.vim', 1), "\n")[0]
                                        \ | call airline#load_theme()
                                augroup END
                            
                                if &laststatus < 2
                                  set laststatus=2
                                endif
                                if s:airline_initialized
                                  call s:on_window_changed()
                                endif
                            
                                call airline#util#doautocmd('AirlineToggledOn')
                              endif
                            endfunction
                            
    1              0.000002 function! s:get_airline_themes(a, l, p)
                              return airline#util#themes(a:a)
                            endfunction
                            
    1              0.000001 function! s:airline_theme(...)
                              if a:0
                                try
                                  call airline#switch_theme(a:1)
                                catch " discard error
                                endtry
                              else
                                echo g:airline_theme
                              endif
                            endfunction
                            
    1              0.000001 function! s:airline_refresh()
                              if !exists("#airline")
                                " disabled
                                return
                              endif
                              call airline#util#doautocmd('AirlineBeforeRefresh')
                              call airline#highlighter#reset_hlcache()
                              call airline#load_theme()
                              call airline#update_statusline()
                            endfunction
                            
    1              0.000001 function! s:FocusGainedHandler(timer)
                              if exists("s:timer") && a:timer == s:timer
                                augroup airline
                                  au FocusGained * unlet! w:airline_lastmode | :call <sid>airline_refresh()
                                augroup END
                              endif
                            endfu
                            
    1              0.000002 function! s:airline_extensions()
                              let loaded = airline#extensions#get_loaded_extensions()
                              let files = split(globpath(&rtp, "autoload/airline/extensions/*.vim"), "\n")
                              call map(files, 'fnamemodify(v:val, ":t:r")')
                              if !empty(files)
                                echohl Title
                                echo printf("%-15s\t%s", "Extension", "Status")
                                echohl Normal
                              endif
                              for ext in sort(files)
                                echo printf("%-15s\t%sloaded", ext, (index(loaded, ext) == -1 ? 'not ' : ''))
                              endfor
                            endfunction
                            
    1              0.000006 command! -bar -nargs=? -complete=customlist,<sid>get_airline_themes AirlineTheme call <sid>airline_theme(<f-args>)
    1              0.000005 command! -bar AirlineToggleWhitespace call airline#extensions#whitespace#toggle()
    1              0.000003 command! -bar AirlineToggle  call s:airline_toggle()
    1              0.000003 command! -bar AirlineRefresh call s:airline_refresh()
    1              0.000003 command! AirlineExtensions   call s:airline_extensions()
                            
    1   0.001235   0.000055 call airline#init#bootstrap()
    1   0.000340   0.000005 call s:airline_toggle()

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline.vim
Sourced 1 time
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000006 let g:airline_statusline_funcrefs = get(g:, 'airline_statusline_funcrefs', [])
                            
    1              0.000003 let s:sections = ['a','b','c','gutter','x','y','z', 'error', 'warning']
    1              0.000002 let s:inactive_funcrefs = []
    1              0.000001 let s:contexts = {}
    1              0.000015 let s:core_funcrefs = [
                                  \ function('airline#extensions#apply'),
                                  \ function('airline#extensions#default#apply') ]
                            
                            
    1              0.000002 function! airline#add_statusline_func(name)
                              call airline#add_statusline_funcref(function(a:name))
                            endfunction
                            
    1              0.000002 function! airline#add_statusline_funcref(function)
                              if index(g:airline_statusline_funcrefs, a:function) >= 0
                                call airline#util#warning(printf('The airline statusline funcref "%s" has already been added.', string(a:function)))
                                return
                              endif
                              call add(g:airline_statusline_funcrefs, a:function)
                            endfunction
                            
    1              0.000002 function! airline#remove_statusline_func(name)
                              let i = index(g:airline_statusline_funcrefs, function(a:name))
                              if i > -1
                                call remove(g:airline_statusline_funcrefs, i)
                              endif
                            endfunction
                            
    1              0.000002 function! airline#add_inactive_statusline_func(name)
                              call add(s:inactive_funcrefs, function(a:name))
                            endfunction
                            
    1              0.000001 function! airline#load_theme()
                              let g:airline_theme = get(g:, 'airline_theme', 'dark')
                              if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
                              let palette = g:airline#themes#{g:airline_theme}#palette
                              call airline#themes#patch(palette)
                            
                              if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
                              call airline#highlighter#load_theme()
                              call airline#extensions#load_theme()
                              call airline#update_statusline()
                            endfunction
                            
                            " Load an airline theme
    1              0.000002 function! airline#switch_theme(name, ...)
                              let silent = get(a:000, '0', 0)
                              " get all available themes
                              let themes = airline#util#themes('')
                              let err = 0
                              try
                                if index(themes, a:name) == -1
                                  " Theme not available
                                  if !silent
                                    call airline#util#warning(printf('The specified theme "%s" cannot be found.', a:name))
                                  endif
                                  throw "not-found"
                                  let err = 1
                                else
                                  exe "ru autoload/airline/themes/". a:name. ".vim"
                                  let g:airline_theme = a:name
                                endif
                              catch /^Vim/
                                " catch only Vim errors, not "not-found"
                                call airline#util#warning(printf('There is an error in theme "%s".', a:name))
                                if &vbs
                                  call airline#util#warning(v:exception)
                                endif
                                let err = 1
                              endtry
                            
                              if err
                                if exists('g:airline_theme')
                                  return
                                else
                                  let g:airline_theme = 'dark'
                                endif
                              endif
                            
                              unlet! w:airline_lastmode
                              call airline#load_theme()
                            
                              call airline#util#doautocmd('AirlineAfterTheme')
                            
                              " this is required to prevent clobbering the startup info message, i don't know why...
                              call airline#check_mode(winnr())
                            endfunction
                            
                            " Try to load the right theme for the current colorscheme
    1              0.000001 function! airline#switch_matching_theme()
                              if exists('g:colors_name')
                                let existing = g:airline_theme
                                let theme = tr(tolower(g:colors_name), '-', '_')
                                try
                                  call airline#switch_theme(theme, 1)
                                  return 1
                                catch
                                  for map in items(g:airline_theme_map)
                                    if match(g:colors_name, map[0]) > -1
                                      try
                                        call airline#switch_theme(map[1], 1)
                                      catch
                                        call airline#switch_theme(existing)
                                      endtry
                                      return 1
                                    endif
                                  endfor
                                endtry
                              endif
                              return 0
                            endfunction
                            
                            " Update the statusline
    1              0.000001 function! airline#update_statusline()
                              if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
                              let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
                              call airline#update_statusline_inactive(range)
                            
                              unlet! w:airline_render_left w:airline_render_right
                              exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
                              let w:airline_active = 1
                              let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
                              call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)
                            endfunction
                            
                            " Function to be called to make all statuslines inactive
                            " Triggered on FocusLost autocommand
    1              0.000001 function! airline#update_statusline_focuslost()
                              if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
                              endif
                            endfunction
                            
                            " Function to draw inactive statuslines for inactive windows
    1              0.000002 function! airline#update_statusline_inactive(range)
                              if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
                              for nr in a:range
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, {
                                        \ 'left_sep': g:airline_left_alt_sep,
                                        \ 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            endfunction
                            
                            " Gather output from all funcrefs which will later be returned by the
                            " airline#statusline() function
    1              0.000002 function! s:invoke_funcrefs(context, funcrefs)
                              let builder = airline#builder#new(a:context)
                              let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
                              if err == 1
                                let a:context.line = builder.build()
                                let s:contexts[a:context.winnr] = a:context
                                call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
                              endif
                            endfunction
                            
                            " Main statusline function per window
                            " will be set to the statusline option
    1              0.000001 function! airline#statusline(winnr)
                              if has_key(s:contexts, a:winnr)
                                return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''
                            endfunction
                            
                            " Check if mode as changed
    1              0.000001 function! airline#check_mode(winnr)
                              if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
                              let context = s:contexts[a:winnr]
                            
                              if get(w:, 'airline_active', 1)
                                let l:m = mode(1)
                                if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
                                elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
                                  let l:mode = ['normal']
                                endif
                                if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
                                  let l:m = l:m[0]
                                endif
                                let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
                              if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
                              if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
                              if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
                              if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
                              if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
                              let mode_string = join(l:mode)
                              if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode, context.bufnr)
                                call airline#util#doautocmd('AirlineModeChanged')
                                let w:airline_lastmode = mode_string
                              endif
                            
                              return ''
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/init.vim
Sourced 1 time
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 function! s:check_defined(variable, default)
                              if !exists(a:variable)
                                let {a:variable} = a:default
                              endif
                            endfunction
                            
    1              0.000002 let s:loaded = 0
    1              0.000002 function! airline#init#bootstrap()
                              if s:loaded
                                return
                              endif
                              let s:loaded = 1
                            
                              let g:airline#init#bootstrapping = 1
                            
                              let g:airline#init#vim_async = (v:version >= 800 && has('job'))
                              let g:airline#init#is_windows = has('win32') || has('win64')
                            
                              call s:check_defined('g:airline_detect_modified', 1)
                              call s:check_defined('g:airline_detect_paste', 1)
                              call s:check_defined('g:airline_detect_crypt', 1)
                              call s:check_defined('g:airline_detect_spell', 1)
                              call s:check_defined('g:airline_detect_spelllang', 1)
                              call s:check_defined('g:airline_detect_iminsert', 0)
                              call s:check_defined('g:airline_inactive_collapse', 1)
                              call s:check_defined('g:airline_exclude_filenames', ['DebuggerWatch','DebuggerStack','DebuggerStatus'])
                              call s:check_defined('g:airline_exclude_filetypes', [])
                              call s:check_defined('g:airline_exclude_preview', 0)
                              call s:check_defined('g:airline_gui_mode', airline#init#gui_mode())
                            
                              call s:check_defined('g:airline_mode_map', {})
                              call extend(g:airline_mode_map, {
                                    \ '__' : '------',
                                    \ 'c'  : 'COMMAND',
                                    \ 'i'  : 'INSERT',
                                    \ 'ic' : 'INSERT COMPL',
                                    \ 'ix' : 'INSERT COMPL',
                                    \ 'n'  : 'NORMAL',
                                    \ 'ni' : '(INSERT)',
                                    \ 'no' : 'OP PENDING',
                                    \ 'R'  : 'REPLACE',
                                    \ 'Rv' : 'V REPLACE',
                                    \ 's'  : 'SELECT',
                                    \ 'S'  : 'S-LINE',
                                    \ '' : 'S-BLOCK',
                                    \ 't'  : 'TERMINAL',
                                    \ 'v'  : 'VISUAL',
                                    \ 'V'  : 'V-LINE',
                                    \ '' : 'V-BLOCK',
                                    \ }, 'keep')
                            
                              call s:check_defined('g:airline_theme_map', {})
                              call extend(g:airline_theme_map, {
                                    \ 'default': 'dark',
                                    \ '\CTomorrow': 'tomorrow',
                                    \ 'base16': 'base16',
                                    \ 'mo[l|n]okai': 'molokai',
                                    \ 'wombat': 'wombat',
                                    \ 'zenburn': 'zenburn',
                                    \ 'solarized': 'solarized',
                                    \ 'flattened': 'solarized',
                                    \ '\CNeoSolarized': 'solarized',
                                    \ }, 'keep')
                            
                              call s:check_defined('g:airline_symbols', {})
                              " First define the symbols,
                              " that are common in Powerline/Unicode/ASCII mode,
                              " then add specific symbols for either mode
                              call extend(g:airline_symbols, {
                                      \ 'paste': 'PASTE',
                                      \ 'spell': 'SPELL',
                                      \ 'modified': '+',
                                      \ 'space': ' ',
                                      \ 'keymap': 'Keymap:',
                                      \ 'ellipsis': '...'
                                      \  }, 'keep')
                            
                              if get(g:, 'airline_powerline_fonts', 0)
                                " Symbols for Powerline terminals
                                call s:check_defined('g:airline_left_sep', "\ue0b0")      " 
                                call s:check_defined('g:airline_left_alt_sep', "\ue0b1")  " 
                                call s:check_defined('g:airline_right_sep', "\ue0b2")     " 
                                call s:check_defined('g:airline_right_alt_sep', "\ue0b3") " 
                                " ro=, ws=☲, lnr=☰, mlnr=, br=, nx=Ɇ, crypt=🔒
                                call extend(g:airline_symbols, {
                                      \ 'readonly': "\ue0a2",
                                      \ 'whitespace': "\u2632",
                                      \ 'linenr': "\u2630 ",
                                      \ 'maxlinenr': " \ue0a1",
                                      \ 'branch': "\ue0a0",
                                      \ 'notexists': "\u0246",
                                      \ 'crypt': nr2char(0x1F512),
                                      \ }, 'keep')
                              elseif &encoding==?'utf-8' && !get(g:, "airline_symbols_ascii", 0)
                                " Symbols for Unicode terminals
                                call s:check_defined('g:airline_left_sep', "")
                                call s:check_defined('g:airline_left_alt_sep', "")
                                call s:check_defined('g:airline_right_sep', "")
                                call s:check_defined('g:airline_right_alt_sep', "")
                                " ro=⊝, ws=☲, lnr=☰, mlnr=㏑, br=ᚠ, nx=Ɇ, crypt=🔒
                                call extend(g:airline_symbols, {
                                      \ 'readonly': "\u229D",
                                      \ 'whitespace': "\u2632",
                                      \ 'linenr': "\u2630 ",
                                      \ 'maxlinenr': " \u33D1",
                                      \ 'branch': "\u16A0",
                                      \ 'notexists': "\u0246",
                                      \ 'crypt': nr2char(0x1F512),
                                      \ }, 'keep')
                              else
                                " Symbols for ASCII terminals
                                call s:check_defined('g:airline_left_sep', "")
                                call s:check_defined('g:airline_left_alt_sep', "")
                                call s:check_defined('g:airline_right_sep', "")
                                call s:check_defined('g:airline_right_alt_sep', "")
                                call extend(g:airline_symbols, {
                                      \ 'readonly': 'RO',
                                      \ 'whitespace': '!',
                                      \ 'linenr': 'ln ',
                                      \ 'maxlinenr': ' :',
                                      \ 'branch': '',
                                      \ 'notexists': '?',
                                      \ 'crypt': 'cr',
                                      \ }, 'keep')
                              endif
                            
                              call airline#parts#define('mode', {
                                    \ 'function': 'airline#parts#mode',
                                    \ 'accent': 'bold',
                                    \ })
                              call airline#parts#define_function('iminsert', 'airline#parts#iminsert')
                              call airline#parts#define_function('paste', 'airline#parts#paste')
                              call airline#parts#define_function('crypt', 'airline#parts#crypt')
                              call airline#parts#define_function('spell', 'airline#parts#spell')
                              call airline#parts#define_function('filetype', 'airline#parts#filetype')
                              call airline#parts#define('readonly', {
                                    \ 'function': 'airline#parts#readonly',
                                    \ 'accent': 'red',
                                    \ })
                              call airline#parts#define_raw('file', '%f%m')
                              call airline#parts#define_raw('path', '%F%m')
                              call airline#parts#define('linenr', {
                                    \ 'raw': '%{g:airline_symbols.linenr}%4l',
                                    \ 'accent': 'bold'})
                              call airline#parts#define('maxlinenr', {
                                    \ 'raw': '/%L%{g:airline_symbols.maxlinenr}',
                                    \ 'accent': 'bold'})
                              call airline#parts#define_function('ffenc', 'airline#parts#ffenc')
                              call airline#parts#define_empty(['hunks', 'branch', 'obsession', 'tagbar',
                                    \ 'syntastic-warn', 'syntastic-err', 'eclim', 'whitespace','windowswap',
                                    \ 'ycm_error_count', 'ycm_warning_count', 'neomake_error_count',
                                    \ 'neomake_warning_count', 'ale_error_count', 'ale_warning_count',
                                    \ 'languageclient_error_count', 'languageclient_warning_count'])
                              call airline#parts#define_text('capslock', '')
                              call airline#parts#define_text('gutentags', '')
                              call airline#parts#define_text('grepper', '')
                              call airline#parts#define_text('xkblayout', '')
                              call airline#parts#define_text('keymap', '')
                            
                              unlet g:airline#init#bootstrapping
                            endfunction
                            
    1              0.000002 function! airline#init#gui_mode()
                              return has('gui_running') || (has("termguicolors") && &termguicolors == 1) ?  'gui' : 'cterm'
                            endfunction
                            
    1              0.000001 function! airline#init#sections()
                              let spc = g:airline_symbols.space
                              if !exists('g:airline_section_a')
                                let g:airline_section_a = airline#section#create_left(['mode', 'crypt', 'paste', 'keymap', 'spell', 'capslock', 'xkblayout', 'iminsert'])
                              endif
                              if !exists('g:airline_section_b')
                                let g:airline_section_b = airline#section#create(['hunks', 'branch'])
                              endif
                              if !exists('g:airline_section_c')
                                if exists("+autochdir") && &autochdir == 1
                                  let g:airline_section_c = airline#section#create(['%<', 'path', spc, 'readonly'])
                                else
                                  let g:airline_section_c = airline#section#create(['%<', 'file', spc, 'readonly'])
                                endif
                              endif
                              if !exists('g:airline_section_gutter')
                                let g:airline_section_gutter = airline#section#create(['%='])
                              endif
                              if !exists('g:airline_section_x')
                                let g:airline_section_x = airline#section#create_right(['tagbar', 'gutentags', 'grepper', 'filetype'])
                              endif
                              if !exists('g:airline_section_y')
                                let g:airline_section_y = airline#section#create_right(['ffenc'])
                              endif
                              if !exists('g:airline_section_z')
                                if winwidth(0) > 80
                                  let g:airline_section_z = airline#section#create(['windowswap', 'obsession', '%3p%%'.spc, 'linenr', 'maxlinenr', spc.':%3v'])
                                else
                                  let g:airline_section_z = airline#section#create(['%3p%%'.spc, 'linenr',  ':%3v'])
                                endif
                              endif
                              if !exists('g:airline_section_error')
                                let g:airline_section_error = airline#section#create(['ycm_error_count', 'syntastic-err', 'eclim', 'neomake_error_count', 'ale_error_count', 'languageclient_error_count'])
                              endif
                              if !exists('g:airline_section_warning')
                                let g:airline_section_warning = airline#section#create(['ycm_warning_count',  'syntastic-warn', 'neomake_warning_count', 'ale_warning_count', 'languageclient_warning_count', 'whitespace'])
                              endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim
Sourced 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 let s:parts = {}
                            
                            " PUBLIC API {{{
                            
    1              0.000002 function! airline#parts#define(key, config)
                              let s:parts[a:key] = get(s:parts, a:key, {})
                              if exists('g:airline#init#bootstrapping')
                                call extend(s:parts[a:key], a:config, 'keep')
                              else
                                call extend(s:parts[a:key], a:config, 'force')
                              endif
                            endfunction
                            
    1              0.000002 function! airline#parts#define_function(key, name)
                              call airline#parts#define(a:key, { 'function': a:name })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_text(key, text)
                              call airline#parts#define(a:key, { 'text': a:text })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_raw(key, raw)
                              call airline#parts#define(a:key, { 'raw': a:raw })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_minwidth(key, width)
                              call airline#parts#define(a:key, { 'minwidth': a:width })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_condition(key, predicate)
                              call airline#parts#define(a:key, { 'condition': a:predicate })
                            endfunction
                            
    1              0.000002 function! airline#parts#define_accent(key, accent)
                              call airline#parts#define(a:key, { 'accent': a:accent })
                            endfunction
                            
    1              0.000001 function! airline#parts#define_empty(keys)
                              for key in a:keys
                                call airline#parts#define_raw(key, '')
                              endfor
                            endfunction
                            
    1              0.000001 function! airline#parts#get(key)
                              return get(s:parts, a:key, {})
                            endfunction
                            
                            " }}}
                            
    1              0.000001 function! airline#parts#mode()
                              return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)
                            endfunction
                            
    1              0.000001 function! airline#parts#crypt()
                              return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''
                            endfunction
                            
    1              0.000001 function! airline#parts#paste()
                              return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''
                            endfunction
                            
    1              0.000001 function! airline#parts#spell()
                              let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
                              if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! airline#parts#iminsert()
                              if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! airline#parts#readonly()
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
                              if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
                              if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
                                return &readonly ? g:airline_symbols.readonly : ''
                              endif
                            endfunction
                            
    1              0.000001 function! airline#parts#filetype()
                              return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype
                            endfunction
                            
    1              0.000001 function! airline#parts#ffenc()
                              let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
                              let bomb     = &l:bomb ? '[BOM]' : ''
                              let ff       = strlen(&ff) ? '['.&ff.']' : ''
                              if expected is# &fenc.bomb.ff
                                return ''
                              else
                                return &fenc.bomb.ff
                              endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/util.vim
Sourced 1 time
Total time:   0.000113
 Self time:   0.000111

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
                            " TODO: Try to cache winwidth(0) function
                            " e.g. store winwidth per window and access that, only update it, if the size
                            " actually changed.
    1              0.000002 scriptencoding utf-8
                            
    1   0.000008   0.000006 call airline#init#bootstrap()
    1              0.000003 let s:spc = g:airline_symbols.space
    1              0.000004 let s:nomodeline = (v:version > 703 || (v:version == 703 && has("patch438"))) ? '<nomodeline>' : ''
                            
    1              0.000002 function! airline#util#shorten(text, winwidth, minwidth, ...)
                              if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
                                return a:text
                              endif
                            endfunction
                            
    1              0.000002 function! airline#util#wrap(text, minwidth)
                              if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
                              return a:text
                            endfunction
                            
    1              0.000002 function! airline#util#append(text, minwidth)
                              if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
                              let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
                              return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text
                            endfunction
                            
    1              0.000001 function! airline#util#warning(msg)
                              echohl WarningMsg
                              echomsg "airline: ".a:msg
                              echohl Normal
                            endfunction
                            
    1              0.000001 function! airline#util#prepend(text, minwidth)
                              if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
                              return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc
                            endfunction
                            
    1              0.000001 if v:version >= 704
    1              0.000002   function! airline#util#getwinvar(winnr, key, def)
                                return getwinvar(a:winnr, a:key, a:def)
                              endfunction
    1              0.000001 else
                              function! airline#util#getwinvar(winnr, key, def)
                                let winvals = getwinvar(a:winnr, '')
                                return get(winvals, a:key, a:def)
                              endfunction
                            endif
                            
    1              0.000001 if v:version >= 704
    1              0.000002   function! airline#util#exec_funcrefs(list, ...)
                                for Fn in a:list
                                  let code = call(Fn, a:000)
                                  if code != 0
                                    return code
                                  endif
                                endfor
                                return 0
                              endfunction
    1              0.000001 else
                              function! airline#util#exec_funcrefs(list, ...)
                                " for 7.2; we cannot iterate the list, hence why we use range()
                                " for 7.3-[97, 328]; we cannot reuse the variable, hence the {}
                                for i in range(0, len(a:list) - 1)
                                  let Fn{i} = a:list[i]
                                  let code = call(Fn{i}, a:000)
                                  if code != 0
                                    return code
                                  endif
                                endfor
                                return 0
                              endfunction
                            endif
                            
                            " Compatibility wrapper for strchars, in case this vim version does not
                            " have it natively
    1              0.000001 function! airline#util#strchars(str)
                              if exists('*strchars')
                                return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif
                            endfunction
                            
    1              0.000001 function! airline#util#ignore_buf(name)
                              let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', '').
                                    \ get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', 
                                    \ 'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
                              return match(a:name, pat) > -1
                            endfunction
                            
    1              0.000001 function! airline#util#has_fugitive()
                              return exists('*fugitive#head') || exists('*FugitiveHead')
                            endfunction
                            
    1              0.000001 function! airline#util#has_lawrencium()
                              return exists('*lawrencium#statusline')
                            endfunction
                            
    1              0.000001 function! airline#util#has_vcscommand()
                              return get(g:, 'airline#extensions#branch#use_vcscommand', 0) && exists('*VCSCommandGetStatusLine')
                            endfunction
                            
    1              0.000001 function! airline#util#has_custom_scm()
                              return !empty(get(g:, 'airline#extensions#branch#custom_head', ''))
                            endfunction
                            
    1              0.000001 function! airline#util#doautocmd(event)
                              exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)
                            endfunction
                            
    1              0.000001 function! airline#util#themes(match)
                              let files = split(globpath(&rtp, 'autoload/airline/themes/'.a:match.'*'), "\n")
                              return map(files, 'fnamemodify(v:val, ":t:r")')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/plugin/ale.vim
Sourced 1 time
Total time:   0.000694
 Self time:   0.000512

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Main entry point for the plugin: sets up prefs and autocommands
                            "   Preferences can be set in vimrc files and so on to configure ale
                            
                            " Sanity Checks
                            
    1              0.000004 if exists('g:loaded_ale_dont_use_this_in_other_plugins_please')
                                finish
                            endif
                            
                            " Set a special flag used only by this plugin for preventing doubly
                            " loading the script.
    1              0.000003 let g:loaded_ale_dont_use_this_in_other_plugins_please = 1
                            
                            " A flag for detecting if the required features are set.
    1              0.000003 if has('nvim')
    1              0.000006     let s:has_features = has('timers') && has('nvim-0.2.0')
    1              0.000001 else
                                " Check if Job and Channel functions are available, instead of the
                                " features. This works better on old MacVim versions.
                                let s:has_features = has('timers') && exists('*job_start') && exists('*ch_close_in')
                            endif
                            
    1              0.000001 if !s:has_features
                                " Only output a warning if editing some special files.
                                if index(['', 'gitcommit'], &filetype) == -1
                                    execute 'echoerr ''ALE requires NeoVim >= 0.2.0 or Vim 8 with +timers +job +channel'''
                                    execute 'echoerr ''Please update your editor appropriately.'''
                                endif
                            
                                " Stop here, as it won't work.
                                finish
                            endif
                            
                            " Set this flag so that other plugins can use it, like airline.
    1              0.000001 let g:loaded_ale = 1
                            
                            " This global variable is used internally by ALE for tracking information for
                            " each buffer which linters are being run against.
    1              0.000004 let g:ale_buffer_info = {}
                            " This global Dictionary tracks data for fixing code. Don't mess with it.
    1              0.000002 let g:ale_fix_buffer_data = {}
                            
                            " User Configuration
                            
                            " This option prevents ALE autocmd commands from being run for particular
                            " filetypes which can cause issues.
    1              0.000004 let g:ale_filetype_blacklist = [
                            \   'dirvish',
                            \   'nerdtree',
                            \   'qf',
                            \   'tags',
                            \   'unite',
                            \]
                            
                            " This Dictionary configures which linters are enabled for which languages.
    1              0.000003 let g:ale_linters = get(g:, 'ale_linters', {})
                            " This option can be changed to only enable explicitly selected linters.
    1              0.000003 let g:ale_linters_explicit = get(g:, 'ale_linters_explicit', 0)
                            
                            " This Dictionary configures which functions will be used for fixing problems.
    1              0.000002 let g:ale_fixers = get(g:, 'ale_fixers', {})
                            
                            " This Dictionary allows users to set up filetype aliases for new filetypes.
    1              0.000003 let g:ale_linter_aliases = get(g:, 'ale_linter_aliases', {})
                            
                            " This flag can be set with a number of milliseconds for delaying the
                            " execution of a linter when text is changed. The timeout will be set and
                            " cleared each time text is changed, so repeated edits won't trigger the
                            " jobs for linting until enough time has passed after editing is done.
    1              0.000004 let g:ale_lint_delay = get(g:, 'ale_lint_delay', 200)
                            
                            " This flag can be set to 'never' to disable linting when text is changed.
                            " This flag can also be set to 'insert' or 'normal' to lint when text is
                            " changed only in insert or normal mode respectively.
    1              0.000003 let g:ale_lint_on_text_changed = get(g:, 'ale_lint_on_text_changed', 'always')
                            
                            " This flag can be set to 1 to enable linting when leaving insert mode.
    1              0.000003 let g:ale_lint_on_insert_leave = get(g:, 'ale_lint_on_insert_leave', 0)
                            
                            " This flag can be set to 0 to disable linting when the buffer is entered.
    1              0.000002 let g:ale_lint_on_enter = get(g:, 'ale_lint_on_enter', 1)
                            
                            " This flag can be set to 1 to enable linting when a buffer is written.
    1              0.000002 let g:ale_lint_on_save = get(g:, 'ale_lint_on_save', 1)
                            
                            " This flag can be set to 1 to enable linting when the filetype is changed.
    1              0.000003 let g:ale_lint_on_filetype_changed = get(g:, 'ale_lint_on_filetype_changed', 1)
                            
                            " This flag can be set to 1 to enable automatically fixing files on save.
    1              0.000002 let g:ale_fix_on_save = get(g:, 'ale_fix_on_save', 0)
                            
                            " This flag may be set to 0 to disable ale. After ale is loaded, :ALEToggle
                            " should be used instead.
    1              0.000002 let g:ale_enabled = get(g:, 'ale_enabled', 1)
                            
                            " These flags dictates if ale uses the quickfix or the loclist (loclist is the
                            " default, quickfix overrides loclist).
    1              0.000002 let g:ale_set_loclist = get(g:, 'ale_set_loclist', 1)
    1              0.000003 let g:ale_set_quickfix = get(g:, 'ale_set_quickfix', 0)
                            
                            " This flag can be set to 0 to disable setting signs.
                            " This is enabled by default only if the 'signs' feature exists.
    1              0.000004 let g:ale_set_signs = get(g:, 'ale_set_signs', has('signs'))
                            
                            " This flag can be set to 0 to disable setting error highlights.
    1              0.000004 let g:ale_set_highlights = get(g:, 'ale_set_highlights', has('syntax'))
                            
                            " This flag can be set to 0 to disable echoing when the cursor moves.
    1              0.000002 let g:ale_echo_cursor = get(g:, 'ale_echo_cursor', 1)
                            
                            " This flag can be set to 1 to automatically show errors in the preview window.
    1              0.000003 let g:ale_cursor_detail = get(g:, 'ale_cursor_detail', 0)
                            
                            " This flag can be set to 1 to enable virtual text when the cursor moves.
    1              0.000003 let g:ale_virtualtext_cursor = get(g:, 'ale_virtualtext_cursor', 0)
                            
                            " This flag can be set to 1 to automatically close the preview window upon
                            " entering Insert Mode.
    1              0.000003 let g:ale_close_preview_on_insert = get(g:, 'ale_close_preview_on_insert', 0)
                            
                            " This flag can be set to 0 to disable balloon support.
    1              0.000005 let g:ale_set_balloons = get(g:, 'ale_set_balloons', has('balloon_eval') && has('gui_running'))
                            
                            " This flag can be set to 0 to disable warnings for trailing whitespace
    1              0.000003 let g:ale_warn_about_trailing_whitespace = get(g:, 'ale_warn_about_trailing_whitespace', 1)
                            " This flag can be set to 0 to disable warnings for trailing blank lines
    1              0.000003 let g:ale_warn_about_trailing_blank_lines = get(g:, 'ale_warn_about_trailing_blank_lines', 1)
                            
                            " A flag for enabling or disabling the command history.
    1              0.000003 let g:ale_history_enabled = get(g:, 'ale_history_enabled', 1)
                            
                            " A flag for storing the full output of commands in the history.
    1              0.000003 let g:ale_history_log_output = get(g:, 'ale_history_log_output', 1)
                            
                            " Enable automatic completion with LSP servers and tsserver
    1              0.000003 let g:ale_completion_enabled = get(g:, 'ale_completion_enabled', 0)
                            
                            " Enable automatic detection of pipenv for Python linters.
    1              0.000003 let g:ale_python_auto_pipenv = get(g:, 'ale_python_auto_pipenv', 0)
                            
    1              0.000001 if g:ale_set_balloons
                                call ale#balloon#Enable()
                            endif
                            
    1              0.000001 if g:ale_completion_enabled
                                call ale#completion#Enable()
                            endif
                            
                            " Define commands for moving through warnings and errors.
    1              0.000005 command! -bar ALEPrevious :call ale#loclist_jumping#Jump('before', 0)
    1              0.000005 command! -bar ALEPreviousWrap :call ale#loclist_jumping#Jump('before', 1)
    1              0.000004 command! -bar ALENext :call ale#loclist_jumping#Jump('after', 0)
    1              0.000004 command! -bar ALENextWrap :call ale#loclist_jumping#Jump('after', 1)
    1              0.000004 command! -bar ALEFirst :call ale#loclist_jumping#JumpToIndex(0)
    1              0.000004 command! -bar ALELast :call ale#loclist_jumping#JumpToIndex(-1)
                            
                            " A command for showing error details.
    1              0.000003 command! -bar ALEDetail :call ale#cursor#ShowCursorDetail()
                            
                            " Define commands for turning ALE on or off.
    1              0.000004 command! -bar ALEToggle :call ale#toggle#Toggle()
    1              0.000003 command! -bar ALEEnable :call ale#toggle#Enable()
    1              0.000003 command! -bar ALEDisable :call ale#toggle#Disable()
    1              0.000003 command! -bar ALEReset :call ale#toggle#Reset()
                            " Commands for turning ALE on or off for a buffer.
    1              0.000004 command! -bar ALEToggleBuffer :call ale#toggle#ToggleBuffer(bufnr(''))
    1              0.000004 command! -bar ALEEnableBuffer :call ale#toggle#EnableBuffer(bufnr(''))
    1              0.000004 command! -bar ALEDisableBuffer :call ale#toggle#DisableBuffer(bufnr(''))
    1              0.000004 command! -bar ALEResetBuffer :call ale#toggle#ResetBuffer(bufnr(''))
                            " A command to stop all LSP-like clients, including tsserver.
    1              0.000004 command! -bar ALEStopAllLSPs :call ale#lsp#reset#StopAllLSPs()
                            
                            " A command for linting manually.
    1              0.000003 command! -bar ALELint :call ale#Queue(0, 'lint_file')
                            
                            " Define a command to get information about current filetype.
    1              0.000005 command! -bar ALEInfo :call ale#debugging#Info()
                            " The same, but copy output to your clipboard.
    1              0.000004 command! -bar ALEInfoToClipboard :call ale#debugging#InfoToClipboard()
                            " Copy ALE information to a file.
    1              0.000005 command! -bar -nargs=1 ALEInfoToFile :call ale#debugging#InfoToFile(<f-args>)
                            
                            " Fix problems in files.
    1              0.000005 command! -bar -nargs=* -complete=customlist,ale#fix#registry#CompleteFixers ALEFix :call ale#fix#Fix(bufnr(''), '', <f-args>)
                            " Suggest registered functions to use for fixing problems.
    1              0.000004 command! -bar ALEFixSuggest :call ale#fix#registry#Suggest(&filetype)
                            
                            " Go to definition for tsserver and LSP
    1              0.000003 command! -bar ALEGoToDefinition :call ale#definition#GoTo({})
    1              0.000006 command! -bar ALEGoToDefinitionInTab :call ale#definition#GoTo({'open_in': 'tab'})
    1              0.000005 command! -bar ALEGoToDefinitionInSplit :call ale#definition#GoTo({'open_in': 'horizontal-split'})
    1              0.000005 command! -bar ALEGoToDefinitionInVSplit :call ale#definition#GoTo({'open_in': 'vertical-split'})
                            
                            " Find references for tsserver and LSP
    1              0.000003 command! -bar ALEFindReferences :call ale#references#Find()
                            
                            " Show summary information for the cursor.
    1              0.000003 command! -bar ALEHover :call ale#hover#ShowAtCursor()
                            
                            " Show documentation for the cursor.
    1              0.000004 command! -bar ALEDocumentation :call ale#hover#ShowDocumentationAtCursor()
                            
                            " Search for appearances of a symbol, such as a type name or function name.
    1              0.000004 command! -nargs=1 ALESymbolSearch :call ale#symbol#Search(<q-args>)
                            
                            " <Plug> mappings for commands
    1              0.000005 nnoremap <silent> <Plug>(ale_previous) :ALEPrevious<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_previous_wrap) :ALEPreviousWrap<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_next) :ALENext<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_next_wrap) :ALENextWrap<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_first) :ALEFirst<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_last) :ALELast<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_toggle) :ALEToggle<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_enable) :ALEEnable<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_disable) :ALEDisable<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_reset) :ALEReset<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_toggle_buffer) :ALEToggleBuffer<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_enable_buffer) :ALEEnableBuffer<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_disable_buffer) :ALEDisableBuffer<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_reset_buffer) :ALEResetBuffer<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_lint) :ALELint<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_detail) :ALEDetail<Return>
    1              0.000003 nnoremap <silent> <Plug>(ale_fix) :ALEFix<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_go_to_definition) :ALEGoToDefinition<Return>
    1              0.000007 nnoremap <silent> <Plug>(ale_go_to_definition_in_tab) :ALEGoToDefinitionInTab<Return>
    1              0.000006 nnoremap <silent> <Plug>(ale_go_to_definition_in_split) :ALEGoToDefinitionInSplit<Return>
    1              0.000006 nnoremap <silent> <Plug>(ale_go_to_definition_in_vsplit) :ALEGoToDefinitionInVSplit<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_find_references) :ALEFindReferences<Return>
    1              0.000004 nnoremap <silent> <Plug>(ale_hover) :ALEHover<Return>
    1              0.000005 nnoremap <silent> <Plug>(ale_documentation) :ALEDocumentation<Return>
                            
                            " Set up autocmd groups now.
    1   0.000246   0.000063 call ale#events#Init()
                            
                            " Housekeeping
                            
    1              0.000001 augroup ALECleanupGroup
    1              0.000013     autocmd!
                                " Clean up buffers automatically when they are unloaded.
    1              0.000004     autocmd BufDelete * if exists('*ale#engine#Cleanup') | call ale#engine#Cleanup(str2nr(expand('<abuf>'))) | endif
    1              0.000003     autocmd QuitPre * call ale#events#QuitEvent(str2nr(expand('<abuf>')))
                            
    1              0.000003     if exists('##VimSuspend')
    1              0.000004       autocmd VimSuspend * if exists('*ale#engine#CleanupEveryBuffer') | call ale#engine#CleanupEveryBuffer() | endif
    1              0.000001     endif
    1              0.000002 augroup END

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/events.vim
Sourced 1 time
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: ALE functions for autocmd events.
                            
                            " Get the number of milliseconds since some vague, but consistent, point in
                            " the past.
                            "
                            " This function can be used for timing execution, etc.
                            "
                            " The time will be returned as a Number.
    1              0.000002 function! ale#events#ClockMilliseconds() abort
                                return float2nr(reltimefloat(reltime()) * 1000)
                            endfunction
                            
    1              0.000002 function! ale#events#QuitEvent(buffer) abort
                                " Remember when ALE is quitting for BufWrite, etc.
                                call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())
                            endfunction
                            
    1              0.000001 function! ale#events#QuitRecently(buffer) abort
                                let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
                                return l:time && ale#events#ClockMilliseconds() - l:time < 1000
                            endfunction
                            
    1              0.000001 function! ale#events#SaveEvent(buffer) abort
                                let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
                                if l:should_lint
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 1)
                                endif
                            
                                if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
                                if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif
                            endfunction
                            
    1              0.000002 function! ale#events#LintOnEnter(buffer) abort
                                " Unmark a file as being changed outside of Vim after we try to check it.
                                call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
                                if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif
                            endfunction
                            
    1              0.000002 function! ale#events#ReadOrEnterEvent(buffer) abort
                                " Apply pattern options if the variable is set.
                                if get(g:, 'ale_pattern_options_enabled', 1)
                                \&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
                                endif
                            
                                " When entering a buffer, we are no longer quitting it.
                                call setbufvar(a:buffer, 'ale_quitting', 0)
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
                                if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
                                endif
                            endfunction
                            
    1              0.000002 function! ale#events#FileTypeEvent(buffer, new_filetype) abort
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
                                let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
                                if l:old_filetype isnot v:null
                                \&& !empty(a:new_filetype)
                                \&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
                                    call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
                                    if g:ale_lint_on_filetype_changed
                                        call ale#Queue(300, 'lint_file', a:buffer)
                                    endif
                                endif
                            endfunction
                            
    1              0.000002 function! ale#events#FileChangedEvent(buffer) abort
                                call setbufvar(a:buffer, 'ale_file_changed', 1)
                            
                                if bufnr('') == a:buffer
                                    call ale#events#LintOnEnter(a:buffer)
                                endif
                            endfunction
                            
    1              0.000001 function! ale#events#Init() abort
                                " This value used to be a Boolean as a Number, and is now a String.
                                let l:text_changed = '' . g:ale_lint_on_text_changed
                            
                                augroup ALEEvents
                                    autocmd!
                            
                                    " These events always need to be set up.
                                    autocmd BufEnter,BufRead * call ale#events#ReadOrEnterEvent(str2nr(expand('<abuf>')))
                                    autocmd BufWritePost * call ale#events#SaveEvent(str2nr(expand('<abuf>')))
                            
                                    if g:ale_enabled
                                        if l:text_changed is? 'always' || l:text_changed is# '1'
                                            autocmd TextChanged,TextChangedI * call ale#Queue(g:ale_lint_delay)
                                        elseif l:text_changed is? 'normal'
                                            autocmd TextChanged * call ale#Queue(g:ale_lint_delay)
                                        elseif l:text_changed is? 'insert'
                                            autocmd TextChangedI * call ale#Queue(g:ale_lint_delay)
                                        endif
                            
                                        if g:ale_lint_on_enter
                                            autocmd BufWinEnter * call ale#events#LintOnEnter(str2nr(expand('<abuf>')))
                                            " Track when the file is changed outside of Vim.
                                            autocmd FileChangedShellPost * call ale#events#FileChangedEvent(str2nr(expand('<abuf>')))
                                        endif
                            
                                        if g:ale_lint_on_filetype_changed
                                            " Only start linting if the FileType actually changes after
                                            " opening a buffer. The FileType will fire when buffers are opened.
                                            autocmd FileType * call ale#events#FileTypeEvent(
                                            \   str2nr(expand('<abuf>')),
                                            \   expand('<amatch>')
                                            \)
                                        endif
                            
                                        if g:ale_lint_on_insert_leave
                                            autocmd InsertLeave * call ale#Queue(0)
                                        endif
                            
                                        if g:ale_echo_cursor || g:ale_cursor_detail
                                            autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarningWithDelay() | endif
                                            " Look for a warning to echo as soon as we leave Insert mode.
                                            " The script's position variable used when moving the cursor will
                                            " not be changed here.
                                            autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#cursor#EchoCursorWarning() | endif
                                        endif
                            
                                        if g:ale_virtualtext_cursor
                                            autocmd CursorMoved,CursorHold * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarningWithDelay() | endif
                                            " Look for a warning to echo as soon as we leave Insert mode.
                                            " The script's position variable used when moving the cursor will
                                            " not be changed here.
                                            autocmd InsertLeave * if exists('*ale#engine#Cleanup') | call ale#virtualtext#ShowCursorWarning() | endif
                                        endif
                            
                                        if g:ale_close_preview_on_insert
                                            autocmd InsertEnter * if exists('*ale#preview#CloseIfTypeMatches') | call ale#preview#CloseIfTypeMatches('ale-preview') | endif
                                        endif
                                    endif
                                augroup END
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-indent-guides/plugin/indent_guides.vim
Sourced 1 time
Total time:   0.000549
 Self time:   0.000246

count  total (s)   self (s)
                            " Author:   Nate Kane <nathanaelkane AT gmail DOT com>
                            " Homepage: http://github.com/nathanaelkane/vim-indent-guides
                            
                            " Do not load if vim is too old
    1              0.000004 if (v:version == 701 && !exists('*matchadd')) || (v:version < 701)
                              finish
                            endif
                            
    1              0.000007 if exists('g:loaded_indent_guides') || &cp
                              finish
                            endif
    1              0.000002 let g:loaded_indent_guides = 1
    1   0.000262   0.000072 call indent_guides#define_default_highlights()
                            
    1              0.000002 function! s:IndentGuidesToggle()
                              call indent_guides#toggle()
                            endfunction
                            
    1              0.000001 function! s:IndentGuidesEnable()
                              call indent_guides#enable()
                            endfunction
                            
    1              0.000001 function! s:IndentGuidesDisable()
                              call indent_guides#disable()
                            endfunction
                            
                            " Commands
    1              0.000004 command! -bar IndentGuidesToggle  call s:IndentGuidesToggle()
    1              0.000005 command! -bar IndentGuidesEnable  call s:IndentGuidesEnable()
    1              0.000004 command! -bar IndentGuidesDisable call s:IndentGuidesDisable()
                            
                            "
                            " Initializes a given variable to a given value. The variable is only
                            " initialized if it does not exist prior.
                            "
    1              0.000002 function s:InitVariable(var, value)
                              if !exists(a:var)
                                if type(a:value) == type("")
                                  exec 'let ' . a:var . ' = ' . "'" . a:value . "'"
                                else
                                  exec 'let ' . a:var . ' = ' .  a:value
                                endif
                              endif
                            endfunction
                            
                            " Fixed global variables
    1              0.000002 let g:indent_guides_autocmds_enabled         = 0
    1              0.000002 let g:indent_guides_color_hex_pattern        = '#[0-9A-Fa-f]\{6\}'
    1              0.000004 let g:indent_guides_color_hex_guibg_pattern  = 'guibg=\zs' . g:indent_guides_color_hex_pattern . '\ze'
    1              0.000003 let g:indent_guides_color_name_guibg_pattern = "guibg='\\?\\zs[0-9A-Za-z ]\\+\\ze'\\?"
                            
                            " Configurable global variables
    1   0.000017   0.000004 call s:InitVariable('g:indent_guides_indent_levels', 30)
    1   0.000014   0.000003 call s:InitVariable('g:indent_guides_auto_colors', 1)
    1   0.000014   0.000003 call s:InitVariable('g:indent_guides_color_change_percent', 10) " ie. 10%
    1   0.000013   0.000003 call s:InitVariable('g:indent_guides_guide_size', 0)
    1   0.000014   0.000004 call s:InitVariable('g:indent_guides_start_level', 1)
    1   0.000013   0.000003 call s:InitVariable('g:indent_guides_enable_on_vim_startup', 0)
    1   0.000013   0.000003 call s:InitVariable('g:indent_guides_debug', 0)
    1   0.000013   0.000003 call s:InitVariable('g:indent_guides_space_guides', 1)
    1   0.000013   0.000003 call s:InitVariable('g:indent_guides_tab_guides', 1)
    1   0.000014   0.000003 call s:InitVariable('g:indent_guides_soft_pattern', '\s')
    1   0.000013   0.000003 call s:InitVariable('g:indent_guides_default_mapping', 1)
                            
    1              0.000002 if !exists('g:indent_guides_exclude_filetypes')
    1              0.000002   let g:indent_guides_exclude_filetypes = ['help']
    1              0.000001 endif
                            
                            " Default mapping
    1              0.000011 if !hasmapto('<Plug>IndentGuidesToggle', 'n') && maparg('<Leader>ig', 'n') == ''
                                \ && g:indent_guides_default_mapping != 0
    1              0.000006   nmap <silent><unique> <Leader>ig <Plug>IndentGuidesToggle
    1              0.000001 endif
                            
                            " Plug mappings
    1              0.000006 nnoremap <unique><script> <Plug>IndentGuidesToggle  :IndentGuidesToggle<CR>
    1              0.000005 nnoremap <unique><script> <Plug>IndentGuidesEnable  :IndentGuidesEnable<CR>
    1              0.000005 nnoremap <unique><script> <Plug>IndentGuidesDisable :IndentGuidesDisable<CR>
                            
                            " Auto commands
    1              0.000001 augroup indent_guides
    1              0.000014   autocmd!
                            
    1              0.000002   if g:indent_guides_enable_on_vim_startup
                                autocmd VimEnter * :IndentGuidesEnable
                              endif
                            
    1              0.000007   autocmd BufEnter,WinEnter,FileType * call indent_guides#process_autocmds()
                            
                              " Trigger BufEnter and process modelines.
    1              0.000003   autocmd ColorScheme * doautocmd indent_guides BufEnter
    1              0.000002 augroup END

SCRIPT  /home/greg/.config/nvim/plugged/vim-indent-guides/autoload/indent_guides.vim
Sourced 1 time
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
                            " Author:   Nate Kane <nathanaelkane AT gmail DOT com>
                            " Homepage: http://github.com/nathanaelkane/vim-indent-guides
                            
                            "
                            " Toggles the indent guides on and off.
                            "
    1              0.000003 function! indent_guides#toggle()
                              call indent_guides#init_matches()
                            
                              if empty(w:indent_guides_matches)
                                call indent_guides#enable()
                              else
                                call indent_guides#disable()
                              endif
                            endfunction
                            
                            "
                            " Called from autocmds, keeps indent guides enabled or disabled when entering
                            " other buffers and windows.
                            "
    1              0.000002 function! indent_guides#process_autocmds()
                              if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
                              else
                                call indent_guides#disable()
                              end
                            endfunction
                            
                            "
                            " Enables the indent guides for the current buffer and any other buffer upon
                            " entering it.
                            "
    1              0.000001 function! indent_guides#enable()
                              let g:indent_guides_autocmds_enabled = 1
                            
                              if &diff || indent_guides#exclude_filetype()
                                call indent_guides#clear_matches()
                                return
                              end
                            
                              call indent_guides#init_script_vars()
                              call indent_guides#highlight_colors()
                              call indent_guides#clear_matches()
                            
                              " loop through each indent level and define a highlight pattern
                              " will automagically figure out whether to use tabs or spaces
                              for l:level in range(s:start_level, s:indent_levels)
                                let l:group = 'IndentGuides' . ((l:level % 2 == 0) ? 'Even' : 'Odd')
                                let l:column_start = (l:level - 1) * s:indent_size + 1
                            
                                " define the higlight patterns and add to matches list
                                if g:indent_guides_space_guides
                                  let l:soft_pattern = indent_guides#indent_highlight_pattern(g:indent_guides_soft_pattern, l:column_start, s:guide_size)
                                  call add(w:indent_guides_matches, matchadd(l:group, l:soft_pattern))
                                end
                                if g:indent_guides_tab_guides
                                  let l:hard_pattern = indent_guides#indent_highlight_pattern('\t', l:column_start, s:indent_size)
                                  call add(w:indent_guides_matches, matchadd(l:group, l:hard_pattern))
                                end
                              endfor
                            endfunction
                            
                            "
                            " Disables the indent guides for the current buffer and any other buffer upon
                            " entering it.
                            "
    1              0.000001 function! indent_guides#disable()
                              let g:indent_guides_autocmds_enabled = 0
                              call indent_guides#clear_matches()
                            endfunction
                            
                            "
                            " Clear all highlight matches for the current window.
                            "
    1              0.000001 function! indent_guides#clear_matches()
                              call indent_guides#init_matches()
                              if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
                              endif
                            endfunction
                            
                            "
                            " Automagically calculates and defines the indent highlight colors.
                            "
    1              0.000002 function! indent_guides#highlight_colors()
                              if s:auto_colors
                                if has('gui_running') || has('nvim')
                                  call indent_guides#gui_highlight_colors()
                                else
                                  call indent_guides#basic_highlight_colors()
                                endif
                              endif
                            endfunction
                            
                            "
                            " Defines some basic indent highlight colors that work for Terminal Vim and
                            " gVim when colors can't be automatically calculated.
                            "
    1              0.000002 function! indent_guides#basic_highlight_colors()
                              let l:cterm_colors = (&g:background == 'dark') ? ['darkgrey', 'black'] : ['lightgrey', 'white']
                              let l:gui_colors   = (&g:background == 'dark') ? ['grey15', 'grey30']  : ['grey70', 'grey85']
                            
                              exe 'hi IndentGuidesEven guibg=' . l:gui_colors[0] . ' guifg=' . l:gui_colors[1] . ' ctermbg=' . l:cterm_colors[0] . ' ctermfg=' . l:cterm_colors[1]
                              exe 'hi IndentGuidesOdd  guibg=' . l:gui_colors[1] . ' guifg=' . l:gui_colors[0] . ' ctermbg=' . l:cterm_colors[1] . ' ctermfg=' . l:cterm_colors[0]
                            endfunction
                            
                            "
                            " Automagically calculates and defines the indent highlight colors for gui
                            " vim.
                            "
    1              0.000002 function! indent_guides#gui_highlight_colors()
                              let l:hi_normal_guibg = ''
                            
                              " capture the backgroud color from the normal highlight
                              if s:hi_normal =~ s:color_hex_bg_pat
                                " hex color code is being used, eg. '#FFFFFF'
                                let l:hi_normal_guibg = matchstr(s:hi_normal, s:color_hex_bg_pat)
                            
                              elseif s:hi_normal =~ s:color_name_bg_pat
                                " color name is being used, eg. 'white'
                                let l:color_name = matchstr(s:hi_normal, s:color_name_bg_pat)
                                let l:hi_normal_guibg = color_helper#color_name_to_hex(l:color_name)
                            
                              else
                                " background color could not be detected, default to basic colors
                                call indent_guides#basic_highlight_colors()
                              endif
                            
                              if l:hi_normal_guibg =~ s:color_hex_pat
                                " calculate the highlight background colors
                                let l:hi_odd_bg  = indent_guides#lighten_or_darken_color(l:hi_normal_guibg)
                                let l:hi_even_bg = indent_guides#lighten_or_darken_color(l:hi_odd_bg)
                            
                                " define the new highlights
                                exe 'hi IndentGuidesOdd  guibg=' . l:hi_odd_bg . ' guifg=' . l:hi_even_bg
                                exe 'hi IndentGuidesEven guibg=' . l:hi_even_bg . ' guifg=' . l:hi_odd_bg
                              end
                            endfunction
                            
                            "
                            " Takes a color and darkens or lightens it depending on whether a dark or light
                            " colorscheme is being used.
                            "
    1              0.000002 function! indent_guides#lighten_or_darken_color(color)
                              let l:new_color = ''
                            
                              if (&g:background == 'dark')
                                let l:new_color = color_helper#hex_color_lighten(a:color, s:change_percent)
                              else
                                let l:new_color = color_helper#hex_color_darken (a:color, s:change_percent)
                              endif
                            
                              return l:new_color
                            endfunction
                            
                            "
                            " Define default highlights.
                            "
    1              0.000002 function! indent_guides#define_default_highlights()
                              hi default clear IndentGuidesOdd
                              hi default clear IndentGuidesEven
                            endfunction
                            
                            "
                            " Init the w:indent_guides_matches variable.
                            "
    1              0.000002 function! indent_guides#init_matches()
                              let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []
                            endfunction
                            
                            "
                            " We need to initialize these vars every time a buffer is entered while the
                            " plugin is enabled.
                            "
    1              0.000001 function! indent_guides#init_script_vars()
                              if &l:shiftwidth > 0 && &l:expandtab
                                let s:indent_size = &l:shiftwidth
                              else
                                let s:indent_size = &l:tabstop
                              endif
                              let s:guide_size  = indent_guides#calculate_guide_size()
                              let s:hi_normal   = indent_guides#capture_highlight('Normal')
                            
                              " remove 'font=<value>' from the s:hi_normal string (only seems to happen on Vim startup in Windows)
                              let s:hi_normal = substitute(s:hi_normal, ' font=[A-Za-z0-9:]\+', "", "")
                            
                              " shortcuts to the global variables - this makes the code easier to read
                              let s:debug             = g:indent_guides_debug
                              let s:indent_levels     = g:indent_guides_indent_levels
                              let s:auto_colors       = g:indent_guides_auto_colors
                              let s:color_hex_pat     = g:indent_guides_color_hex_pattern
                              let s:color_hex_bg_pat  = g:indent_guides_color_hex_guibg_pattern
                              let s:color_name_bg_pat = g:indent_guides_color_name_guibg_pattern
                              let s:start_level       = g:indent_guides_start_level
                            
                              " str2float not available in vim versions <= 7.1
                              if has('float')
                                let s:change_percent = g:indent_guides_color_change_percent / str2float('100.0')
                              else
                                let s:change_percent = g:indent_guides_color_change_percent / 100.0
                              endif
                            
                              if s:debug
                                echo 's:indent_size = '       . s:indent_size
                                echo 's:guide_size = '        . s:guide_size
                                echo 's:hi_normal = '         . s:hi_normal
                                echo 's:indent_levels = '     . s:indent_levels
                                echo 's:auto_colors = '       . s:auto_colors
                                echo 's:change_percent = '    . string(s:change_percent)
                                echo 's:color_hex_pat = '     . s:color_hex_pat
                                echo 's:color_hex_bg_pat = '  . s:color_hex_bg_pat
                                echo 's:color_name_bg_pat = ' . s:color_name_bg_pat
                                echo 's:start_level = '       . s:start_level
                              endif
                            endfunction
                            
                            "
                            " Calculate the indent guide size. Ensures the guide size is less than or
                            " equal to the actual indent size, otherwise some weird things can occur.
                            "
                            " NOTE: Currently, this only works when soft-tabs are being used.
                            "
    1              0.000002 function! indent_guides#calculate_guide_size()
                              let l:guide_size = g:indent_guides_guide_size
                            
                              if l:guide_size == 0 || l:guide_size > s:indent_size
                                let l:guide_size = s:indent_size
                              endif
                            
                              return l:guide_size
                            endfunction
                            
                            "
                            " Captures and returns the output of highlight group definitions.
                            "
                            " Example: indent_guides#capture_highlight('normal')
                            " Returns: 'Normal xxx guifg=#323232 guibg=#ffffff'
                            "
    1              0.000002 function! indent_guides#capture_highlight(group_name)
                              redir => l:output
                              exe "silent hi " . a:group_name
                              redir END
                            
                              let l:output = substitute(l:output, "\n", "", "")
                              return l:output
                            endfunction
                            
                            "
                            " Returns a regex pattern for highlighting an indent level.
                            "
                            " Example: indent_guides#indent_highlight_pattern(' ', 1, 4)
                            " Returns: /^ *\%1v\zs *\%5v\ze/
                            "
                            " Example: indent_guides#indent_highlight_pattern('\s', 5, 2)
                            " Returns: /^\s*\%5v\zs\s*\%7v\ze/
                            "
                            " Example: indent_guides#indent_highlight_pattern('\t', 9, 2)
                            " Returns: /^\t*\%9v\zs\t*\%11v\ze/
                            "
    1              0.000002 function! indent_guides#indent_highlight_pattern(indent_pattern, column_start, indent_size)
                              let l:pattern  = '^' . a:indent_pattern . '*\%' . a:column_start . 'v\zs'
                              let l:pattern .= a:indent_pattern . '*\%' . (a:column_start + a:indent_size) . 'v'
                              let l:pattern .= '\ze'
                              return l:pattern
                            endfunction
                            
                            "
                            " Detect if any of the buffer filetypes should be excluded.
                            "
    1              0.000002 function! indent_guides#exclude_filetype()
                              for ft in split(&ft, '\.')
                                if index(g:indent_guides_exclude_filetypes, ft) > -1
                                  return 1
                                end
                              endfor
                              return 0
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/jedi-vim/plugin/jedi.vim
Sourced 1 time
Total time:   0.000349
 Self time:   0.000302

count  total (s)   self (s)
                            "jedi-vim - Omni Completion for python in vim
                            " Maintainer: David Halter <davidhalter88@gmail.com>
                            "
                            " This part of the software is just the vim interface. The really big deal is
                            " the Jedi Python library.
                            
    1              0.000004 if get(g:, 'jedi#auto_vim_configuration', 1)
                                " jedi-vim doesn't work in compatible mode (vim script syntax problems)
    1              0.000001     if &compatible
                                    " vint: -ProhibitSetNoCompatible
                                    set nocompatible
                                    " vint: +ProhibitSetNoCompatible
                                endif
                            
                                " jedi-vim really needs, otherwise jedi-vim cannot start.
    1   0.000252   0.000228     filetype plugin on
                            
                                " Change completeopt, but only if it was not set already.
                                " This gets done on VimEnter, since otherwise Vim fails to restore the
                                " screen.  Neovim is not affected, this is likely caused by using
                                " :redir/execute() before the (alternate) terminal is configured.
    1              0.000002     function! s:setup_completeopt()
                                    if exists('*execute')
                                        let completeopt = execute('silent verb set completeopt?')
                                    else
                                        redir => completeopt
                                            silent verb set completeopt?
                                        redir END
                                    endif
                                    if len(split(completeopt, '\n')) == 1
                                        set completeopt=menuone,longest,preview
                                    endif
                                endfunction
    1              0.000003     if has('nvim')
    1   0.000026   0.000004         call s:setup_completeopt()
    1              0.000001     else
                                    augroup jedi_startup
                                        au!
                                        autocmd VimEnter * call s:setup_completeopt()
                                    augroup END
                                endif
                            
    1              0.000005     if len(mapcheck('<C-c>', 'i')) == 0
    1              0.000003         inoremap <C-c> <ESC>
    1              0.000001     endif
    1              0.000002 endif
                            
                            " Pyimport command
    1              0.000005 command! -nargs=1 -complete=custom,jedi#py_import_completions Pyimport :call jedi#py_import(<q-args>)
                            
    1              0.000002 function! s:jedi_debug_info()
                                " Ensure the autoload file has been loaded (and ignore any errors, which
                                " will be displayed with the debug info).
                                let unset = {}
                                let saved_squelch_py_warning = get(g:, 'jedi#squelch_py_warning', unset)
                                let g:jedi#squelch_py_warning = 1
                                call jedi#init_python()
                                if saved_squelch_py_warning is unset
                                    unlet g:jedi#squelch_py_warning
                                else
                                    let g:jedi#squelch_py_warning = saved_squelch_py_warning
                                endif
                                call jedi#debug_info()
                            endfunction
    1              0.000004 command! -nargs=0 -bar JediDebugInfo call s:jedi_debug_info()
    1              0.000005 command! -nargs=0 -bang JediClearCache call jedi#clear_cache(<bang>0)
                            
                            " vim: set et ts=4:

SCRIPT  /home/greg/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim
Sourced 1 time
Total time:   0.000415
 Self time:   0.000415

count  total (s)   self (s)
                            " Insert or delete brackets, parens, quotes in pairs.
                            " Maintainer:	JiangMiao <jiangfriend@gmail.com>
                            " Contributor: camthompson
                            " Last Change:  2017-06-17
                            " Version: 1.3.3
                            " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
                            " Repository: https://github.com/jiangmiao/auto-pairs
                            " License: MIT
                            
    1              0.000008 if exists('g:AutoPairsLoaded') || &cp
                              finish
                            end
    1              0.000002 let g:AutoPairsLoaded = 1
                            
    1              0.000002 if !exists('g:AutoPairs')
    1              0.000005   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsParens')
    1              0.000005   let g:AutoPairsParens = {'(':')', '[':']', '{':'}'}
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapBS')
    1              0.000001   let g:AutoPairsMapBS = 1
    1              0.000001 end
                            
                            " Map <C-h> as the same BS
    1              0.000002 if !exists('g:AutoPairsMapCh')
    1              0.000001   let g:AutoPairsMapCh = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapCR')
    1              0.000001   let g:AutoPairsMapCR = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsMapSpace')
    1              0.000001   let g:AutoPairsMapSpace = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsCenterLine')
    1              0.000001   let g:AutoPairsCenterLine = 1
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutToggle')
    1              0.000002   let g:AutoPairsShortcutToggle = '<M-p>'
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutFastWrap')
    1              0.000002   let g:AutoPairsShortcutFastWrap = '<M-e>'
    1              0.000001 end
                            
    1              0.000003 if !exists('g:AutoPairsMoveCharacter')
    1              0.000002   let g:AutoPairsMoveCharacter = "()[]{}\"'"
    1              0.000001 end
                            
    1              0.000002 if !exists('g:AutoPairsShortcutJump')
    1              0.000001   let g:AutoPairsShortcutJump = '<M-n>'
    1              0.000001 endif
                            
                            " Fly mode will for closed pair to jump to closed pair instead of insert.
                            " also support AutoPairsBackInsert to insert pairs where jumped.
    1              0.000002 if !exists('g:AutoPairsFlyMode')
    1              0.000001   let g:AutoPairsFlyMode = 0
    1              0.000001 endif
                            
                            " When skipping the closed pair, look at the current and
                            " next line as well.
    1              0.000002 if !exists('g:AutoPairsMultilineClose')
    1              0.000002   let g:AutoPairsMultilineClose = 1
    1              0.000001 endif
                            
                            " Work with Fly Mode, insert pair where jumped
    1              0.000002 if !exists('g:AutoPairsShortcutBackInsert')
    1              0.000002   let g:AutoPairsShortcutBackInsert = '<M-b>'
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:AutoPairsSmartQuotes')
    1              0.000001   let g:AutoPairsSmartQuotes = 1
    1              0.000001 endif
                            
                            " 7.4.849 support <C-G>U to avoid breaking '.'
                            " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
                            " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
    1              0.000003 if v:version > 704 || v:version == 704 && has("patch849")
    1              0.000002   let s:Go = "\<C-G>U"
    1              0.000001 else
                              let s:Go = ""
                            endif
                            
    1              0.000002 let s:Left = s:Go."\<LEFT>"
    1              0.000002 let s:Right = s:Go."\<RIGHT>"
                            
                            
                            " Will auto generated {']' => '[', ..., '}' => '{'}in initialize.
    1              0.000002 let g:AutoPairsClosedPairs = {}
                            
                            
    1              0.000002 function! AutoPairsInsert(key)
                              if !b:autopairs_enabled
                                return a:key
                              end
                            
                              let line = getline('.')
                              let pos = col('.') - 1
                              let before = strpart(line, 0, pos)
                              let after = strpart(line, pos)
                              let next_chars = split(after, '\zs')
                              let current_char = get(next_chars, 0, '')
                              let next_char = get(next_chars, 1, '')
                              let prev_chars = split(before, '\zs')
                              let prev_char = get(prev_chars, -1, '')
                            
                              let eol = 0
                              if col('$') -  col('.') <= 1
                                let eol = 1
                              end
                            
                              " Ignore auto close if prev character is \
                              if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
                              if !has_key(b:AutoPairs, a:key)
                                let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
                                if current_char == a:key
                                  return s:Right
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
                              let open = a:key
                              let close = b:AutoPairs[open]
                            
                              if current_char == close && open == close
                                return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
                              if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
                              if open == close
                                " The key must be ' " `
                                let pprev_char = line[col('.')-3]
                                if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
                              end
                            
                              let quotes_num = 0
                              " Ignore comment line for vim file
                              if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
                              if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
                                let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
                                let n = quotes_num
                                let pos = 0
                                while 1
                                  let pos = stridx(cleaned_line, open, pos)
                                  if pos == -1
                                    break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
                                if n % 2 == 1
                                  return a:key
                                endif
                              endif
                            
                              return open.close.s:Left
                            endfunction
                            
    1              0.000001 function! AutoPairsDelete()
                              if !b:autopairs_enabled
                                return "\<BS>"
                              end
                            
                              let line = getline('.')
                              let pos = col('.') - 1
                              let current_char = get(split(strpart(line, pos), '\zs'), 0, '')
                              let prev_chars = split(strpart(line, 0, pos), '\zs')
                              let prev_char = get(prev_chars, -1, '')
                              let pprev_char = get(prev_chars, -2, '')
                            
                              if pprev_char == '\'
                                return "\<BS>"
                              end
                            
                              " Delete last two spaces in parens, work with MapSpace
                              if has_key(b:AutoPairs, pprev_char) && prev_char == ' ' && current_char == ' '
                                return "\<BS>\<DEL>"
                              endif
                            
                              " Delete Repeated Pair eg: '''|''' [[|]] {{|}}
                              if has_key(b:AutoPairs, prev_char)
                                let times = 0
                                let p = -1
                                while get(prev_chars, p, '') == prev_char
                                  let p = p - 1
                                  let times = times + 1
                                endwhile
                            
                                let close = b:AutoPairs[prev_char]
                                let left = repeat(prev_char, times)
                                let right = repeat(close, times)
                            
                                let before = strpart(line, pos-times, times)
                                let after  = strpart(line, pos, times)
                                if left == before && right == after
                                  return repeat("\<BS>\<DEL>", times)
                                end
                              end
                            
                            
                              if has_key(b:AutoPairs, prev_char)
                                let close = b:AutoPairs[prev_char]
                                if match(line,'^\s*'.close, col('.')-1) != -1
                                  " Delete (|___)
                                  let space = matchstr(line, '^\s*', col('.')-1)
                                  return "\<BS>". repeat("\<DEL>", len(space)+1)
                                elseif match(line, '^\s*$', col('.')-1) != -1
                                  " Delete (|__\n___)
                                  let nline = getline(line('.')+1)
                                  if nline =~ '^\s*'.close
                                    if &filetype == 'vim' && prev_char == '"'
                                      " Keep next line's comment
                                      return "\<BS>"
                                    end
                            
                                    let space = matchstr(nline, '^\s*')
                                    return "\<BS>\<DEL>". repeat("\<DEL>", len(space)+1)
                                  end
                                end
                              end
                            
                              return "\<BS>"
                            endfunction
                            
    1              0.000001 function! AutoPairsJump()
                              call search('["\]'')}]','W')
                            endfunction
                            " string_chunk cannot use standalone
    1              0.000002 let s:string_chunk = '\v%(\\\_.|[^\1]|[\r\n]){-}'
    1              0.000003 let s:ss_pattern = '\v''' . s:string_chunk . ''''
    1              0.000002 let s:ds_pattern = '\v"'  . s:string_chunk . '"'
                            
    1              0.000002 func! s:RegexpQuote(str)
                              return substitute(a:str, '\v[\[\{\(\<\>\)\}\]]', '\\&', 'g')
                            endf
                            
    1              0.000001 func! s:RegexpQuoteInSquare(str)
                              return substitute(a:str, '\v[\[\]]', '\\&', 'g')
                            endf
                            
                            " Search next open or close pair
    1              0.000002 func! s:FormatChunk(open, close)
                              let open = s:RegexpQuote(a:open)
                              let close = s:RegexpQuote(a:close)
                              let open2 = s:RegexpQuoteInSquare(a:open)
                              let close2 = s:RegexpQuoteInSquare(a:close)
                              if open == close
                                return '\v'.open.s:string_chunk.close
                              else
                                return '\v%(' . s:ss_pattern . '|' . s:ds_pattern . '|' . '[^'.open2.close2.']|[\r\n]' . '){-}(['.open2.close2.'])'
                              end
                            endf
                            
                            " Fast wrap the word in brackets
    1              0.000001 function! AutoPairsFastWrap()
                              let line = getline('.')
                              let current_char = line[col('.')-1]
                              let next_char = line[col('.')]
                              let open_pair_pattern = '\v[({\[''"]'
                              let at_end = col('.') >= col('$') - 1
                              normal! x
                              " Skip blank
                              if next_char =~ '\v\s' || at_end
                                call search('\v\S', 'W')
                                let line = getline('.')
                                let next_char = line[col('.')-1]
                              end
                            
                              if has_key(b:AutoPairs, next_char)
                                let followed_open_pair = next_char
                                let inputed_close_pair = current_char
                                let followed_close_pair = b:AutoPairs[next_char]
                                if followed_close_pair != followed_open_pair
                                  " TODO replace system searchpair to skip string and nested pair.
                                  " eg: (|){"hello}world"} will transform to ({"hello})world"}
                                  call searchpair('\V'.followed_open_pair, '', '\V'.followed_close_pair, 'W')
                                else
                                  call search(s:FormatChunk(followed_open_pair, followed_close_pair), 'We')
                                end
                                return s:Right.inputed_close_pair.s:Left
                              else
                                normal! he
                                return s:Right.current_char.s:Left
                              end
                            endfunction
                            
    1              0.000001 function! AutoPairsMap(key)
                              " | is special key which separate map command from text
                              let key = a:key
                              if key == '|'
                                let key = '<BAR>'
                              end
                              let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
                              execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            
                            endfunction
                            
    1              0.000001 function! AutoPairsToggle()
                              if b:autopairs_enabled
                                let b:autopairs_enabled = 0
                                echo 'AutoPairs Disabled.'
                              else
                                let b:autopairs_enabled = 1
                                echo 'AutoPairs Enabled.'
                              end
                              return ''
                            endfunction
                            
    1              0.000001 function! AutoPairsMoveCharacter(key)
                              let c = getline(".")[col(".")-1]
                              let escaped_key = substitute(a:key, "'", "''", 'g')
                              return "\<DEL>\<ESC>:call search("."'".escaped_key."'".")\<CR>a".c."\<LEFT>"
                            endfunction
                            
    1              0.000001 function! AutoPairsReturn()
                              if b:autopairs_enabled == 0
                                return ''
                              end
                              let line = getline('.')
                              let pline = getline(line('.')-1)
                              let prev_char = pline[strlen(pline)-1]
                              let cmd = ''
                              let cur_char = line[col('.')-1]
                              if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
                                if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Recenter before adding new line to avoid replacing line content
                                  let cmd = "zz"
                                end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
                                if &equalprg != ''
                                  return "\<ESC>".cmd."O"
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
                                if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>".cmd."k==o"
                                else
                                  return "\<ESC>".cmd."=ko"
                                endif
                              end
                              return ''
                            endfunction
                            
    1              0.000001 function! AutoPairsSpace()
                              let line = getline('.')
                              let prev_char = line[col('.')-2]
                              let cmd = ''
                              let cur_char =line[col('.')-1]
                              if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>".s:Left
                              endif
                              return "\<SPACE>".cmd
                            endfunction
                            
    1              0.000001 function! AutoPairsBackInsert()
                              if exists('b:autopairs_saved_pair')
                                let pair = b:autopairs_saved_pair[0]
                                let pos  = b:autopairs_saved_pair[1]
                                call setpos('.', pos)
                                return pair
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! AutoPairsInit()
                              let b:autopairs_loaded  = 1
                              if !exists('b:autopairs_enabled')
                                let b:autopairs_enabled = 1
                              end
                              let b:AutoPairsClosedPairs = {}
                            
                              if !exists('b:AutoPairs')
                                let b:AutoPairs = g:AutoPairs
                              end
                            
                              if !exists('b:AutoPairsMoveCharacter')
                                let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
                              end
                            
                              " buffer level map pairs keys
                              for [open, close] in items(b:AutoPairs)
                                call AutoPairsMap(open)
                                if open != close
                                  call AutoPairsMap(close)
                                end
                                let b:AutoPairsClosedPairs[close] = open
                              endfor
                            
                              for key in split(b:AutoPairsMoveCharacter, '\s*')
                                let escaped_key = substitute(key, "'", "''", 'g')
                                execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
                              endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
                              if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
                                execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
                              end
                            
                              if g:AutoPairsMapCh
                                execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
                              endif
                            
                              if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
                                let do_abbrev = ""
                                if v:version == 703 && has("patch489") || v:version > 703
                                  let do_abbrev = "<C-]>"
                                endif
                                execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
                              end
                            
                              if g:AutoPairsShortcutFastWrap != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
                              end
                            
                              if g:AutoPairsShortcutBackInsert != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
                              end
                            
                              if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
                                execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
                                execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
                              end
                            
                              if g:AutoPairsShortcutJump != ''
                                execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
                                execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
                              end
                            
                            endfunction
                            
    1              0.000002 function! s:ExpandMap(map)
                              let map = a:map
                              let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
                              return map
                            endfunction
                            
    1              0.000001 function! AutoPairsTryInit()
                              if exists('b:autopairs_loaded')
                                return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()
                            endfunction
                            
                            " Always silent the command
    1              0.000007 inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
    1              0.000005 imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
                            
                            
    1              0.000005 au BufEnter * :call AutoPairsTryInit()

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/plugin/deoplete.vim
Sourced 1 time
Total time:   0.000217
 Self time:   0.000104

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: deoplete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 if exists('g:loaded_deoplete')
                              finish
                            endif
    1              0.000002 let g:loaded_deoplete = 1
                            
                            " Global options definition.
    1              0.000003 if get(g:, 'deoplete#enable_at_startup', 0)
    1   0.000200   0.000086   call deoplete#enable()
    1              0.000002 endif

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/autoload/deoplete.vim
Sourced 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: deoplete.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#initialize() abort
                              return deoplete#init#_initialize()
                            endfunction
    1              0.000002 function! deoplete#is_enabled() abort
                              return deoplete#init#_is_handler_enabled()
                            endfunction
    1              0.000001 function! deoplete#enable() abort
                              if has('vim_starting')
                                augroup deoplete
                                  autocmd!
                                  autocmd VimEnter * call deoplete#enable()
                                augroup END
                                return 1
                              endif
                            
                              if deoplete#initialize() && deoplete#is_enabled()
                                return 1
                              endif
                              return deoplete#init#_enable_handler()
                            endfunction
    1              0.000002 function! deoplete#disable() abort
                              call deoplete#initialize()
                              return deoplete#init#_disable_handler()
                            endfunction
    1              0.000001 function! deoplete#toggle() abort
                              call deoplete#initialize()
                              return deoplete#is_enabled() ?
                                    \ deoplete#init#_disable_handler() :
                                    \ deoplete#init#_enable_handler()
                            endfunction
                            
    1              0.000002 function! deoplete#enable_logging(level, logfile) abort
                              let g:deoplete#_logging = {'level': a:level, 'logfile': a:logfile}
                              call deoplete#util#rpcnotify('deoplete_enable_logging', {})
                            endfunction
                            
    1              0.000002 function! deoplete#send_event(event, ...) abort
                              let sources = deoplete#util#convert2list(get(a:000, 0, []))
                              call deoplete#util#rpcnotify('deoplete_on_event',
                                    \ {'event': a:event, 'sources': sources})
                            endfunction
                            
    1              0.000002 function! deoplete#manual_complete(...) abort
                              if !deoplete#is_enabled()
                                return ''
                              endif
                            
                              " Start complete.
                              return "\<C-r>=deoplete#mapping#_rpcrequest_wrapper("
                                    \ . string(get(a:000, 0, [])) . ")\<CR>"
                            endfunction
    1              0.000001 function! deoplete#close_popup() abort
                              call deoplete#handler#_skip_next_completion()
                              return pumvisible() ? "\<C-y>" : ''
                            endfunction
    1              0.000002 function! deoplete#smart_close_popup() abort
                              call deoplete#handler#_skip_next_completion()
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
    1              0.000001 function! deoplete#cancel_popup() abort
                              call deoplete#handler#_skip_next_completion()
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
    1              0.000001 function! deoplete#refresh() abort
                              if exists('g:deoplete#_context')
                                if get(g:deoplete#_context, 'event', '') ==# 'Manual'
                                  let g:deoplete#_context.event = 'Refresh'
                                endif
                              endif
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
    1              0.000002 function! deoplete#insert_candidate(number) abort
                              return deoplete#mapping#_insert_candidate(a:number)
                            endfunction
    1              0.000001 function! deoplete#undo_completion() abort
                              return deoplete#mapping#_undo_completion()
                            endfunction
    1              0.000002 function! deoplete#complete_common_string() abort
                              return deoplete#mapping#_complete_common_string()
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim
Sourced 1 time
Total time:   0.001510
 Self time:   0.000624

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            
    1              0.000010 if exists('g:loaded_gitgutter') || !has('signs') || &cp
                              finish
                            endif
    1              0.000002 let g:loaded_gitgutter = 1
                            
                            " Initialisation {{{
                            
    1              0.000003 if v:version < 703 || (v:version == 703 && !has("patch105"))
                              call gitgutter#utility#warn('requires Vim 7.3.105')
                              finish
                            endif
                            
    1              0.000002 function! s:set(var, default) abort
                              if !exists(a:var)
                                if type(a:default)
                                  execute 'let' a:var '=' string(a:default)
                                else
                                  execute 'let' a:var '=' a:default
                                endif
                              endif
                            endfunction
                            
    1   0.000016   0.000004 call s:set('g:gitgutter_enabled',                     1)
    1   0.000013   0.000003 call s:set('g:gitgutter_max_signs',                 500)
    1   0.000012   0.000003 call s:set('g:gitgutter_signs',                       1)
    1   0.000012   0.000003 call s:set('g:gitgutter_highlight_lines',             0)
    1   0.000012   0.000003 call s:set('g:gitgutter_sign_column_always',          0)
    1              0.000002 if g:gitgutter_sign_column_always && exists('&signcolumn')
                              " Vim 7.4.2201.
                              set signcolumn=yes
                              let g:gitgutter_sign_column_always = 0
                              call gitgutter#utility#warn('please replace "let g:gitgutter_sign_column_always=1" with "set signcolumn=yes"')
                            endif
    1   0.000013   0.000003 call s:set('g:gitgutter_override_sign_column_highlight', 1)
    1   0.000014   0.000003 call s:set('g:gitgutter_sign_added',                   '+')
    1   0.000012   0.000003 call s:set('g:gitgutter_sign_modified',                '~')
    1   0.000012   0.000003 call s:set('g:gitgutter_sign_removed',                 '_')
                            
    1   0.000295   0.000103 if gitgutter#utility#supports_overscore_sign()
    1   0.000016   0.000004   call s:set('g:gitgutter_sign_removed_first_line', '‾')
    1              0.000001 else
                              call s:set('g:gitgutter_sign_removed_first_line', '_^')
                            endif
                            
    1   0.000014   0.000003 call s:set('g:gitgutter_sign_removed_above_and_below', '[')
    1   0.000013   0.000003 call s:set('g:gitgutter_sign_modified_removed',       '~_')
    1   0.000013   0.000003 call s:set('g:gitgutter_git_args',                      '')
    1   0.000012   0.000003 call s:set('g:gitgutter_diff_args',                     '')
    1   0.000012   0.000003 call s:set('g:gitgutter_diff_base',                     '')
    1   0.000012   0.000003 call s:set('g:gitgutter_map_keys',                       1)
    1   0.000013   0.000003 call s:set('g:gitgutter_terminal_reports_focus',         1)
    1   0.000012   0.000003 call s:set('g:gitgutter_async',                          1)
    1   0.000012   0.000003 call s:set('g:gitgutter_log',                            0)
                            
    1   0.000013   0.000003 call s:set('g:gitgutter_git_executable', 'git')
    1              0.000010 if !executable(g:gitgutter_git_executable)
                              call gitgutter#utility#warn('cannot find git. Please set g:gitgutter_git_executable.')
                            endif
                            
    1              0.000002 let default_grep = 'grep'
    1   0.000013   0.000003 call s:set('g:gitgutter_grep', default_grep)
    1              0.000002 if !empty(g:gitgutter_grep)
    1              0.000019   if executable(split(g:gitgutter_grep)[0])
    1              0.000004     if $GREP_OPTIONS =~# '--color=always'
                                  let g:gitgutter_grep .= ' --color=never'
                                endif
    1              0.000001   else
                                if g:gitgutter_grep !=# default_grep
                                  call gitgutter#utility#warn('cannot find '.g:gitgutter_grep.'. Please check g:gitgutter_grep.')
                                endif
                                let g:gitgutter_grep = ''
                              endif
    1              0.000001 endif
                            
    1   0.000238   0.000106 call gitgutter#highlight#define_sign_column_highlight()
    1   0.000273   0.000005 call gitgutter#highlight#define_highlights()
    1   0.000083   0.000007 call gitgutter#highlight#define_signs()
                            
                            " Prevent infinite loop where:
                            " - executing a job in the foreground launches a new window which takes the focus;
                            " - when the job finishes, focus returns to gvim;
                            " - the FocusGained event triggers a new job (see below).
    1   0.000012   0.000004 if gitgutter#utility#windows() && !(g:gitgutter_async && gitgutter#async#available())
                              set noshelltemp
                            endif
                            
                            " }}}
                            
                            " Primary functions {{{
                            
    1              0.000004 command! -bar GitGutterAll call gitgutter#all(1)
    1              0.000005 command! -bar GitGutter    call gitgutter#process_buffer(bufnr(''), 1)
                            
    1              0.000003 command! -bar GitGutterDisable call gitgutter#disable()
    1              0.000003 command! -bar GitGutterEnable  call gitgutter#enable()
    1              0.000003 command! -bar GitGutterToggle  call gitgutter#toggle()
                            
                            " }}}
                            
                            " Line highlights {{{
                            
    1              0.000005 command! -bar GitGutterLineHighlightsDisable call gitgutter#highlight#line_disable()
    1              0.000004 command! -bar GitGutterLineHighlightsEnable  call gitgutter#highlight#line_enable()
    1              0.000004 command! -bar GitGutterLineHighlightsToggle  call gitgutter#highlight#line_toggle()
                            
                            " }}}
                            
                            " Signs {{{
                            
    1              0.000004 command! -bar GitGutterSignsEnable  call gitgutter#sign#enable()
    1              0.000004 command! -bar GitGutterSignsDisable call gitgutter#sign#disable()
    1              0.000003 command! -bar GitGutterSignsToggle  call gitgutter#sign#toggle()
                            
                            " }}}
                            
                            " Hunks {{{
                            
    1              0.000006 command! -bar -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
    1              0.000005 command! -bar -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
                            
    1              0.000004 command! -bar GitGutterStageHunk   call gitgutter#hunk#stage()
    1              0.000003 command! -bar GitGutterUndoHunk    call gitgutter#hunk#undo()
    1              0.000004 command! -bar GitGutterPreviewHunk call gitgutter#hunk#preview()
                            
                            " Hunk text object
    1              0.000008 onoremap <silent> <Plug>GitGutterTextObjectInnerPending :<C-U>call gitgutter#hunk#text_object(1)<CR>
    1              0.000007 onoremap <silent> <Plug>GitGutterTextObjectOuterPending :<C-U>call gitgutter#hunk#text_object(0)<CR>
    1              0.000006 xnoremap <silent> <Plug>GitGutterTextObjectInnerVisual  :<C-U>call gitgutter#hunk#text_object(1)<CR>
    1              0.000006 xnoremap <silent> <Plug>GitGutterTextObjectOuterVisual  :<C-U>call gitgutter#hunk#text_object(0)<CR>
                            
                            
                            " Returns the git-diff hunks for the file or an empty list if there
                            " aren't any hunks.
                            "
                            " The return value is a list of lists.  There is one inner list per hunk.
                            "
                            "   [
                            "     [from_line, from_count, to_line, to_count],
                            "     [from_line, from_count, to_line, to_count],
                            "     ...
                            "   ]
                            "
                            " where:
                            "
                            " `from`  - refers to the staged file
                            " `to`    - refers to the working tree's file
                            " `line`  - refers to the line number where the change starts
                            " `count` - refers to the number of lines the change covers
    1              0.000002 function! GitGutterGetHunks()
                              let bufnr = bufnr('')
                              return gitgutter#utility#is_active(bufnr) ? gitgutter#hunk#hunks(bufnr) : []
                            endfunction
                            
                            " Returns an array that contains a summary of the hunk status for the current
                            " window.  The format is [ added, modified, removed ], where each value
                            " represents the number of lines added/modified/removed respectively.
    1              0.000001 function! GitGutterGetHunkSummary()
                              return gitgutter#hunk#summary(winbufnr(0))
                            endfunction
                            
                            " }}}
                            
    1              0.000004 command! -bar GitGutterDebug call gitgutter#debug#debug()
                            
                            " Maps {{{
                            
    1              0.000008 nnoremap <silent> <expr> <Plug>GitGutterNextHunk &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
    1              0.000008 nnoremap <silent> <expr> <Plug>GitGutterPrevHunk &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
                            
    1              0.000005 nnoremap <silent> <Plug>GitGutterStageHunk   :GitGutterStageHunk<CR>
    1              0.000005 nnoremap <silent> <Plug>GitGutterUndoHunk    :GitGutterUndoHunk<CR>
    1              0.000005 nnoremap <silent> <Plug>GitGutterPreviewHunk :GitGutterPreviewHunk<CR>
                            
                            " }}}
                            
    1              0.000002 function! s:on_bufenter()
                              if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
                                call gitgutter#init_buffer(bufnr(''))
                                call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
                              endif
                            endfunction
                            
                            " Autocommands {{{
                            
    1              0.000001 augroup gitgutter
    1              0.000014   autocmd!
                            
    1              0.000004   autocmd TabEnter * let t:gitgutter_didtabenter = 1
                            
    1              0.000002   autocmd BufEnter * call s:on_bufenter()
                            
    1              0.000006   autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(bufnr(''), 0)
    1              0.000003   autocmd FileChangedShellPost   * call gitgutter#process_buffer(bufnr(''), 1)
                            
                              " Ensure that all buffers are processed when opening vim with multiple files, e.g.:
                              "
                              "   vim -o file1 file2
    1              0.000004   autocmd VimEnter * if winnr() != winnr('$') | call gitgutter#all(0) | endif
                            
    1              0.000004   autocmd FocusGained,ShellCmdPost * call gitgutter#all(1)
                            
    1              0.000003   if exists('##VimResume')
    1              0.000003     autocmd VimResume * call gitgutter#all(1)
    1              0.000001   endif
                            
    1              0.000004   autocmd ColorScheme * call gitgutter#highlight#define_sign_column_highlight() | call gitgutter#highlight#define_highlights()
                            
                              " Disable during :vimgrep
    1              0.000003   autocmd QuickFixCmdPre  *vimgrep* let g:gitgutter_enabled = 0
    1              0.000004   autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = 1
    1              0.000001 augroup END
                            
                            " }}}
                            
                            " vim:set et sw=2 fdm=marker:

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim
Sourced 1 time
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
    1              0.000003 function! gitgutter#utility#supports_overscore_sign()
                              if gitgutter#utility#windows()
                                return &encoding ==? 'utf-8'
                              else
                                return &termencoding ==? &encoding || &termencoding == ''
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#setbufvar(buffer, varname, val)
                              let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
                              let bvars = getbufvar(buffer, '')
                              if empty(bvars)
                                let bvars = {}
                              endif
                              let dict = get(bvars, 'gitgutter', {})
                              let needs_setting = empty(dict)
                              let dict[a:varname] = a:val
                              if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#getbufvar(buffer, varname, ...)
                              let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
                              if has_key(dict, a:varname)
                                return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#warn(message) abort
                              echohl WarningMsg
                              echo 'vim-gitgutter: ' . a:message
                              echohl None
                              let v:warningmsg = a:message
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#warn_once(bufnr, message, key) abort
                              if empty(gitgutter#utility#getbufvar(a:bufnr, a:key))
                                call gitgutter#utility#setbufvar(a:bufnr, a:key, '1')
                                echohl WarningMsg
                                redraw | echom 'vim-gitgutter: ' . a:message
                                echohl None
                                let v:warningmsg = a:message
                              endif
                            endfunction
                            
                            " Returns truthy when the buffer's file should be processed; and falsey when it shouldn't.
                            " This function does not and should not make any system calls.
    1              0.000002 function! gitgutter#utility#is_active(bufnr) abort
                              return g:gitgutter_enabled &&
                                    \ !pumvisible() &&
                                    \ s:is_file_buffer(a:bufnr) &&
                                    \ s:exists_file(a:bufnr) &&
                                    \ s:not_git_dir(a:bufnr)
                            endfunction
                            
    1              0.000002 function! s:not_git_dir(bufnr) abort
                              return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'
                            endfunction
                            
    1              0.000001 function! s:is_file_buffer(bufnr) abort
                              return empty(getbufvar(a:bufnr, '&buftype'))
                            endfunction
                            
                            " From tpope/vim-fugitive
    1              0.000003 function! s:winshell()
                              return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
                            endfunction
                            
                            " From tpope/vim-fugitive
    1              0.000002 function! gitgutter#utility#shellescape(arg) abort
                              if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000001 function! gitgutter#utility#file(bufnr)
                              return s:abs_path(a:bufnr, 1)
                            endfunction
                            
                            " Not shellescaped
    1              0.000002 function! gitgutter#utility#extension(bufnr) abort
                              return fnamemodify(s:abs_path(a:bufnr, 0), ':e')
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#system(cmd, ...) abort
                              call gitgutter#debug#log(a:cmd, a:000)
                            
                              call s:use_known_shell()
                              silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
                              call s:restore_shell()
                            
                              return output
                            endfunction
                            
                            " Path of file relative to repo root.
                            "
                            " *     empty string - not set
                            " * non-empty string - path
                            " *               -1 - pending
                            " *               -2 - not tracked by git
    1              0.000002 function! gitgutter#utility#repo_path(bufnr, shellesc) abort
                              let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
                              return a:shellesc ? gitgutter#utility#shellescape(p) : p
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#set_repo_path(bufnr) abort
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                if has('lambda')
                                  call gitgutter#async#execute(cmd, a:bufnr, {
                                        \   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},
                                        \   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)},
                                        \ })
                                else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {
                                          \   'out': function('s:set_path'),
                                          \   'err': function('s:not_tracked_by_git')
                                          \ })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {
                                          \   'out': function('s:set_path'),
                                          \   'err': function('s:set_path', [-2])
                                          \ })
                                  endif
                                endif
                              else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif
                            endfunction
                            
    1              0.000006 if has('nvim') && !has('nvim-0.2.0')
                              function! s:not_tracked_by_git(bufnr)
                                call s:set_path(a:bufnr, -2)
                              endfunction
                            endif
                            
    1              0.000002 function! s:set_path(bufnr, path)
                              if a:bufnr == -2
                                let [bufnr, path] = [a:path, a:bufnr]
                                call gitgutter#utility#setbufvar(bufnr, 'path', path)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(a:path))
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#cd_cmd(bufnr, cmd) abort
                              let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
                              return cd.' '.s:dir(a:bufnr).' && '.a:cmd
                            endfunction
                            
    1              0.000001 function! s:unc_path(bufnr)
                              return s:abs_path(a:bufnr, 0) =~ '^\\\\'
                            endfunction
                            
    1              0.000002 function! s:use_known_shell() abort
                              if has('unix') && &shell !=# 'sh'
                                let [s:shell, s:shellcmdflag, s:shellredir] = [&shell, &shellcmdflag, &shellredir]
                                let &shell = 'sh'
                                set shellcmdflag=-c shellredir=>%s\ 2>&1
                              endif
                            endfunction
                            
    1              0.000001 function! s:restore_shell() abort
                              if has('unix') && exists('s:shell')
                                let [&shell, &shellcmdflag, &shellredir] = [s:shell, s:shellcmdflag, s:shellredir]
                              endif
                            endfunction
                            
    1              0.000001 function! s:abs_path(bufnr, shellesc)
                              let p = resolve(expand('#'.a:bufnr.':p'))
                              return a:shellesc ? gitgutter#utility#shellescape(p) : p
                            endfunction
                            
    1              0.000001 function! s:dir(bufnr) abort
                              return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))
                            endfunction
                            
                            " Not shellescaped.
    1              0.000001 function! s:filename(bufnr) abort
                              return fnamemodify(s:abs_path(a:bufnr, 0), ':t')
                            endfunction
                            
    1              0.000001 function! s:exists_file(bufnr) abort
                              return filereadable(s:abs_path(a:bufnr, 0))
                            endfunction
                            
                            " Get rid of any trailing new line or SOH character.
                            "
                            " git ls-files -z produces output with null line termination.
                            " Vim's system() replaces any null characters in the output
                            " with SOH (start of header), i.e. ^A.
    1              0.000002 function! s:strip_trailing_new_line(line) abort
                              return substitute(a:line, '[[:cntrl:]]$', '', '')
                            endfunction
                            
    1              0.000002 function! gitgutter#utility#windows()
                              return has('win64') || has('win32') || has('win16')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/highlight.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    1              0.000003 function! gitgutter#highlight#line_disable() abort
                              let g:gitgutter_highlight_lines = 0
                              call s:define_sign_line_highlights()
                            
                              if !g:gitgutter_signs
                                call gitgutter#sign#clear_signs(bufnr(''))
                                call gitgutter#sign#remove_dummy_sign(bufnr(''), 0)
                              endif
                            
                              redraw!
                            endfunction
                            
    1              0.000002 function! gitgutter#highlight#line_enable() abort
                              let old_highlight_lines = g:gitgutter_highlight_lines
                            
                              let g:gitgutter_highlight_lines = 1
                              call s:define_sign_line_highlights()
                            
                              if !old_highlight_lines && !g:gitgutter_signs
                                call gitgutter#all(1)
                              endif
                            
                              redraw!
                            endfunction
                            
    1              0.000002 function! gitgutter#highlight#line_toggle() abort
                              if g:gitgutter_highlight_lines
                                call gitgutter#highlight#line_disable()
                              else
                                call gitgutter#highlight#line_enable()
                              endif
                            endfunction
                            
                            
    1              0.000004 function! gitgutter#highlight#define_sign_column_highlight() abort
                              if g:gitgutter_override_sign_column_highlight
                                highlight! link SignColumn LineNr
                              else
                                highlight default link SignColumn LineNr
                              endif
                            endfunction
                            
    1              0.000002 function! gitgutter#highlight#define_highlights() abort
                              let [guibg, ctermbg] = s:get_background_colors('SignColumn')
                            
                              " Highlights used by the signs.
                            
                              execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
                              execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
                              execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
                              highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
                            
                              execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
                              execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
                              execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
                              highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
                            
                              highlight default link GitGutterAdd          GitGutterAddDefault
                              highlight default link GitGutterChange       GitGutterChangeDefault
                              highlight default link GitGutterDelete       GitGutterDeleteDefault
                              highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
                            
                              " Highlights used for the whole line.
                            
                              highlight default link GitGutterAddLine          DiffAdd
                              highlight default link GitGutterChangeLine       DiffChange
                              highlight default link GitGutterDeleteLine       DiffDelete
                              highlight default link GitGutterChangeDeleteLine GitGutterChangeLine
                            endfunction
                            
    1              0.000002 function! gitgutter#highlight#define_signs() abort
                              sign define GitGutterLineAdded
                              sign define GitGutterLineModified
                              sign define GitGutterLineRemoved
                              sign define GitGutterLineRemovedFirstLine
                              sign define GitGutterLineRemovedAboveAndBelow
                              sign define GitGutterLineModifiedRemoved
                              sign define GitGutterDummy
                            
                              call s:define_sign_text()
                              call gitgutter#highlight#define_sign_text_highlights()
                              call s:define_sign_line_highlights()
                            endfunction
                            
    1              0.000002 function! s:define_sign_text() abort
                              execute "sign define GitGutterLineAdded                 text=" . g:gitgutter_sign_added
                              execute "sign define GitGutterLineModified              text=" . g:gitgutter_sign_modified
                              execute "sign define GitGutterLineRemoved               text=" . g:gitgutter_sign_removed
                              execute "sign define GitGutterLineRemovedFirstLine      text=" . g:gitgutter_sign_removed_first_line
                              execute "sign define GitGutterLineRemovedAboveAndBelow  text=" . g:gitgutter_sign_removed_above_and_below
                              execute "sign define GitGutterLineModifiedRemoved       text=" . g:gitgutter_sign_modified_removed
                            endfunction
                            
    1              0.000002 function! gitgutter#highlight#define_sign_text_highlights() abort
                              " Once a sign's text attribute has been defined, it cannot be undefined or
                              " set to an empty value.  So to make signs' text disappear (when toggling
                              " off or disabling) we make them invisible by setting their foreground colours
                              " to the background's.
                              if g:gitgutter_signs
                                sign define GitGutterLineAdded                 texthl=GitGutterAdd
                                sign define GitGutterLineModified              texthl=GitGutterChange
                                sign define GitGutterLineRemoved               texthl=GitGutterDelete
                                sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
                                sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
                                sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
                              else
                                sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
                                sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
                                sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
                              endif
                            endfunction
                            
    1              0.000002 function! s:define_sign_line_highlights() abort
                              if g:gitgutter_highlight_lines
                                sign define GitGutterLineAdded                 linehl=GitGutterAddLine
                                sign define GitGutterLineModified              linehl=GitGutterChangeLine
                                sign define GitGutterLineRemoved               linehl=GitGutterDeleteLine
                                sign define GitGutterLineRemovedFirstLine      linehl=GitGutterDeleteLine
                                sign define GitGutterLineRemovedAboveAndBelow  linehl=GitGutterDeleteLine
                                sign define GitGutterLineModifiedRemoved       linehl=GitGutterChangeDeleteLine
                              else
                                sign define GitGutterLineAdded                 linehl=
                                sign define GitGutterLineModified              linehl=
                                sign define GitGutterLineRemoved               linehl=
                                sign define GitGutterLineRemovedFirstLine      linehl=
                                sign define GitGutterLineRemovedAboveAndBelow  linehl=
                                sign define GitGutterLineModifiedRemoved       linehl=
                              endif
                            endfunction
                            
    1              0.000002 function! s:get_background_colors(group) abort
                              redir => highlight
                              silent execute 'silent highlight ' . a:group
                              redir END
                            
                              let link_matches = matchlist(highlight, 'links to \(\S\+\)')
                              if len(link_matches) > 0 " follow the link
                                return s:get_background_colors(link_matches[1])
                              endif
                            
                              let ctermbg = s:match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
                              let guibg   = s:match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
                              return [guibg, ctermbg]
                            endfunction
                            
    1              0.000002 function! s:match_highlight(highlight, pattern) abort
                              let matches = matchlist(a:highlight, a:pattern)
                              if len(matches) == 0
                                return 'NONE'
                              endif
                              return matches[1]
                            endfunction

SCRIPT  /usr/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000011 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
                            endif
    1              0.000002 let loaded_gzip = 1
                            
    1              0.000001 augroup gzip
                              " Remove all gzip autocommands
    1              0.000014   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000019   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
    1              0.000009   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000014   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000005   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000005   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000005   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000003   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000003   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000002   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000003   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000002   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000003   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000003   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000002   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000003   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000003   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000003   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000003   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000002   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000003   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/health.vim
Sourced 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005 autocmd CmdUndefined CheckHealth checkhealth

SCRIPT  /usr/share/nvim/runtime/plugin/man.vim
Sourced 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
                            " Maintainer: Anmol Sethi <anmol@aubble.com>
                            
    1              0.000003 if exists('g:loaded_man')
                              finish
                            endif
    1              0.000002 let g:loaded_man = 1
                            
    1              0.000009 command! -bar -range=0 -complete=customlist,man#complete -nargs=* Man call man#open_page(v:count, v:count1, <q-mods>, <f-args>)
                            
    1              0.000001 augroup man
    1              0.000014   autocmd!
    1              0.000004   autocmd BufReadCmd man://* call man#read_page(matchstr(expand('<amatch>'), 'man://\zs.*'))
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.000518
 Self time:   0.000518

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Last Change: 2017 Sep 15
                            "  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            "  Version:     1.13.3, for Vim 6.3+
                            "		Fix from Tommy Allen included.
                            "		Fix from Fernando Torres included.
                            "		Improvement from Ken Takata included.
                            "  URL:		http://www.vim.org/script.php?script_id=39
                            
                            " Documentation:
                            "  The documentation is in a separate file, matchit.txt .
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " allow user to prevent loading
                            " and prevent duplicate loading
    1              0.000007 if exists("loaded_matchit") || &cp
                              finish
                            endif
    1              0.000002 let loaded_matchit = 1
    1              0.000002 let s:last_mps = ""
    1              0.000001 let s:last_words = ":"
    1              0.000001 let s:patBR = ""
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000007 nnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'n') <CR>
    1              0.000005 nnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'n') <CR>
    1              0.000006 vnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'v') <CR>m'gv``
    1              0.000005 vnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'v') <CR>m'gv``
    1              0.000005 onoremap <silent> %  v:<C-U>call <SID>Match_wrapper('',1,'o') <CR>
    1              0.000005 onoremap <silent> g% v:<C-U>call <SID>Match_wrapper('',0,'o') <CR>
                            
                            " Analogues of [{ and ]} using matching patterns:
    1              0.000007 nnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "n") <CR>
    1              0.000005 nnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "n") <CR>
    1              0.000004 vmap [% <Esc>[%m'gv``
    1              0.000003 vmap ]% <Esc>]%m'gv``
                            " vnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "v") <CR>m'gv``
                            " vnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "v") <CR>m'gv``
    1              0.000005 onoremap <silent> [% v:<C-U>call <SID>MultiMatch("bW", "o") <CR>
    1              0.000004 onoremap <silent> ]% v:<C-U>call <SID>MultiMatch("W",  "o") <CR>
                            
                            " text object:
    1              0.000003 vmap a% <Esc>[%v]%
                            
                            " Auto-complete mappings:  (not yet "ready for prime time")
                            " TODO Read :help write-plugin for the "right" way to let the user
                            " specify a key binding.
                            "   let g:match_auto = '<C-]>'
                            "   let g:match_autoCR = '<C-CR>'
                            " if exists("g:match_auto")
                            "   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'
                            " endif
                            " if exists("g:match_autoCR")
                            "   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'
                            " endif
                            " if exists("g:match_gthhoh")
                            "   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'
                            " endif " gthhoh = "Get the heck out of here!"
                            
    1              0.000002 let s:notslash = '\\\@<!\%(\\\\\)*'
                            
    1              0.000003 function! s:Match_wrapper(word, forward, mode) range
                              " In s:CleanUp(), :execute "set" restore_options .
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              if &ve != ''
                                let restore_options = " ve=" . &ve . restore_options
                                set ve=
                              endif
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
                              if a:mode == "v"
                                execute "normal! gv\<Esc>"
                              endif
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
                              let startline = line(".")
                              let startcol = col(".")
                              " Use default behavior if called with a count.
                              if v:count
                                exe "normal! " . v:count . "%"
                                return s:CleanUp(restore_options, a:mode, startline, startcol)
                              end
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              "
                              if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
                              elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
                              if (match_words != s:last_words) || (&mps != s:last_mps)
                                  \ || exists("b:match_debug")
                                let s:last_mps = &mps
                                " The next several lines were here before
                                " BF started messing with this script.
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
                                " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
                                "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
                                let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
                                  \ '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                let s:last_words = match_words
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = substitute(s:pat, s:notslash . '\zs[,:]\+', '\\|', 'g')
                                let s:all = '\%(' . s:all . '\)'
                                " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                                " Reconstruct the version with unresolved backrefs.
                                let s:patBR = substitute(match_words.',',
                                  \ s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                                let s:patBR = substitute(s:patBR, s:notslash.'\zs:\{2,}', ':', 'g')
                              endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
                              let matchline = getline(startline)
                              if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else	" Find the match that ends on or after the cursor and set curcol.
                                let regexp = s:Wholematch(matchline, s:all, startcol-1)
                                let curcol = match(matchline, regexp)
                                " If there is no match, give up.
                                if curcol == -1
                                  return s:CleanUp(restore_options, a:mode, startline, startcol)
                                endif
                                let endcol = matchend(matchline, regexp)
                                let suf = strlen(matchline) - endcol
                                let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
                                let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
                              endif
                              if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
                              let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, s:patBR)
                              let i = matchend(group, s:notslash . ",")
                              let groupBR = strpart(group, i)
                              let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                              if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
                              if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash . ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
                              let i = matchend(group, s:notslash . ":")
                              let j = matchend(group, '.*' . s:notslash . ":")
                              let ini = strpart(group, 0, i-1)
                              let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
                              let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
                              let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
                              let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
                              let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
                              let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix
                                \ || !a:forward && matchline =~ prefix . ini . suffix
                                let mid = ""
                              endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix . fin . suffix
                                \ || !a:forward && matchline !~ prefix . ini . suffix
                                let flag = "bW"
                              else
                                let flag = "W"
                              endif
                              " Set skip.
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
                              let view = winsaveview()
                              call cursor(0, curcol + 1)
                              " normal! 0
                              " if curcol
                              "   execute "normal!" . curcol . "l"
                              " endif
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = "0"
                              else
                                execute "if " . skip . "| let skip = '0' | endif"
                              endif
                              let sp_return = searchpair(ini, mid, fin, flag, skip)
                              let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
                              " Restore cursor position and original screen.
                              call winrestview(view)
                              normal! m'
                              if sp_return > 0
                                execute final_position
                              endif
                              return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)
                            endfun
                            
                            " Restore options and do some special handling for Operator-pending mode.
                            " The optional argument is the tail of the matching group.
    1              0.000002 fun! s:CleanUp(options, mode, startline, startcol, ...)
                              if strlen(a:options)
                                execute "set" a:options
                              endif
                              " Open folds, if appropriate.
                              if a:mode != "o"
                                if &foldopen =~ "percent"
                                  normal! zv
                                endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
                              elseif (a:startline < line(".")) ||
                            	\ (a:startline == line(".") && a:startcol < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                            	call cursor(0, endcol)
                                  endif
                                endif " a:0
                              endif " a:mode != "o" && etc.
                              return 0
                            endfun
                            
                            " Example (simplified HTML patterns):  if
                            "   a:groupBR	= '<\(\k\+\)>:</\1>'
                            "   a:prefix	= '^.\{3}\('
                            "   a:group	= '<\(\k\+\)>:</\(\k\+\)>'
                            "   a:suffix	= '\).\{2}$'
                            "   a:matchline	=  "123<tag>12" or "123</tag>12"
                            " then extract "tag" from a:matchline and return "<tag>:</tag>" .
    1              0.000002 fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              if a:matchline !~ a:prefix .
                                \ substitute(a:group, s:notslash . '\zs:', '\\|', 'g') . a:suffix
                                return a:group
                              endif
                              let i = matchend(a:groupBR, s:notslash . ':')
                              let ini = strpart(a:groupBR, 0, i-1)
                              let tailBR = strpart(a:groupBR, i)
                              let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix,
                                \ a:groupBR)
                              let i = matchend(word, s:notslash . ":")
                              let wordBR = strpart(word, i)
                              let word = strpart(word, 0, i-1)
                              " Now, a:matchline =~ a:prefix . word . a:suffix
                              if wordBR != ini
                                let table = s:Resolve(ini, wordBR, "table")
                              else
                                " let table = "----------"
                                let table = ""
                                let d = 0
                                while d < 10
                                  if tailBR =~ s:notslash . '\\' . d
                            	" let table[d] = d
                            	let table = table . d
                                  else
                            	let table = table . "-"
                                  endif
                                  let d = d + 1
                                endwhile
                              endif
                              let d = 9
                              while d
                                if table[d] != "-"
                                  let backref = substitute(a:matchline, a:prefix.word.a:suffix,
                            	\ '\'.table[d], "")
                            	" Are there any other characters that should be escaped?
                                  let backref = escape(backref, '*,:')
                                  execute s:Ref(ini, d, "start", "len")
                                  let ini = strpart(ini, 0, start) . backref . strpart(ini, start+len)
                                  let tailBR = substitute(tailBR, s:notslash . '\zs\\' . d,
                            	\ escape(backref, '\\&'), 'g')
                                endif
                                let d = d-1
                              endwhile
                              if exists("b:match_debug")
                                if s:do_BR
                                  let b:match_table = table
                                  let b:match_word = word
                                else
                                  let b:match_table = ""
                                  let b:match_word = ""
                                endif
                              endif
                              return ini . ":" . tailBR
                            endfun
                            
                            " Input a comma-separated list of groups with backrefs, such as
                            "   a:groups = '\(foo\):end\1,\(bar\):end\1'
                            " and return a comma-separated list of groups with backrefs replaced:
                            "   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'
    1              0.000001 fun! s:ParseWords(groups)
                              let groups = substitute(a:groups.",", s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
                              let groups = substitute(groups, s:notslash . '\zs:\{2,}', ':', 'g')
                              let parsed = ""
                              while groups =~ '[^,:]'
                                let i = matchend(groups, s:notslash . ':')
                                let j = matchend(groups, s:notslash . ',')
                                let ini = strpart(groups, 0, i-1)
                                let tail = strpart(groups, i, j-i-1) . ":"
                                let groups = strpart(groups, j)
                                let parsed = parsed . ini
                                let i = matchend(tail, s:notslash . ':')
                                while i != -1
                                  " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
                                  let word = strpart(tail, 0, i-1)
                                  let tail = strpart(tail, i)
                                  let i = matchend(tail, s:notslash . ':')
                                  let parsed = parsed . ":" . s:Resolve(ini, word, "word")
                                endwhile " Now, tail has been used up.
                                let parsed = parsed . ","
                              endwhile " groups =~ '[^,:]'
                              let parsed = substitute(parsed, ',$', '', '')
                              return parsed
                            endfun
                            
                            " TODO I think this can be simplified and/or made more efficient.
                            " TODO What should I do if a:start is out of range?
                            " Return a regexp that matches all of a:string, such that
                            " matchstr(a:string, regexp) represents the match for a:pat that starts
                            " as close to a:start as possible, before being preferred to after, and
                            " ends after a:start .
                            " Usage:
                            " let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)
                            " let i      = match(getline("."), regexp)
                            " let j      = matchend(getline("."), regexp)
                            " let match  = matchstr(getline("."), regexp)
    1              0.000002 fun! s:Wholematch(string, pat, start)
                              let group = '\%(' . a:pat . '\)'
                              let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
                              let len = strlen(a:string)
                              let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
                              if a:string !~ prefix . group . suffix
                                let prefix = ''
                              endif
                              return prefix . group . suffix
                            endfun
                            
                            " No extra arguments:  s:Ref(string, d) will
                            " find the d'th occurrence of '\(' and return it, along with everything up
                            " to and including the matching '\)'.
                            " One argument:  s:Ref(string, d, "start") returns the index of the start
                            " of the d'th '\(' and any other argument returns the length of the group.
                            " Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be
                            " executed, having the effect of
                            "   :let foo = s:Ref(string, d, "start")
                            "   :let bar = s:Ref(string, d, "len")
    1              0.000001 fun! s:Ref(string, d, ...)
                              let len = strlen(a:string)
                              if a:d == 0
                                let start = 0
                              else
                                let cnt = a:d
                                let match = a:string
                                while cnt
                                  let cnt = cnt - 1
                                  let index = matchend(match, s:notslash . '\\(')
                                  if index == -1
                            	return ""
                                  endif
                                  let match = strpart(match, index)
                                endwhile
                                let start = len - strlen(match)
                                if a:0 == 1 && a:1 == "start"
                                  return start - 2
                                endif
                                let cnt = 1
                                while cnt
                                  let index = matchend(match, s:notslash . '\\(\|\\)') - 1
                                  if index == -2
                            	return ""
                                  endif
                                  " Increment if an open, decrement if a ')':
                                  let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
                                  " let cnt = stridx('0(', match[index]) + cnt
                                  let match = strpart(match, index+1)
                                endwhile
                                let start = start - 2
                                let len = len - start - strlen(match)
                              endif
                              if a:0 == 1
                                return len
                              elseif a:0 == 2
                                return "let " . a:1 . "=" . start . "| let " . a:2 . "=" . len
                              else
                                return strpart(a:string, start, len)
                              endif
                            endfun
                            
                            " Count the number of disjoint copies of pattern in string.
                            " If the pattern is a literal string and contains no '0' or '1' characters
                            " then s:Count(string, pattern, '0', '1') should be faster than
                            " s:Count(string, pattern).
    1              0.000001 fun! s:Count(string, pattern, ...)
                              let pat = escape(a:pattern, '\\')
                              if a:0 > 1
                                let foo = substitute(a:string, '[^'.a:pattern.']', "a:1", "g")
                                let foo = substitute(a:string, pat, a:2, "g")
                                let foo = substitute(foo, '[^' . a:2 . ']', "", "g")
                                return strlen(foo)
                              endif
                              let result = 0
                              let foo = a:string
                              let index = matchend(foo, pat)
                              while index != -1
                                let result = result + 1
                                let foo = strpart(foo, index)
                                let index = matchend(foo, pat)
                              endwhile
                              return result
                            endfun
                            
                            " s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where
                            " word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first
                            " '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this
                            " indicates that all other instances of '\1' in target are to be replaced
                            " by '\3'.  The hard part is dealing with nesting...
                            " Note that ":" is an illegal character for source and target,
                            " unless it is preceded by "\".
    1              0.000002 fun! s:Resolve(source, target, output)
                              let word = a:target
                              let i = matchend(word, s:notslash . '\\\d') - 1
                              let table = "----------"
                              while i != -2 " There are back references to be replaced.
                                let d = word[i]
                                let backref = s:Ref(a:source, d)
                                " The idea is to replace '\d' with backref.  Before we do this,
                                " replace any \(\) groups in backref with :1, :2, ... if they
                                " correspond to the first, second, ... group already inserted
                                " into backref.  Later, replace :1 with \1 and so on.  The group
                                " number w+b within backref corresponds to the group number
                                " s within a:source.
                                " w = number of '\(' in word before the current one
                                let w = s:Count(
                                \ substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
                                let b = 1 " number of the current '\(' in backref
                                let s = d " number of the current '\(' in a:source
                                while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1')
                                \ && s < 10
                                  if table[s] == "-"
                            	if w + b < 10
                            	  " let table[s] = w + b
                            	  let table = strpart(table, 0, s) . (w+b) . strpart(table, s+1)
                            	endif
                            	let b = b + 1
                            	let s = s + 1
                                  else
                            	execute s:Ref(backref, b, "start", "len")
                            	let ref = strpart(backref, start, len)
                            	let backref = strpart(backref, 0, start) . ":". table[s]
                            	\ . strpart(backref, start+len)
                            	let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
                                  endif
                                endwhile
                                let word = strpart(word, 0, i-1) . backref . strpart(word, i+1)
                                let i = matchend(word, s:notslash . '\\\d') - 1
                              endwhile
                              let word = substitute(word, s:notslash . '\zs:', '\\', 'g')
                              if a:output == "table"
                                return table
                              elseif a:output == "word"
                                return word
                              else
                                return table . word
                              endif
                            endfun
                            
                            " Assume a:comma = ",".  Then the format for a:patterns and a:1 is
                            "   a:patterns = "<pat1>,<pat2>,..."
                            "   a:1 = "<alt1>,<alt2>,..."
                            " If <patn> is the first pattern that matches a:string then return <patn>
                            " if no optional arguments are given; return <patn>,<altn> if a:1 is given.
    1              0.000011 fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)
                              let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
                              let i = matchend(tail, s:notslash . a:comma)
                              if a:0
                                let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
                                let j = matchend(alttail, s:notslash . a:comma)
                              endif
                              let current = strpart(tail, 0, i-1)
                              if a:branch == ""
                                let currpat = current
                              else
                                let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                              endif
                              while a:string !~ a:prefix . currpat . a:suffix
                                let tail = strpart(tail, i)
                                let i = matchend(tail, s:notslash . a:comma)
                                if i == -1
                                  return -1
                                endif
                                let current = strpart(tail, 0, i-1)
                                if a:branch == ""
                                  let currpat = current
                                else
                                  let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
                                endif
                                if a:0
                                  let alttail = strpart(alttail, j)
                                  let j = matchend(alttail, s:notslash . a:comma)
                                endif
                              endwhile
                              if a:0
                                let current = current . a:comma . strpart(alttail, 0, j-1)
                              endif
                              return current
                            endfun
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000003 if !exists(":MatchDebug")
    1              0.000004   command! -nargs=0 MatchDebug call s:Match_debug()
    1              0.000001 endif
                            
    1              0.000001 fun! s:Match_debug()
                              let b:match_debug = 1	" Save debugging information.
                              " pat = all of b:match_words with backrefs parsed
                              amenu &Matchit.&pat	:echo b:match_pat<CR>
                              " match = bit of text that is recognized as a match
                              amenu &Matchit.&match	:echo b:match_match<CR>
                              " curcol = cursor column of the start of the matching text
                              amenu &Matchit.&curcol	:echo b:match_col<CR>
                              " wholeBR = matching group, original version
                              amenu &Matchit.wh&oleBR	:echo b:match_wholeBR<CR>
                              " iniBR = 'if' piece, original version
                              amenu &Matchit.ini&BR	:echo b:match_iniBR<CR>
                              " ini = 'if' piece, with all backrefs resolved from match
                              amenu &Matchit.&ini	:echo b:match_ini<CR>
                              " tail = 'else\|endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&tail	:echo b:match_tail<CR>
                              " fin = 'endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&word	:echo b:match_word<CR>
                              " '\'.d in ini refers to the same thing as '\'.table[d] in word.
                              amenu &Matchit.t&able	:echo '0:' . b:match_table . ':9'<CR>
                            endfun
                            
                            " Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"
                            " or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".
                            " Return a "mark" for the original position, so that
                            "   let m = MultiMatch("bW", "n") ... execute m
                            " will return to the original position.  If there is a problem, do not
                            " move the cursor and return "", unless a count is given, in which case
                            " go up or down as many levels as possible and again return "".
                            " TODO This relies on the same patterns as % matching.  It might be a good
                            " idea to give it its own matching patterns.
    1              0.000001 fun! s:MultiMatch(spflag, mode)
                              if !exists("b:match_words") || b:match_words == ""
                                return {}
                              end
                              let restore_options = ""
                              if exists("b:match_ignorecase") && b:match_ignorecase != &ic
                                let restore_options .= (&ic ? " " : " no") . "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              let startline = line(".")
                              let startcol = col(".")
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR	flag for whether there are backrefs
                              "   s:pat	parsed version of b:match_words
                              "   s:all	regexp based on s:pat and the default groups
                              " This part is copied and slightly modified from s:Match_wrapper().
                              let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
                                \ '\/\*:\*\/,#\s*if\%(def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                              " Allow b:match_words = "GetVimMatchWords()" .
                              if b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                              if (match_words != s:last_words) || (&mps != s:last_mps) ||
                                \ exists("b:match_debug")
                                let s:last_words = match_words
                                let s:last_mps = &mps
                                let match_words = match_words . (strlen(match_words) ? "," : "") . default
                                if match_words !~ s:notslash . '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = '\%(' . substitute(s:pat . (strlen(s:pat) ? "," : "") . default,
                            	\ '[,:]\+', '\\|', 'g') . '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                              endif
                            
                              " Second step:  figure out the patterns for searchpair()
                              " and save the screen, cursor position, and 'ignorecase'.
                              " - TODO:  A lot of this is copied from s:Match_wrapper().
                              " - maybe even more functionality should be split off
                              " - into separate functions!
                              let cdefault = (s:pat =~ '[^,]$' ? "," : "") . default
                              let open =  substitute(s:pat . cdefault,
                            	\ s:notslash . '\zs:.\{-}' . s:notslash . ',', '\\),\\(', 'g')
                              let open =  '\(' . substitute(open, s:notslash . '\zs:.*$', '\\)', '')
                              let close = substitute(s:pat . cdefault,
                            	\ s:notslash . '\zs,.\{-}' . s:notslash . ':', '\\),\\(', 'g')
                              let close = substitute(close, '^.\{-}' . s:notslash . ':', '\\(', '') . '\)'
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" . b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              let view = winsaveview()
                            
                              " Third step: call searchpair().
                              " Replace '\('--but not '\\('--with '\%(' and ',' with '\|'.
                              let openpat =  substitute(open, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let openpat = substitute(openpat, ',', '\\|', 'g')
                              let closepat = substitute(close, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
                              let closepat = substitute(closepat, ',', '\\|', 'g')
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                execute "if " . skip . "| let skip = '0' | endif"
                              endif
                              mark '
                              let level = v:count1
                              while level
                                if searchpair(openpat, '', closepat, a:spflag, skip) < 1
                                  call s:CleanUp(restore_options, a:mode, startline, startcol)
                                  return {}
                                endif
                                let level = level - 1
                              endwhile
                            
                              " Restore options and return view dict to restore the original position.
                              call s:CleanUp(restore_options, a:mode, startline, startcol)
                              return view
                            endfun
                            
                            " Search backwards for "if" or "while" or "<tag>" or ...
                            " and return "endif" or "endwhile" or "</tag>" or ... .
                            " For now, this uses b:match_words and the same script variables
                            " as s:Match_wrapper() .  Later, it may get its own patterns,
                            " either from a buffer variable or passed as arguments.
                            " fun! s:Autocomplete()
                            "   echo "autocomplete not yet implemented :-("
                            "   if !exists("b:match_words") || b:match_words == ""
                            "     return ""
                            "   end
                            "   let startpos = s:MultiMatch("bW")
                            "
                            "   if startpos == ""
                            "     return ""
                            "   endif
                            "   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct
                            "   " - the appropriate closing.
                            "   let matchline = getline(".")
                            "   let curcol = col(".") - 1
                            "   " - TODO:  Change the s:all argument if there is a new set of match pats.
                            "   let regexp = s:Wholematch(matchline, s:all, curcol)
                            "   let suf = strlen(matchline) - matchend(matchline, regexp)
                            "   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')
                            "   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')
                            "   " Reconstruct the version with unresolved backrefs.
                            "   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')
                            "   let patBR = substitute(patBR, ':\{2,}', ':', "g")
                            "   " Now, set group and groupBR to the matching group: 'if:endif' or
                            "   " 'while:endwhile' or whatever.
                            "   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
                            "   let i = matchend(group, s:notslash . ",")
                            "   let groupBR = strpart(group, i)
                            "   let group = strpart(group, 0, i-1)
                            "   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                            "   if s:do_BR
                            "     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                            "   endif
                            " " let g:group = group
                            "
                            "   " - TODO:  Construct the closing from group.
                            "   let fake = "end" . expand("<cword>")
                            "   execute startpos
                            "   return fake
                            " endfun
                            
                            " Close all open structures.  "Get the heck out of here!"
                            " fun! s:Gthhoh()
                            "   let close = s:Autocomplete()
                            "   while strlen(close)
                            "     put=close
                            "     let close = s:Autocomplete()
                            "   endwhile
                            " endfun
                            
                            " Parse special strings as typical skip arguments for searchpair():
                            "   s:foo becomes (current syntax item) =~ foo
                            "   S:foo becomes (current syntax item) !~ foo
                            "   r:foo becomes (line before cursor) =~ foo
                            "   R:foo becomes (line before cursor) !~ foo
    1              0.000002 fun! s:ParseSkip(str)
                              let skip = a:str
                              if skip[1] == ":"
                                if skip[0] == "s"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" .
                            	\ strpart(skip,2) . "'"
                                elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" .
                            	\ strpart(skip,2) . "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
                                endif
                              endif
                              return skip
                            endfun
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:

SCRIPT  /usr/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2017 Sep 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000009 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
                            endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000002 if !exists("g:matchparen_timeout")
    1              0.000003   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000002 if !exists("g:matchparen_insert_timeout")
    1              0.000002   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
                            
    1              0.000001 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000007   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000003   if exists('##TextChanged')
    1              0.000009     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000003 if exists("*s:Highlight_Matching_Pair")
                              finish
                            endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000006 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000003 function! s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000004 command! DoMatchParen call s:DoMatchParen()
    1              0.000003 command! NoMatchParen call s:NoMatchParen()
                            
    1              0.000001 func! s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func! s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000479
 Self time:   0.000479

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 08, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000007 if &cp || exists("g:loaded_netrwPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_netrwPlugin = "v156"
    1              0.000005 let s:keepcpo = &cpo
    1              0.000005 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000001 augroup FileExplorer
    1              0.000049  au!
    1              0.000014  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000003  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000004  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000010  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
                             endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000013  au!
    1              0.000006  au BufReadCmd   file://*											call netrw#FileUrlRead(expand("<amatch>"))
    1              0.000022  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000017  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000022  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000016  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000002  try                                                       
    1              0.000015   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000002  catch /^Vim\%((\a\+)\)\=:E216/                            
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000011 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000011 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000004 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000008 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000004 com! -nargs=?		Ntree		call netrw#SetTreetop(<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000007 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000006 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000007 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000006 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000006 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000004 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000006 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000003 if !exists("g:netrw_nogx")
    1              0.000005  if maparg('gx','n') == ""
    1              0.000005   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000005    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000011   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
    1              0.000001  endif
    1              0.000004  if maparg('gx','v') == ""
    1              0.000005   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000004    vmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000001   endif
    1              0.000006   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000003 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
                            endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000003 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000001 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000007 let &cpo= s:keepcpo
    1              0.000001 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.001002
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_remote_plugins')
                              finish
                            endif
    1              0.000002 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = has('win32') ? '$LOCALAPPDATA' : '$XDG_DATA_HOME'
                              if !exists(dest)
                                let dest = has('win32') ? '~/AppData/Local' : '~/.local/share'
                              endif
                            
                              let dest = fnamemodify(expand(dest), ':p')
                              if !empty(dest)
                                let dest .= ('/' ==# dest[-1:] ? '' : '/') . 'nvim'
                                if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000001 function! s:GetOldManifestPath() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              return fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                let old_manifest = s:GetOldManifestPath()
                                if filereadable(old_manifest)
                                  call rename(old_manifest, manifest)
                                endif
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000005 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1   0.000958   0.000005 call s:LoadRemotePlugins()

SCRIPT  /home/greg/.local/share/nvim/rplugin.vim
Sourced 1 time
Total time:   0.000841
 Self time:   0.000142

count  total (s)   self (s)
                            " node plugins
                            
                            
                            " python3 plugins
    1   0.000831   0.000133 call remote#host#RegisterPlugin('python3', '/home/greg/.config/nvim/plugged/deoplete.nvim/rplugin/python3/deoplete', [
                                  \ {'sync': v:false, 'name': '_deoplete_init', 'type': 'function', 'opts': {}},
                                 \ ])
                            
                            
                            " ruby plugins
                            
                            
                            " python plugins
                            
                            

SCRIPT  /usr/share/nvim/runtime/autoload/remote/host.vim
Sourced 1 time
Total time:   0.000181
 Self time:   0.000138

count  total (s)   self (s)
    1              0.000003 let s:hosts = {}
    1              0.000002 let s:plugin_patterns = {}
    1              0.000001 let s:plugins_for_host = {}
                            
                            " Register a host by associating it with a factory(funcref)
    1              0.000002 function! remote#host#Register(name, pattern, factory) abort
                              let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}
                              let s:plugin_patterns[a:name] = a:pattern
                              if type(a:factory) == type(1) && a:factory
                                " Passed a channel directly
                                let s:hosts[a:name].channel = a:factory
                              endif
                            endfunction
                            
                            " Register a clone to an existing host. The new host will use the same factory
                            " as `source`, but it will run as a different process. This can be used by
                            " plugins that should run isolated from other plugins created for the same host
                            " type
    1              0.000002 function! remote#host#RegisterClone(name, orig_name) abort
                              if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
                              endif
                              let Factory = s:hosts[a:orig_name].factory
                              let s:hosts[a:name] = {
                                    \ 'factory': Factory,
                                    \ 'channel': 0,
                                    \ 'initialized': 0,
                                    \ 'orig_name': a:orig_name
                                    \ }
                            endfunction
                            
                            " Get a host channel, bootstrapping it if necessary
    1              0.000002 function! remote#host#Require(name) abort
                              if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
                              let host = s:hosts[a:name]
                              if !host.channel && !host.initialized
                                let host_info = {
                                      \ 'name': a:name,
                                      \ 'orig_name': get(host, 'orig_name', a:name)
                                      \ }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
                              endif
                              return host.channel
                            endfunction
                            
    1              0.000002 function! remote#host#IsRunning(name) abort
                              if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
                              return s:hosts[a:name].channel != 0
                            endfunction
                            
                            " Example of registering a Python plugin with two commands (one async), one
                            " autocmd (async) and one function (sync):
                            "
                            " let s:plugin_path = expand('<sfile>:p:h').'/nvim_plugin.py'
                            " call remote#host#RegisterPlugin('python', s:plugin_path, [
                            "   \ {'type': 'command', 'name': 'PyCmd', 'sync': 1, 'opts': {}},
                            "   \ {'type': 'command', 'name': 'PyAsyncCmd', 'sync': 0, 'opts': {'eval': 'cursor()'}},
                            "   \ {'type': 'autocmd', 'name': 'BufEnter', 'sync': 0, 'opts': {'eval': 'expand("<afile>")'}},
                            "   \ {'type': 'function', 'name': 'PyFunc', 'sync': 1, 'opts': {}}
                            "   \ ])
                            "
                            " The third item in a declaration is a boolean: non zero means the command,
                            " autocommand or function will be executed synchronously with rpcrequest.
    1              0.000002 function! remote#host#RegisterPlugin(host, path, specs) abort
                              let plugins = remote#host#PluginsForHost(a:host)
                            
                              for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
                              endfor
                            
                              if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
                              endif
                            
                              for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
                              endfor
                            
                              call add(plugins, {'path': a:path, 'specs': a:specs})
                            endfunction
                            
    1              0.000002 function! s:RegistrationCommands(host) abort
                              " Register a temporary host clone for discovering specs
                              let host_id = a:host.'-registration-clone'
                              call remote#host#RegisterClone(host_id, a:host)
                              let pattern = s:plugin_patterns[a:host]
                              let paths = globpath(&rtp, 'rplugin/'.a:host.'/'.pattern, 0, 1)
                              let paths = map(paths, 'tr(resolve(v:val),"\\","/")') " Normalize slashes #4795
                              let paths = uniq(sort(paths))
                              if empty(paths)
                                return []
                              endif
                            
                              for path in paths
                                call remote#host#RegisterPlugin(host_id, path, [])
                              endfor
                              let channel = remote#host#Require(host_id)
                              let lines = []
                              let registered = []
                              for path in paths
                                unlet! specs
                                let specs = rpcrequest(channel, 'specs', path)
                                if type(specs) != type([])
                                  " host didn't return a spec list, indicates a failure while loading a
                                  " plugin
                                  continue
                                endif
                                call add(lines, "call remote#host#RegisterPlugin('".a:host
                                      \ ."', '".path."', [")
                                for spec in specs
                                  call add(lines, "      \\ ".string(spec).",")
                                endfor
                                call add(lines, "     \\ ])")
                                call add(registered, path)
                              endfor
                              echomsg printf("remote/host: %s host registered plugins %s",
                                    \ a:host, string(map(registered, "fnamemodify(v:val, ':t')")))
                            
                              " Delete the temporary host clone
                              call rpcstop(s:hosts[host_id].channel)
                              call remove(s:hosts, host_id)
                              call remove(s:plugins_for_host, host_id)
                              return lines
                            endfunction
                            
    1              0.000002 function! remote#host#UpdateRemotePlugins() abort
                              let commands = []
                              let hosts = keys(s:hosts)
                              for host in hosts
                                if has_key(s:plugin_patterns, host)
                                  try
                                    let commands +=
                                          \   ['" '.host.' plugins']
                                          \ + s:RegistrationCommands(host)
                                          \ + ['', '']
                                  catch
                                    echomsg v:throwpoint
                                    echomsg v:exception
                                  endtry
                                endif
                              endfor
                              call writefile(commands, g:loaded_remote_plugins)
                              echomsg printf('remote/host: generated rplugin manifest: %s',
                                    \ g:loaded_remote_plugins)
                            endfunction
                            
    1              0.000002 function! remote#host#PluginsForHost(host) abort
                              if !has_key(s:plugins_for_host, a:host)
                                let s:plugins_for_host[a:host] = []
                              end
                              return s:plugins_for_host[a:host]
                            endfunction
                            
    1              0.000002 function! remote#host#LoadErrorForHost(host, log) abort
                              return 'Failed to load '. a:host . ' host. '.
                                    \ 'You can try to see what happened by starting nvim with '.
                                    \ a:log . ' set and opening the generated log file.'.
                                    \ ' Also, the host stderr is available in messages.'
                            endfunction
                            
                            " Registration of standard hosts
                            
                            " Python/Python3
    1   0.000019   0.000007 call remote#host#Register('python', '*',
                                  \ function('provider#pythonx#Require'))
    1   0.000017   0.000005 call remote#host#Register('python3', '*',
                                  \ function('provider#pythonx#Require'))
                            
                            " Ruby
    1   0.000014   0.000005 call remote#host#Register('ruby', '*.rb',
                                  \ function('provider#ruby#Require'))
                            
                            " nodejs
    1   0.000015   0.000006 call remote#host#Register('node', '*',
                                  \ function('provider#node#Require'))

SCRIPT  /usr/share/nvim/runtime/autoload/remote/define.vim
Sourced 1 time
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
    1              0.000004 function! remote#define#CommandOnHost(host, method, sync, name, opts)
                              let prefix = ''
                            
                              if has_key(a:opts, 'range')
                                if a:opts.range == '' || a:opts.range == '%'
                                  " -range or -range=%, pass the line range in a list
                                  let prefix = '<line1>,<line2>'
                                elseif matchstr(a:opts.range, '\d') != ''
                                  " -range=N, pass the count
                                  let prefix = '<count>'
                                endif
                              elseif has_key(a:opts, 'count')
                                let prefix = '<count>'
                              endif
                            
                              let forward_args = [prefix.a:name]
                            
                              if has_key(a:opts, 'bang')
                                call add(forward_args, '<bang>')
                              endif
                            
                              if has_key(a:opts, 'register')
                                call add(forward_args, ' <register>')
                              endif
                            
                              if has_key(a:opts, 'nargs')
                                call add(forward_args, ' <args>')
                              endif
                            
                              exe s:GetCommandPrefix(a:name, a:opts)
                                    \ .' call remote#define#CommandBootstrap("'.a:host.'"'
                                    \ .                                ', "'.a:method.'"'
                                    \ .                                ', '.string(a:sync)
                                    \ .                                ', "'.a:name.'"'
                                    \ .                                ', '.string(a:opts).''
                                    \ .                                ', "'.join(forward_args, '').'"'
                                    \ .                                ')'
                            endfunction
                            
                            
    1              0.000003 function! remote#define#CommandBootstrap(host, method, sync, name, opts, forward)
                              let channel = remote#host#Require(a:host)
                            
                              if channel
                                call remote#define#CommandOnChannel(channel, a:method, a:sync, a:name, a:opts)
                                exe a:forward
                              else
                                exe 'delcommand '.a:name
                                echoerr 'Host "'a:host.'" is not available, deleting command "'.a:name.'"'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! remote#define#CommandOnChannel(channel, method, sync, name, opts)
                              let rpcargs = [a:channel, '"'.a:method.'"']
                              if has_key(a:opts, 'nargs')
                                " -nargs, pass arguments in a list
                                call add(rpcargs, '[<f-args>]')
                              endif
                            
                              if has_key(a:opts, 'range')
                                if a:opts.range == '' || a:opts.range == '%'
                                  " -range or -range=%, pass the line range in a list
                                  call add(rpcargs, '[<line1>, <line2>]')
                                elseif matchstr(a:opts.range, '\d') != ''
                                  " -range=N, pass the count
                                  call add(rpcargs, '<count>')
                                endif
                              elseif has_key(a:opts, 'count')
                                " count
                                call add(rpcargs, '<count>')
                              endif
                            
                              if has_key(a:opts, 'bang')
                                " bang
                                call add(rpcargs, '<q-bang> == "!"')
                              endif
                            
                              if has_key(a:opts, 'register')
                                " register
                                call add(rpcargs, '<q-reg>')
                              endif
                            
                              call s:AddEval(rpcargs, a:opts)
                              exe s:GetCommandPrefix(a:name, a:opts)
                                    \ . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
                            endfunction
                            
                            
    1              0.000002 function! remote#define#AutocmdOnHost(host, method, sync, name, opts)
                              let group = s:GetNextAutocmdGroup()
                              let forward = '"doau '.group.' '.a:name.' ".'
                                    \ . 'fnameescape(expand("<amatch>"))'
                              let a:opts.group = group
                              let bootstrap_def = s:GetAutocmdPrefix(a:name, a:opts)
                                    \ .' call remote#define#AutocmdBootstrap("'.a:host.'"'
                                    \ .                                ', "'.a:method.'"'
                                    \ .                                ', '.string(a:sync)
                                    \ .                                ', "'.a:name.'"'
                                    \ .                                ', '.string(a:opts).''
                                    \ .                                ', "'.escape(forward, '"').'"'
                                    \ .                                ')'
                              exe bootstrap_def
                            endfunction
                            
                            
    1              0.000002 function! remote#define#AutocmdBootstrap(host, method, sync, name, opts, forward)
                              let channel = remote#host#Require(a:host)
                            
                              exe 'autocmd! '.a:opts.group
                              if channel
                                call remote#define#AutocmdOnChannel(channel, a:method, a:sync, a:name,
                                      \ a:opts)
                                exe eval(a:forward)
                              else
                                exe 'augroup! '.a:opts.group
                                echoerr 'Host "'a:host.'" for "'.a:name.'" autocmd is not available'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! remote#define#AutocmdOnChannel(channel, method, sync, name, opts)
                              let rpcargs = [a:channel, '"'.a:method.'"']
                              call s:AddEval(rpcargs, a:opts)
                            
                              let autocmd_def = s:GetAutocmdPrefix(a:name, a:opts)
                                    \ . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
                              exe autocmd_def
                            endfunction
                            
                            
    1              0.000004 function! remote#define#FunctionOnHost(host, method, sync, name, opts)
                              let group = s:GetNextAutocmdGroup()
                              exe 'autocmd! '.group.' FuncUndefined '.a:name
                                    \ .' call remote#define#FunctionBootstrap("'.a:host.'"'
                                    \ .                                 ', "'.a:method.'"'
                                    \ .                                 ', '.string(a:sync)
                                    \ .                                 ', "'.a:name.'"'
                                    \ .                                 ', '.string(a:opts)
                                    \ .                                 ', "'.group.'"'
                                    \ .                                 ')'
                            endfunction
                            
                            
    1              0.000002 function! remote#define#FunctionBootstrap(host, method, sync, name, opts, group)
                              let channel = remote#host#Require(a:host)
                            
                              exe 'autocmd! '.a:group
                              exe 'augroup! '.a:group
                              if channel
                                call remote#define#FunctionOnChannel(channel, a:method, a:sync, a:name,
                                      \ a:opts)
                              else
                                echoerr 'Host "'a:host.'" for "'.a:name.'" function is not available'
                              endif
                            endfunction
                            
                            
    1              0.000003 function! remote#define#FunctionOnChannel(channel, method, sync, name, opts)
                              let rpcargs = [a:channel, '"'.a:method.'"', 'a:000']
                              if has_key(a:opts, 'range')
                                call add(rpcargs, '[a:firstline, a:lastline]')
                              endif
                              call s:AddEval(rpcargs, a:opts)
                            
                              let function_def = s:GetFunctionPrefix(a:name, a:opts)
                                    \ . 'return '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
                                    \ . "\nendfunction"
                              exe function_def
                            endfunction
                            
    1              0.000004 let s:busy = {}
    1              0.000003 let s:pending_notifications = {}
                            
    1              0.000003 function! s:GetRpcFunction(sync)
                              if a:sync ==# 'urgent'
                                return 'rpcnotify'
                              elseif a:sync
                                return 'remote#define#request'
                              endif
                              return 'remote#define#notify'
                            endfunction
                            
    1              0.000003 function! remote#define#notify(chan, ...)
                              if get(s:busy, a:chan, 0) > 0
                                let pending = get(s:pending_notifications, a:chan, [])
                                call add(pending, deepcopy(a:000))
                                let s:pending_notifications[a:chan] = pending
                              else
                                call call('rpcnotify', [a:chan] + a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! remote#define#request(chan, ...)
                              let s:busy[a:chan] = get(s:busy, a:chan, 0)+1
                              let val = call('rpcrequest', [a:chan]+a:000)
                              let s:busy[a:chan] -= 1
                              if s:busy[a:chan] == 0
                                for msg in get(s:pending_notifications, a:chan, [])
                                  call call('rpcnotify', [a:chan] + msg)
                                endfor
                                let s:pending_notifications[a:chan] = []
                              endif
                              return val
                            endfunction
                            
    1              0.000003 function! s:GetCommandPrefix(name, opts)
                              return 'command!'.s:StringifyOpts(a:opts, ['nargs', 'complete', 'range',
                                    \ 'count', 'bang', 'bar', 'register']).' '.a:name
                            endfunction
                            
                            
                            " Each msgpack-rpc autocommand has it's own unique group, which is derived
                            " from an autoincrementing gid(group id). This is required for replacing the
                            " autocmd implementation with the lazy-load mechanism
    1              0.000003 let s:next_gid = 1
    1              0.000002 function! s:GetNextAutocmdGroup()
                              let gid = s:next_gid
                              let s:next_gid += 1
                            
                              let group_name = 'RPC_DEFINE_AUTOCMD_GROUP_'.gid
                              " Ensure the group is defined
                              exe 'augroup '.group_name.' | augroup END'
                              return group_name
                            endfunction
                            
                            
    1              0.000002 function! s:GetAutocmdPrefix(name, opts)
                              if has_key(a:opts, 'group')
                                let group = a:opts.group
                              else
                                let group = s:GetNextAutocmdGroup()
                              endif
                              let rv = ['autocmd!', group, a:name]
                            
                              if has_key(a:opts, 'pattern')
                                call add(rv, a:opts.pattern)
                              else
                                call add(rv, '*')
                              endif
                            
                              if has_key(a:opts, 'nested') && a:opts.nested
                                call add(rv, 'nested')
                              endif
                            
                              return join(rv, ' ')
                            endfunction
                            
                            
    1              0.000002 function! s:GetFunctionPrefix(name, opts)
                              let res = "function! ".a:name."(...)"
                              if has_key(a:opts, 'range')
                                let res = res." range"
                              endif
                              return res."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:StringifyOpts(opts, keys)
                              let rv = []
                              for key in a:keys
                                if has_key(a:opts, key)
                                  call add(rv, ' -'.key)
                                  let val = a:opts[key]
                                  if type(val) != type('') || val != ''
                                    call add(rv, '='.val)
                                  endif
                                endif
                              endfor
                              return join(rv, '')
                            endfunction
                            
                            
    1              0.000003 function! s:AddEval(rpcargs, opts)
                              if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
                              endif
                            endfunction

SCRIPT  /usr/share/nvim/runtime/plugin/rrhelper.vim
Sourced 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                            " Vim plugin with helper function(s) for --remote-wait
                            " Maintainer: Flemming Madsen <fma@cci.dk>
                            " Last Change: 2008 May 29
                            
                            " Has this already been loaded?
    1              0.000006 if exists("loaded_rrhelper") || !has("clientserver")
    1              0.000001   finish
                            endif
                            let loaded_rrhelper = 1
                            
                            " Setup answers for a --remote-wait client who will assume
                            " a SetupRemoteReplies() function in the command server
                            
                            function SetupRemoteReplies()
                              let cnt = 0
                              let max = argc()
                            
                              let id = expand("<client>")
                              if id == 0
                                return
                              endif
                              while cnt < max
                                " Handle same file from more clients and file being more than once
                                " on the command line by encoding this stuff in the group name
                                let uniqueGroup = "RemoteReply_".id."_".cnt
                            
                                " Path separators are always forward slashes for the autocommand pattern.
                                " Escape special characters with a backslash.
                                let f = substitute(argv(cnt), '\\', '/', "g")
                                if exists('*fnameescape')
                                  let f = fnameescape(f)
                                else
                                  let f = escape(f, " \t\n*?[{`$\\%#'\"|!<")
                                endif
                                execute "augroup ".uniqueGroup
                                execute "autocmd ".uniqueGroup." BufUnload ". f ."  call DoRemoteReply('".id."', '".cnt."', '".uniqueGroup."', '". f ."')"
                                let cnt = cnt + 1
                              endwhile
                              augroup END
                            endfunc
                            
                            function DoRemoteReply(id, cnt, group, file)
                              call server2client(a:id, a:cnt)
                              execute 'autocmd! '.a:group.' BufUnload '.a:file
                              execute 'augroup! '.a:group
                            endfunc
                            
                            " vim: set sw=2 sts=2 :

SCRIPT  /usr/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000003 if exists('g:loaded_shada_plugin')
                              finish
                            endif
    1              0.000002 let g:loaded_shada_plugin = 1
                            
    1              0.000001 augroup ShaDaCommands
    1              0.000015   autocmd!
    1              0.000010   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000010   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000012   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000010   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000009   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000005   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000010 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
                            endif
    1              0.000002 let loaded_spellfile_plugin = 1
                            
    1              0.000005 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000007 if &cp || exists("g:loaded_tarPlugin")
                             finish
                            endif
    1              0.000002 let g:loaded_tarPlugin = "v29"
    1              0.000005 let s:keepcpo          = &cpo
    1              0.000006 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000001 augroup tar
    1              0.000014   au!
    1              0.000004   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000005   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000003   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000003   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000002   if has("unix")
    1              0.000004    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000005    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000005    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000006    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000006   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000004   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000006 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000008 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo

SCRIPT  /usr/share/nvim/runtime/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2015 Sep 08
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
                            " TODO: {{{
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
    1              0.000003 if exists('g:loaded_2html_plugin')
                              finish
                            endif
    1              0.000002 let g:loaded_2html_plugin = 'vim7.4_v2'
                            
                            "
                            " Changelog: {{{
                            "   7.4_v2  (this version): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evalutated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin was not already loaded
                            " - user commands are available. {{{
    1              0.000009 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000008   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
                            endif
    1              0.000004 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000006 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /usr/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Sep 13, 2016
                            " Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000006 if &cp || exists("g:loaded_zipPlugin")
                             finish
                            endif
    1              0.000010 let g:loaded_zipPlugin = "v28"
    1              0.000005 let s:keepcpo          = &cpo
    1              0.000006 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000003 if !exists("g:zipPlugin_ext")
    1              0.000009  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001 augroup zip
    1              0.000014  au!
    1              0.000004  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000004  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000007  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000002  if has("unix")
    1              0.000004   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000004   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000047  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000006 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo

SCRIPT  /usr/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.000284
 Self time:   0.000284

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2014 Sep 07
                            
                            " Only do this when not done yet for this buffer
    1              0.000004 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    1              0.000002 let b:did_ftplugin = 1
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000008 set cpo-=C
                            
    1              0.000005 let b:undo_ftplugin = "setl fo< isk< com< tw< commentstring< keywordprg<"
                            	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000010 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000024 setlocal isk+=#
                            
                            " Set 'comments' to format dashed lists in comments
    1              0.000006 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    1              0.000003 if &tw == 0
    1              0.000004   setlocal tw=78
    1              0.000001 endif
                            
                            " Comments start with a double quote
    1              0.000002 setlocal commentstring=\"%s
                            
                            " Prefer Vim help instead of manpages.
    1              0.000001 setlocal keywordprg=:help
                            
                            " Move around functions.
    1              0.000016 nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000010 vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    1              0.000006 nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000007 vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    1              0.000006 nnoremap <silent><buffer> [] m':call search('^\s*endf*\%[unction]\>', "bW")<CR>
    1              0.000008 vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "bW")<CR>
    1              0.000006 nnoremap <silent><buffer> ][ m':call search('^\s*endf*\%[unction]\>', "W")<CR>
    1              0.000007 vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf*\%[unction]\>', "W")<CR>
                            
                            " Move around comments
    1              0.000006 nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000008 vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000006 nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000008 vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000003 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
    1              0.000055   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,' .
                            	\ '(:)'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
    1              0.000004   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000001 endif
                            
    1              0.000007 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    1              0.000003 if exists("b:did_indent")
                              finish
                            endif
    1              0.000002 let b:did_indent = 1
                            
    1              0.000002 setlocal indentexpr=GetVimIndent()
    1              0.000002 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\
                            
    1              0.000002 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000002 if exists("*GetVimIndent")
                              finish
                            endif
    1              0.000006 let s:keepcpo= &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000002 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
    1              0.000001 function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' and below a line that starts
                              " with '\', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ '^\s*\\'
                                while lnum > 0 && getline(lnum) =~ '^\s*\\'
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' after
                              " a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ '^\s*\\' && v:lnum > 1 && prev_text !~ '^\s*\\'
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000006 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.005596
 Self time:   0.005596

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000003 if exists("b:current_syntax")
                              finish
                            endif
    1              0.000006 let s:keepcpo= &cpo
    1              0.000006 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000013 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000005 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000008 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000009 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000010 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000024 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000007 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000005 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000098 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000005 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000003 syn match   vimTermOption contained	"t_%1"
    1              0.000003 syn match   vimTermOption contained	"t_#2"
    1              0.000002 syn match   vimTermOption contained	"t_#4"
    1              0.000002 syn match   vimTermOption contained	"t_@7"
    1              0.000003 syn match   vimTermOption contained	"t_*7"
    1              0.000003 syn match   vimTermOption contained	"t_&8"
    1              0.000002 syn match   vimTermOption contained	"t_%i"
    1              0.000002 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000007 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000001 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000017 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000029 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    1              0.000006 syn match vimHLGroup contained	"Conceal"
    1              0.000006 syn keyword vimOnlyHLGroup contained	VisualNOS
    1              0.000009 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC QuickFixLine
                            "}}}2
    1              0.000001 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a' 
                              com! -nargs=* VimFolda <args> fold 
                             else 
                              com! -nargs=* VimFolda <args> 
                             endif
                             if g:vimsyn_folding =~# 'f' 
                              com! -nargs=* VimFoldf <args> fold 
                             else 
                              com! -nargs=* VimFoldf <args> 
                             endif
                             if g:vimsyn_folding =~# 'l' 
                              com! -nargs=* VimFoldl <args> fold 
                             else 
                              com! -nargs=* VimFoldl <args> 
                             endif
                             if g:vimsyn_folding =~# 'm' 
                              com! -nargs=* VimFoldm <args> fold 
                             else 
                              com! -nargs=* VimFoldm <args> 
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P' 
                              com! -nargs=* VimFoldP <args> fold 
                             else 
                              com! -nargs=* VimFoldP <args> 
                             endif
                             if g:vimsyn_folding =~# 'r' 
                              com! -nargs=* VimFoldr <args> fold 
                             else 
                              com! -nargs=* VimFoldr <args> 
                             endif
                             if g:vimsyn_folding =~# 't' 
                              com! -nargs=* VimFoldt <args> fold 
                             else 
                              com! -nargs=* VimFoldt <args> 
                             endif
                            else
    1              0.000005  com! -nargs=*	VimFolda	<args>
    1              0.000003  com! -nargs=*	VimFoldf	<args>
    1              0.000003  com! -nargs=*	VimFoldl	<args>
    1              0.000003  com! -nargs=*	VimFoldm	<args>
    1              0.000003  com! -nargs=*	VimFoldp	<args>
    1              0.000003  com! -nargs=*	VimFoldP	<args>
    1              0.000003  com! -nargs=*	VimFoldr	<args>
    1              0.000003  com! -nargs=*	VimFoldt	<args>
    1              0.000001 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    1              0.000004 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000002 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    1              0.000002 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    1              0.000002 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Variable options {{{2
    1              0.000002 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
                            else
    1              0.000002  let s:vimsyn_maxlines= 60
    1              0.000001 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000027 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    1              0.000011 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand
    1              0.000003 syn match vimNumber	"\<0[xX]\x\+"
    1              0.000005 syn match vimNumber	"\%(^\|[^a-zA-Z]\)\zs#\x\{6}"
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    1              0.000060 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000010 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000006 syn match vimVar        contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000006 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000010 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000004 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    1              0.000021 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"	matchgroup=vimCommand end="^\.$""
    1              0.000014 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"	matchgroup=vimCommand end="^\.$""
    1              0.000012 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    1              0.000018 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000002 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000003  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000001 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000024 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000003 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000003  syn match   vimFTError  contained	"\I\i*"
    1              0.000001 endif
    1              0.000002 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000003 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000135 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    1              0.000016  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000001 endif
    1              0.000005 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000012  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000001 endif
    1              0.000003 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000018 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    1              0.000009 syn match	vimOper	"\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000005 syn match	vimOper	"||\|&&\|[-+.]"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000010 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    1              0.000016 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000008  syn match	vimOperError	")"
    1              0.000001 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000025 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000099 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIf,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000023 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000003 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    1              0.000010  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    1              0.000001 endif
    1              0.000005 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000005 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000003 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000008 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000008 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000012 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000007 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000007 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000008 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000006 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000006 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000005 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000079 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000004 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000018 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    1              0.000003 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000010 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000016 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000008 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000007 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000006 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000005 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000005 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000005 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000003  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000001 endif
    1              0.000001 syn case ignore
    1              0.000008 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000012 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000010 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000010 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000001 syn case match
    1              0.000003 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000011 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000010 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000003 syn match	vimEnvvar	"\$\I\i*"
    1              0.000003 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000009 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000029 syn match	vimPatSepErr	contained	"\\)"
    1              0.000009 syn match	vimPatSep	contained	"\\|"
    1              0.000022 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    1              0.000018 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000008 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000007 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000008 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ end=+"+	contains=@vimStringGroup
    1              0.000006 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000006 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000007 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    1              0.000013 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    1              0.000010 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000004 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000013 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000010 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000009 syn cluster	vimSubstList	add=vimCollection
    1              0.000017 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    1              0.000007 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000006 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000007 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000010 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000023 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000016 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000014 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000009 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000009 syn match	vimCollClass    contained transparent	"\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000003 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000004 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000012 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000005 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    1              0.000004 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000014 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000009 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000008 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000019 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000010 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    1              0.000007 syn match	vimMarkNumber	"[-+]\d\+"		nextgroup=vimSubst contained contains=vimOper
    1              0.000010 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    1              0.000008 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000005 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000004 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000003 syn match	vimRegister	'@"'
    1              0.000009 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000005 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000006 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000006 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    1              0.000012 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    1              0.000005 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000005 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000053 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    1              0.000026 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1 contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    1              0.000009 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+	contains=vimCtrlChar
    1              0.000009 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    1              0.000013 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    1              0.000012 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    1              0.000026 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    1              0.000030 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000009 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000003 syn match	vimAutoCmdSfxList	contained	"\S*"
    1              0.000007 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    1              0.000028 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000033 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000024 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000002 syn case ignore
    1              0.000002 syn keyword	vimEchoHLNone	none
    1              0.000001 syn case match
                            
                            " Maps {{{2
                            " ====
    1              0.000006 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000027 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000012 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000006 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000012 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000010 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000013 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000005 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000024 syn match	vimMapMod	contained	"\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000013 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000026 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000002 syn case ignore
    1              0.000005 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000001 syn case match
                            
                            " Menus {{{2
                            " =====
    1              0.000029 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000024 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000018 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000006 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000008 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000007 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000009 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000014 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    1              0.000005 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000002 syn case ignore
    1              0.000030 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000013 syn match	vimNotation	"\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000007 syn match	vimNotation	"\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"		contains=vimBracket
    1              0.000008 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1			contains=vimBracket
    1              0.000009 syn match	vimNotation	'\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000012 syn match	vimNotation	"\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000003 syn match	vimBracket contained	"[\\<>]"
    1              0.000001 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000027 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000015 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%([a-zA-Z0-9_]\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    1              0.000007 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000006 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000012  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)[0-9]\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000010  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000013  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000001 endif
                            
                            " Norm {{{2
                            " ====
    1              0.000011 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000003 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    1              0.000017 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000006 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000003 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000010  syn match	vimSynError	contained	"\i\+"
    1              0.000004  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000001 endif
    1              0.000012 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000010 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000010 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000021 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000028 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    1              0.000009 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000020 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000003  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000001 endif
    1              0.000002 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000007 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000012 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000030 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000004 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000022 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000013 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000012 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000010 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000003 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000007 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000011 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000011 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000012 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000009 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000008 syn match	vimSynKeyOpt	contained	"\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000011 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000028 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    1              0.000012 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000007 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000013 syn match	vimSynMtchOpt	contained	"\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000005 if has("conceal")
    1              0.000014  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000003  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000001 endif
    1              0.000011 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000007 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000028 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000023 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000013 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000007 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000013 syn match	vimSynRegOpt	contained	"\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000005 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000021 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000020 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000006 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000008 syn match	vimSynPatMod	contained	"\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000003 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000004 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000006 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000006 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000005 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000012 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000079 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000005 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000003  syn match	vimSyncError	contained	"\i\+"
    1              0.000001 endif
    1              0.000003 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000010 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000005 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000007 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000003 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000010 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000010 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000012 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000012 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000002 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    1              0.000018 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    1              0.000028 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000010  syn match	vimHiCtermError	contained	"[^0-9]\i*"
    1              0.000001 endif
    1              0.000013 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000005 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000006 syn match	vimHiGroup	contained	"\i\+"
    1              0.000002 syn case ignore
    1              0.000011 syn keyword	vimHiAttrib	contained	none bold inverse italic reverse standout underline undercurl
    1              0.000010 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000001 syn case match
    1              0.000010 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000004 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000002 syn case ignore
    1              0.000077 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    1              0.000008 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000001 syn case match
    1              0.000010 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000010 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000010 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000076 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000021 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000004 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000003  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000001 endif
    1              0.000004 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000014 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000006 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000014 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000004 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000004 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000015 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000006 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000004 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000011 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
    1              0.000053 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation,vimOnlyHLGroup,nvimHLGroup
    1              0.000014 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    1              0.000005 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000025 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000024 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000005 syn match	vimContinue	"^\s*\\"
    1              0.000013 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000003 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000017 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000004 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000019 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000017 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000003 if !exists("g:vimsyn_embed")
    1              0.000006  let g:vimsyn_embed= 0
    1              0.000001 endif
                            
                            " [-- lua --] {{{3
    1              0.000014 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000008 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
    1              0.000005 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
                             unlet! b:current_syntax
                             exe "syn include @vimLuaScript ".s:luapath
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+		contains=@vimLuaScript
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
    1              0.000015  syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000007  syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000002 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000009 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000005 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
    1              0.000004 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+	contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                            else
    1              0.000006  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000008 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000005 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
    1              0.000003 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimRubyScript
                             syn region vimRubyRegion matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+		contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                            else
    1              0.000005  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000008 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000005 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    1              0.000003 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(.*\)$+ end=+^\z1$+		contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+		contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                            else
    1              0.000006  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000007  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000010 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    1              0.000002  let s:trytcl= 1
    1              0.000001 endif
    1              0.000001 if s:trytcl
    1              0.000007  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000005  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
    1              0.000003  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
                             else
    1              0.000032   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000006   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001  endif
    1              0.000001  unlet s:tclpath
    1              0.000001 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    1              0.000001 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000009 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000005 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
    1              0.000003 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                            else
    1              0.000006  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000006  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000002 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    1              0.000005 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000003 syn sync linecont	"^\s\+\\"
    1              0.000012 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000003 if !exists("skip_vim_syntax_inits")
    1              0.000002  if !exists("g:vimsyn_noerror")
    1              0.000010   hi def link vimBehaveError	vimError
    1              0.000002   hi def link vimCollClassErr	vimError
    1              0.000003   hi def link vimErrSetting	vimError
    1              0.000007   hi def link vimEmbedError	Normal
    1              0.000003   hi def link vimFTError	vimError
    1              0.000003   hi def link vimFunctionError	vimError
    1              0.000005   hi def link vimFunc         	vimError
    1              0.000002   hi def link vimHiAttribList	vimError
    1              0.000001   hi def link vimHiCtermError	vimError
    1              0.000001   hi def link vimHiKeyError	vimError
    1              0.000007   hi def link vimKeyCodeError	vimError
    1              0.000003   hi def link vimMapModErr	vimError
    1              0.000002   hi def link vimSubstFlagErr	vimError
    1              0.000002   hi def link vimSynCaseError	vimError
    1              0.000008   hi def link vimBufnrWarn	vimWarn
    1              0.000001  endif
                            
    1              0.000007  hi def link vimAbb	vimCommand
    1              0.000005  hi def link vimAddress	vimMark
    1              0.000003  hi def link vimAugroupError	vimError
    1              0.000007  hi def link vimAugroupKey	vimCommand
    1              0.000009  hi def link vimAuHighlight	vimHighlight
    1              0.000008  hi def link vimAutoCmdOpt	vimOption
    1              0.000007  hi def link vimAutoCmd	vimCommand
    1              0.000007  hi def link vimAutoEvent	Type
    1              0.000011  hi def link vimAutoSet	vimCommand
    1              0.000005  hi def link vimBehaveModel	vimBehave
    1              0.000007  hi def link vimBehave	vimCommand
    1              0.000007  hi def link vimBracket	Delimiter
    1              0.000008  hi def link vimCmplxRepeat	SpecialChar
    1              0.000009  hi def link vimCommand	Statement
    1              0.000007  hi def link vimComment	Comment
    1              0.000007  hi def link vimCommentString	vimString
    1              0.000005  hi def link vimCommentTitle	PreProc
    1              0.000011  hi def link vimCondHL	vimCommand
    1              0.000007  hi def link vimContinue	Special
    1              0.000008  hi def link vimCtrlChar	SpecialChar
    1              0.000006  hi def link vimEchoHLNone	vimGroup
    1              0.000006  hi def link vimEchoHL	vimCommand
    1              0.000007  hi def link vimElseIfErr	Error
    1              0.000007  hi def link vimElseif	vimCondHL
    1              0.000007  hi def link vimEnvvar	PreProc
    1              0.000006  hi def link vimError	Error
    1              0.000008  hi def link vimFBVar	vimVar
    1              0.000002  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000013  hi def link vimFold	Folded
    1              0.000007  hi def link vimFTCmd	vimCommand
    1              0.000007  hi def link vimFTOption	vimSynType
    1              0.000006  hi def link vimFuncKey	vimCommand
    1              0.000007  hi def link vimFuncName	Function
    1              0.000007  hi def link vimFuncSID	Special
    1              0.000008  hi def link vimFuncVar	Identifier
    1              0.000008  hi def link vimGroupAdd	vimSynOption
    1              0.000006  hi def link vimGroupName	vimGroup
    1              0.000002  hi def link vimGroupRem	vimSynOption
    1              0.000006  hi def link vimGroupSpecial	Special
    1              0.000010  hi def link vimGroup	Type
    1              0.000006  hi def link vimHiAttrib	PreProc
    1              0.000003  hi def link vimHiClear	vimHighlight
    1              0.000002  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000002  hi def link vimHiCTerm	vimHiTerm
    1              0.000006  hi def link vimHighlight	vimCommand
    1              0.000006  hi def link vimHiGroup	vimGroupName
    1              0.000002  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000002  hi def link vimHiGuiFont	vimHiTerm
    1              0.000003  hi def link vimHiGuiRgb	vimNumber
    1              0.000004  hi def link vimHiGui	vimHiTerm
    1              0.000006  hi def link vimHiNmbr	Number
    1              0.000002  hi def link vimHiStartStop	vimHiTerm
    1              0.000006  hi def link vimHiTerm	Type
    1              0.000007  hi def link vimHLGroup	vimGroup
    1              0.000012  hi def link vimHLMod	PreProc
    1              0.000005  hi def link vimInsert	vimString
    1              0.000007  hi def link vimIskSep	Delimiter
    1              0.000009  hi def link vimKeyCode	vimSpecFile
    1              0.000014  hi def link vimKeyword	Statement
    1              0.000007  hi def link vimLet	vimCommand
    1              0.000005  hi def link vimLineComment	vimComment
    1              0.000006  hi def link vimMapBang	vimCommand
    1              0.000003  hi def link vimMapModKey	vimFuncSID
    1              0.000003  hi def link vimMapMod	vimBracket
    1              0.000007  hi def link vimMap	vimCommand
    1              0.000008  hi def link vimMark	Number
    1              0.000004  hi def link vimMarkNumber	vimNumber
    1              0.000003  hi def link vimMenuMod	vimMapMod
    1              0.000003  hi def link vimMenuNameMore	vimMenuName
    1              0.000006  hi def link vimMenuName	PreProc
    1              0.000003  hi def link vimMtchComment	vimComment
    1              0.000006  hi def link vimNorm	vimCommand
    1              0.000007  hi def link vimNotation	Special
    1              0.000007  hi def link vimNotFunc	vimCommand
    1              0.000004  hi def link vimNotPatSep	vimString
    1              0.000008  hi def link vimNumber	Number
    1              0.000008  hi def link vimOperError	Error
    1              0.000009  hi def link vimOper	Operator
    1              0.000006  hi def link vimOption	PreProc
    1              0.000008  hi def link vimParenSep	Delimiter
    1              0.000004  hi def link vimPatSepErr	vimPatSep
    1              0.000004  hi def link vimPatSepR	vimPatSep
    1              0.000008  hi def link vimPatSep	SpecialChar
    1              0.000004  hi def link vimPatSepZone	vimString
    1              0.000004  hi def link vimPatSepZ	vimPatSep
    1              0.000008  hi def link vimPattern	Type
    1              0.000004  hi def link vimPlainMark	vimMark
    1              0.000004  hi def link vimPlainRegister	vimRegister
    1              0.000008  hi def link vimRegister	SpecialChar
    1              0.000012  hi def link vimScriptDelim	Comment
    1              0.000006  hi def link vimSearchDelim	Statement
    1              0.000003  hi def link vimSearch	vimString
    1              0.000008  hi def link vimSep	Delimiter
    1              0.000003  hi def link vimSetMod	vimOption
    1              0.000006  hi def link vimSetSep	Statement
    1              0.000004  hi def link vimSetString	vimString
    1              0.000008  hi def link vimSpecFile	Identifier
    1              0.000004  hi def link vimSpecFileMod	vimSpecFile
    1              0.000013  hi def link vimSpecial	Type
    1              0.000012  hi def link vimStatement	Statement
    1              0.000004  hi def link vimStringCont	vimString
    1              0.000008  hi def link vimString	String
    1              0.000004  hi def link vimSubst1	vimSubst
    1              0.000008  hi def link vimSubstDelim	Delimiter
    1              0.000007  hi def link vimSubstFlags	Special
    1              0.000008  hi def link vimSubstSubstr	SpecialChar
    1              0.000004  hi def link vimSubstTwoBS	vimString
    1              0.000007  hi def link vimSubst	vimCommand
    1              0.000007  hi def link vimSynCaseError	Error
    1              0.000007  hi def link vimSynCase	Type
    1              0.000007  hi def link vimSyncC	Type
    1              0.000007  hi def link vimSyncError	Error
    1              0.000002  hi def link vimSyncGroupName	vimGroupName
    1              0.000002  hi def link vimSyncGroup	vimGroupName
    1              0.000007  hi def link vimSyncKey	Type
    1              0.000007  hi def link vimSyncNone	Type
    1              0.000002  hi def link vimSynContains	vimSynOption
    1              0.000007  hi def link vimSynError	Error
    1              0.000003  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000002  hi def link vimSynKeyOpt	vimSynOption
    1              0.000002  hi def link vimSynMtchGrp	vimSynOption
    1              0.000005  hi def link vimSynMtchOpt	vimSynOption
    1              0.000003  hi def link vimSynNextgroup	vimSynOption
    1              0.000002  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000005  hi def link vimSynOption	Special
    1              0.000003  hi def link vimSynPatRange	vimString
    1              0.000002  hi def link vimSynRegOpt	vimSynOption
    1              0.000003  hi def link vimSynRegPat	vimString
    1              0.000007  hi def link vimSynReg	Type
    1              0.000007  hi def link vimSyntax	vimCommand
    1              0.000005  hi def link vimSynType	vimSpecial
    1              0.000007  hi def link vimTodo	Todo
    1              0.000004  hi def link vimUnmap	vimMap
    1              0.000007  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000003  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000004  hi def link vimUserAttrbKey	vimOption
    1              0.000002  hi def link vimUserAttrb	vimSpecial
    1              0.000007  hi def link vimUserAttrbError	Error
    1              0.000007  hi def link vimUserCmdError	Error
    1              0.000006  hi def link vimUserCommand	vimCommand
    1              0.000011  hi def link vimUserFunc	Normal
    1              0.000010  hi def link vimVar	Identifier
    1              0.000007  hi def link vimWarn	WarningMsg
                            
    1              0.000003  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000005  hi def link nvimHLGroup	vimHLGroup
    1              0.000004  hi def link nvimMap	vimMap
    1              0.000003  hi def link nvimUnmap	vimUnmap
    1              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000002 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000002 delc VimFolda
    1              0.000002 delc VimFoldf
    1              0.000002 delc VimFoldl
    1              0.000002 delc VimFoldm
    1              0.000002 delc VimFoldp
    1              0.000002 delc VimFoldP
    1              0.000002 delc VimFoldr
    1              0.000002 delc VimFoldt
    1              0.000009 let &cpo = s:keepcpo
    1              0.000001 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/share/nvim/runtime/syntax/vim/generated.vim
Sourced 1 time
Total time:   0.002666
 Self time:   0.002666

count  total (s)   self (s)
    1              0.001690 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] au[tocmd] aug[roup] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cad[dbuffer] cadde[xpr] caddf[ile] cal[l] cat[ch] cb[uffer] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] cnorem[enu] co[py]
    1              0.000078 syn keyword vimCommand contained  col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] do[autocmd] doautoa[ll] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy]
    1              0.000061 syn keyword vimCommand contained  hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] lat[er] lb[uffer] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] map
    1              0.000068 syn keyword vimCommand contained  mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] nb[key] nbc[lose] nbs[tart] ne[w] nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[mptfind] promptr[epl] prof[ile] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r]
    1              0.000072 syn keyword vimCommand contained  redr[aw] redraws[tatus] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind]
    1              0.000076 syn keyword vimCommand contained  t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[ap] tmapc[lear] tme[nu] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmap] tunme[nu] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[verb] wsh[ada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap]
    1              0.000009 syn keyword vimCommand contained  xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    1              0.000031 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari altkeymap akm invaltkeymap noaltkeymap invakm noakm ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh
    1              0.000031 syn keyword vimOption contained  buflisted bl invbuflisted nobuflisted invbl nobl buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb
    1              0.000091 syn keyword vimOption contained  cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic
    1              0.000029 syn keyword vimOption contained  filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol fkmap fk invfkmap nofkmap invfk nofk foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontset gfs guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp
    1              0.000025 syn keyword vimOption contained  hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz
    1              0.000027 syn keyword vimOption contained  linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu
    1              0.000024 syn keyword vimOption contained  opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumheight ph quoteescape qe readonly ro invreadonly noreadonly invro noro redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru
    1              0.000030 syn keyword vimOption contained  rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl
    1              0.000039 syn keyword vimOption contained  smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi
    1              0.000026 syn keyword vimOption contained  termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak
    1              0.000014 syn keyword vimOption contained  winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    1              0.000003 syn case ignore
                            
    1              0.000075 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanOpen ChanInfo CmdLineEnter CmdLineLeave CmdUndefined CmdWinEnter CmdWinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave JobActivity MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost
    1              0.000014 syn keyword vimAutoEvent contained  ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinNew WinEnter WinLeave BufWrite FileEncoding BufCreate BufRead
                            
    1              0.000007 syn keyword nvimAutoEvent contained  TabNewEntered TabClosed TabNew TermOpen TermClose DirChanged
                            
    1              0.000002 syn case match
                            
    1              0.000020 syn keyword vimFuncName contained  ceil nvim_win_get_position lispindent nvim_buf_line_count strftime sinh nvim_tabpage_get_win inputdialog shellescape settabwinvar tagfiles append getwinposx msgpackparse nvim_buf_get_commands tabpagewinnr jobclose nvim_set_current_tabpage map settabvar nvim_buf_get_changedtick inputlist has_key resolve inputsave strcharpart libcallnr nvim_win_set_cursor range sqrt setbufvar winheight acos gettabvar getcmdline setwinvar assert_match nvim_get_proc_children float2nr expand setline delete round nvim_get_color_by_name dictwatcherdel funcref win_findbuf nvim__id_float rpcstop hasmapto nvim_win_set_height atan2 nvim_feedkeys indent reverse timer_stopall screenchar setcharsearch nvim_win_get_width nvim_win_set_var jobpid nvim_get_current_tabpage asin nvim_get_hl_by_name sort getftype garbagecollect diff_filler nvim_tabpage_get_var
    1              0.000022 syn keyword vimFuncName contained  char2nr msgpackdump maparg foreground setfperm py3eval str2nr strridx invert foldclosedend pumvisible getcompletion extend serverstop min fmod nextnonblank nvim__id_array assert_fails nvim_set_current_dir sin bufloaded stdpath setloclist nvim_win_get_option atan changenr nvim_get_var nvim_win_get_height nvim_list_tabpages line2byte nvim_get_current_win byteidxcomp gettabinfo assert_inrange timer_start inputrestore nvim_list_runtime_paths nvim_buf_set_var getbufinfo getloclist nvim_call_dict_function virtcol writefile glob2regpat nvim_get_current_line nvim_input feedkeys serverlist nvim_set_var getbufline islocked screenrow winwidth shiftwidth abs getwininfo reltimefloat cosh nvim_tabpage_is_valid nvim_set_option pyeval getfsize argc exp nvim_buf_add_highlight json_encode getwinposy nvim_strwidth nvim_replace_termcodes
    1              0.000024 syn keyword vimFuncName contained  buffer_number nvim_command_output getregtype setreg nvim_del_var nvim_buf_del_var strtrans rpcrequest glob buffer_exists histadd timer_stop matchstr jobstart sockconnect match inputsecret rename split escape getcmdpos readfile screenattr hlID mkdir log10 getline getwinvar globpath getcmdtype iconv matcharg nvim_win_get_number clearmatches searchpos buflisted matchstrpos assert_equal nvim_list_uis haslocaldir nvim_win_get_var getcurpos nvim__stats complete matchaddpos join histnr bufwinid call getqflist copy strchars screencol nvim_command winnr finddir jobresize nvim_buf_set_lines nvim_buf_get_number strpart bufnr eval localtime searchpair setcmdpos strlen repeat nvim_win_del_var index browse highlight_exists filereadable assert_notmatch nvim_get_chan_info cursor gettabwinvar empty bufexists insert nvim_buf_get_name
    1              0.000021 syn keyword vimFuncName contained  execute matchadd or matchdelete foldlevel hostname rpcnotify getchar undofile synIDattr getmatches reltimestr count strgetchar xor nvim_eval highlightID tabpagebuflist getcharsearch assert_exception winline getpid winsaveview nvim_list_chans searchpairpos winrestview system winbufnr file_readable foldclosed simplify filewritable isdirectory nvim_win_is_valid getcharmod function matchlist json_decode pathshorten pow exepath reltime type trunc printf menu_get nvim_buf_set_name jobstop foldtext nvim_win_set_option assert_true searchdecl col cos timer_pause nvim_call_function cindent foldtextresult mode rpcstart bufwinnr keys sha256 dictwatcheradd chansend toupper win_id2win byteidx wordcount getftime nvim_win_set_width diff_hlID libcall remove bufname tanh nr2char argv get tempname jobsend and complete_check
    1              0.000024 syn keyword vimFuncName contained  assert_false synIDtrans win_id2tabwin synID line hlexists substitute tolower mapcheck nvim_get_commands getcwd setpos fnameescape stdioopen spellbadword strwidth strdisplaywidth soundfold nvim_win_get_cursor search histget wildmenumode stridx spellsuggest nvim_get_option nvim_get_color_map undotree nvim_list_bufs input exists complete_add did_filetype eventhandler items jobwait prevnonblank browsedir buffer_name synconcealed win_gotoid tabpagenr taglist nvim_buf_get_mark getfperm nvim_buf_get_var nvim_tabpage_list_wins wincol test_garbagecollect_now test_write_list_log arglistid setmatches matchend filter fnamemodify visualmode string tr executable uniq values findfile win_getid nvim_get_keymap tan nvim__id_dictionary nvim_buf_set_option nvim_out_write nvim_get_hl_by_id nvim_del_current_line timer_info setqflist
    1              0.000017 syn keyword vimFuncName contained  serverstart nvim_buf_clear_highlight nvim__id nvim_set_current_line chanclose assert_report getreg synstack api_info nvim_set_current_win nvim_list_wins nvim_set_current_buf nvim_buf_get_keymap nvim_get_current_buf str2float byte2line confirm nvim_get_mode nvim_get_proc submatch nvim_win_get_buf nvim_buf_is_valid nvim_err_writeln nvim_err_write id log nvim_win_get_tabpage cscope_connection luaeval len getcmdwintype argidx assert_notequal winrestcmd add floor getpos max getfontname nvim_tabpage_get_number nvim_tabpage_del_var nvim_tabpage_set_var termopen nvim_parse_expression getbufvar systemlist nvim_get_vvar last_buffer_nr nvim_buf_get_option deepcopy has nvim_buf_get_lines histdel

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim
Sourced 1 time
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 let s:loaded_ext = []
    1              0.000004 let s:ext = {}
    1              0.000002 let s:ext._theme_funcrefs = []
                            
    1              0.000003 function! s:ext.add_statusline_func(name) dict
                              call airline#add_statusline_func(a:name)
                            endfunction
    1              0.000001 function! s:ext.add_statusline_funcref(function) dict
                              call airline#add_statusline_funcref(a:function)
                            endfunction
    1              0.000001 function! s:ext.add_inactive_statusline_func(name) dict
                              call airline#add_inactive_statusline_func(a:name)
                            endfunction
    1              0.000001 function! s:ext.add_theme_func(name) dict
                              call add(self._theme_funcrefs, function(a:name))
                            endfunction
                            
    1              0.000022 let s:script_path = tolower(resolve(expand('<sfile>:p:h')))
                            
    1              0.000013 let s:filetype_overrides = {
                                  \ 'nerdtree': [ get(g:, 'NERDTreeStatusline', 'NERD'), '' ],
                                  \ 'gundo': [ 'Gundo', '' ],
                                  \ 'vimfiler': [ 'vimfiler', '%{vimfiler#get_status_string()}' ],
                                  \ 'minibufexpl': [ 'MiniBufExplorer', '' ],
                                  \ 'startify': [ 'startify', '' ],
                                  \ 'vim-plug': [ 'Plugins', '' ],
                                  \ }
                            
    1              0.000002 let s:filetype_regex_overrides = {}
                            
    1              0.000002 function! s:check_defined_section(name)
                              if !exists('w:airline_section_{a:name}')
                                let w:airline_section_{a:name} = g:airline_section_{a:name}
                              endif
                            endfunction
                            
    1              0.000003 function! airline#extensions#append_to_section(name, value)
                              call <sid>check_defined_section(a:name)
                              let w:airline_section_{a:name} .= a:value
                            endfunction
                            
    1              0.000002 function! airline#extensions#prepend_to_section(name, value)
                              call <sid>check_defined_section(a:name)
                              let w:airline_section_{a:name} = a:value . w:airline_section_{a:name}
                            endfunction
                            
    1              0.000002 function! airline#extensions#apply_left_override(section1, section2)
                              let w:airline_section_a = a:section1
                              let w:airline_section_b = a:section2
                              let w:airline_section_c = airline#section#create(['readonly'])
                              let w:airline_render_left = 1
                              let w:airline_render_right = 0
                            endfunction
                            
    1              0.000002 function! airline#extensions#apply(...)
                            
                              if s:is_excluded_window()
                                return -1
                              endif
                            
                              if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
                              if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                              endif
                            
                              if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
                              if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
                              for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! s:is_excluded_window()
                              for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
                              for matchw in g:airline_exclude_filenames
                                if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
                              endfor
                            
                              if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000002 function! airline#extensions#load_theme()
                              call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)
                            endfunction
                            
    1              0.000002 function! airline#extensions#load()
                              let s:loaded_ext = []
                            
                              if exists('g:airline_extensions')
                                for ext in g:airline_extensions
                                  try
                                    call airline#extensions#{ext}#init(s:ext)
                                  catch /^Vim\%((\a\+)\)\=:E117/	" E117, function does not exist
                                    call airline#util#warning("Extension '".ext."' not installed, ignoring!")
                                  endtry
                                endfor
                                return
                              endif
                            
                              call airline#extensions#quickfix#init(s:ext)
                              call add(s:loaded_ext, 'quickfix')
                            
                              if get(g:, 'loaded_unite', 0)
                                call airline#extensions#unite#init(s:ext)
                                call add(s:loaded_ext, 'unite')
                              endif
                            
                              if get(g:, 'loaded_denite', 0)
                                call airline#extensions#denite#init(s:ext)
                                call add(s:loaded_ext, 'denite')
                              endif
                            
                              if exists(':NetrwSettings')
                                call airline#extensions#netrw#init(s:ext)
                                call add(s:loaded_ext, 'netrw')
                              endif
                            
                              if has("terminal") || has('nvim')
                                call airline#extensions#term#init(s:ext)
                                call add(s:loaded_ext, 'term')
                              endif
                            
                              if get(g:, 'airline#extensions#ycm#enabled', 0)
                                call airline#extensions#ycm#init(s:ext)
                                call add(s:loaded_ext, 'ycm')
                              endif
                            
                              if get(g:, 'loaded_vimfiler', 0)
                                let g:vimfiler_force_overwrite_statusline = 0
                              endif
                            
                              if get(g:, 'loaded_ctrlp', 0)
                                call airline#extensions#ctrlp#init(s:ext)
                                call add(s:loaded_ext, 'ctrlp')
                              endif
                            
                              if get(g:, 'loaded_localsearch', 0)
                                call airline#extensions#localsearch#init(s:ext)
                                call add(s:loaded_ext, 'localsearch')
                              endif
                            
                              if get(g:, 'CtrlSpaceLoaded', 0)
                                call airline#extensions#ctrlspace#init(s:ext)
                                call add(s:loaded_ext, 'ctrlspace')
                              endif
                            
                              if get(g:, 'command_t_loaded', 0)
                                call airline#extensions#commandt#init(s:ext)
                                call add(s:loaded_ext, 'commandt')
                              endif
                            
                              if exists(':UndotreeToggle')
                                call airline#extensions#undotree#init(s:ext)
                                call add(s:loaded_ext, 'undotree')
                              endif
                            
                              if get(g:, 'airline#extensions#hunks#enabled', 1)
                                    \ && (exists('g:loaded_signify') || exists('g:loaded_gitgutter') || exists('g:loaded_changes') || exists('g:loaded_quickfixsigns'))
                                call airline#extensions#hunks#init(s:ext)
                                call add(s:loaded_ext, 'hunks')
                              endif
                            
                              if get(g:, 'airline#extensions#vimagit#enabled', 1)
                                    \ && (exists('g:loaded_magit'))
                                call airline#extensions#vimagit#init(s:ext)
                                call add(s:loaded_ext, 'vimagit')
                              endif
                            
                              if get(g:, 'airline#extensions#tagbar#enabled', 1)
                                    \ && exists(':TagbarToggle')
                                call airline#extensions#tagbar#init(s:ext)
                                call add(s:loaded_ext, 'tagbar')
                              endif
                            
                              if get(g:, 'airline#extensions#csv#enabled', 1)
                                    \ && (get(g:, 'loaded_csv', 0) || exists(':Table'))
                                call airline#extensions#csv#init(s:ext)
                                call add(s:loaded_ext, 'csv')
                              endif
                            
                              if exists(':VimShell')
                                let s:filetype_overrides['vimshell'] = ['vimshell','%{vimshell#get_status_string()}']
                                let s:filetype_regex_overrides['^int-'] = ['vimshell','%{substitute(&ft, "int-", "", "")}']
                              endif
                            
                              if get(g:, 'airline#extensions#branch#enabled', 1) && (
                                      \ airline#util#has_fugitive() ||
                                      \ airline#util#has_lawrencium() ||
                                      \ airline#util#has_vcscommand() ||
                                      \ airline#util#has_custom_scm())
                                call airline#extensions#branch#init(s:ext)
                                call add(s:loaded_ext, 'branch')
                              endif
                            
                              if get(g:, 'airline#extensions#bufferline#enabled', 1)
                                    \ && exists('*bufferline#get_status_string')
                                call airline#extensions#bufferline#init(s:ext)
                                call add(s:loaded_ext, 'bufferline')
                              endif
                            
                              if get(g:, 'airline#extensions#fugitiveline#enabled', 1)
                                    \ && airline#util#has_fugitive()
                                    \ && index(s:loaded_ext, 'bufferline') == -1
                                call airline#extensions#fugitiveline#init(s:ext)
                                call add(s:loaded_ext, 'fugitiveline')
                              endif
                            
                              if (get(g:, 'airline#extensions#virtualenv#enabled', 1) && (exists(':VirtualEnvList') || isdirectory($VIRTUAL_ENV)))
                                call airline#extensions#virtualenv#init(s:ext)
                                call add(s:loaded_ext, 'virtualenv')
                              endif
                            
                              if (get(g:, 'airline#extensions#eclim#enabled', 1) && exists(':ProjectCreate'))
                                call airline#extensions#eclim#init(s:ext)
                                call add(s:loaded_ext, 'eclim')
                              endif
                            
                              if get(g:, 'airline#extensions#syntastic#enabled', 1)
                                    \ && exists(':SyntasticCheck')
                                call airline#extensions#syntastic#init(s:ext)
                                call add(s:loaded_ext, 'syntastic')
                              endif
                            
                              if (get(g:, 'airline#extensions#ale#enabled', 1) && exists(':ALELint'))
                                call airline#extensions#ale#init(s:ext)
                                call add(s:loaded_ext, 'ale')
                              endif
                            
                              if (get(g:, 'airline#extensions#languageclient#enabled', 1) && exists(':LanguageClientStart'))
                                call airline#extensions#languageclient#init(s:ext)
                                call add(s:loaded_ext, 'languageclient')
                              endif
                            
                              if get(g:, 'airline#extensions#whitespace#enabled', 1)
                                call airline#extensions#whitespace#init(s:ext)
                                call add(s:loaded_ext, 'whitespace')
                              endif
                            
                              if (get(g:, 'airline#extensions#neomake#enabled', 1) && exists(':Neomake'))
                                call airline#extensions#neomake#init(s:ext)
                                call add(s:loaded_ext, 'neomake')
                              endif
                            
                              if get(g:, 'airline#extensions#po#enabled', 1) && executable('msgfmt')
                                call airline#extensions#po#init(s:ext)
                                call add(s:loaded_ext, 'po')
                              endif
                            
                              if get(g:, 'airline#extensions#wordcount#enabled', 1)
                                call airline#extensions#wordcount#init(s:ext)
                                call add(s:loaded_ext, 'wordcount')
                              endif
                            
                              if get(g:, 'airline#extensions#tabline#enabled', 0)
                                call airline#extensions#tabline#init(s:ext)
                                call add(s:loaded_ext, 'tabline')
                              endif
                            
                              if get(g:, 'airline#extensions#tmuxline#enabled', 1) && exists(':Tmuxline')
                                call airline#extensions#tmuxline#init(s:ext)
                                call add(s:loaded_ext, 'tmuxline')
                              endif
                            
                              if get(g:, 'airline#extensions#promptline#enabled', 1) && exists(':PromptlineSnapshot') && len(get(g:, 'airline#extensions#promptline#snapshot_file', ''))
                                call airline#extensions#promptline#init(s:ext)
                                call add(s:loaded_ext, 'promptline')
                              endif
                            
                              if get(g:, 'airline#extensions#nrrwrgn#enabled', 1) && exists(':NR') == 2
                                  call airline#extensions#nrrwrgn#init(s:ext)
                                call add(s:loaded_ext, 'nrrwrgn')
                              endif
                            
                              if get(g:, 'airline#extensions#unicode#enabled', 1) && exists(':UnicodeTable') == 2
                                  call airline#extensions#unicode#init(s:ext)
                                call add(s:loaded_ext, 'unicode')
                              endif
                            
                              if (get(g:, 'airline#extensions#capslock#enabled', 1) && exists('*CapsLockStatusline'))
                                call airline#extensions#capslock#init(s:ext)
                                call add(s:loaded_ext, 'capslock')
                              endif
                            
                              if (get(g:, 'airline#extensions#gutentags#enabled', 1) && get(g:, 'loaded_gutentags', 0))
                                call airline#extensions#gutentags#init(s:ext)
                                call add(s:loaded_ext, 'gutentags')
                              endif
                            
                              if (get(g:, 'airline#extensions#grepper#enabled', 1) && get(g:, 'loaded_grepper', 0))
                                call airline#extensions#grepper#init(s:ext)
                                call add(s:loaded_ext, 'grepper')
                              endif
                            
                              if (get(g:, 'airline#extensions#xkblayout#enabled', 1) && exists('g:XkbSwitchLib'))
                                call airline#extensions#xkblayout#init(s:ext)
                                call add(s:loaded_ext, 'xkblayout')
                              endif
                            
                              if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
                                call airline#extensions#keymap#init(s:ext)
                                call add(s:loaded_ext, 'keymap')
                              endif
                            
                              if (get(g:, 'airline#extensions#windowswap#enabled', 1) && get(g:, 'loaded_windowswap', 0))
                                call airline#extensions#windowswap#init(s:ext)
                                call add(s:loaded_ext, 'windowswap')
                              endif
                            
                              if (get(g:, 'airline#extensions#obsession#enabled', 1) && exists('*ObsessionStatus'))
                                call airline#extensions#obsession#init(s:ext)
                                call add(s:loaded_ext, 'obsession')
                              endif
                            
                              if get(g:, 'airline#extensions#vimtex#enabled', 1)
                                runtime autoload/vimtex.vim
                                if exists('*vimtex#init')
                                  call airline#extensions#vimtex#init(s:ext)
                                  call add(s:loaded_ext, 'vimtex')
                                endif
                              endif
                            
                              if (get(g:, 'airline#extensions#cursormode#enabled', 0))
                                call airline#extensions#cursormode#init(s:ext)
                                call add(s:loaded_ext, 'cursormode')
                              endif
                            
                              if !get(g:, 'airline#extensions#disable_rtp_load', 0)
                                " load all other extensions, which are not part of the default distribution.
                                " (autoload/airline/extensions/*.vim outside of our s:script_path).
                                for file in split(globpath(&rtp, "autoload/airline/extensions/*.vim"), "\n")
                                  " we have to check both resolved and unresolved paths, since it's possible
                                  " that they might not get resolved properly (see #187)
                                  if stridx(tolower(resolve(fnamemodify(file, ':p'))), s:script_path) < 0
                                        \ && stridx(tolower(fnamemodify(file, ':p')), s:script_path) < 0
                                    let name = fnamemodify(file, ':t:r')
                                    if !get(g:, 'airline#extensions#'.name.'#enabled', 1) ||
                                        \ index(s:loaded_ext, name) > -1
                                      continue
                                    endif
                                    try
                                      call airline#extensions#{name}#init(s:ext)
                                    catch
                                    endtry
                                  endif
                                endfor
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#get_loaded_extensions()
                              return s:loaded_ext
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim
Sourced 1 time
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000004 if !exists('g:airline#extensions#quickfix#quickfix_text')
    1              0.000037   let g:airline#extensions#quickfix#quickfix_text = 'Quickfix'
    1              0.000008 endif
                            
    1              0.000004 if !exists('g:airline#extensions#quickfix#location_text')
    1              0.000006   let g:airline#extensions#quickfix#location_text = 'Location'
    1              0.000001 endif
                            
    1              0.000002 function! airline#extensions#quickfix#apply(...)
                              if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#quickfix#init(ext)
                              call a:ext.add_statusline_func('airline#extensions#quickfix#apply')
                              call a:ext.add_inactive_statusline_func('airline#extensions#quickfix#inactive_qf_window')
                            endfunction
                            
    1              0.000002 function! airline#extensions#quickfix#inactive_qf_window(...)
                              if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#quickfix#get_type()
                              if exists("*win_getid") && exists("*getwininfo")
                                let dict = getwininfo(win_getid())
                                if len(dict) > 0 && get(dict[0], 'quickfix', 0) && !get(dict[0], 'loclist', 0)
                                  return g:airline#extensions#quickfix#quickfix_text
                                elseif len(dict) > 0 && get(dict[0], 'quickfix', 0) && get(dict[0], 'loclist', 0)
                                  return g:airline#extensions#quickfix#location_text
                                endif
                              endif
                              redir => buffers
                              silent ls
                              redir END
                            
                              let nr = bufnr('%')
                              for buf in split(buffers, '\n')
                                if match(buf, '\v^\s*'.nr) > -1
                                  if match(buf, '\cQuickfix') > -1
                                    return g:airline#extensions#quickfix#quickfix_text
                                  else
                                    return g:airline#extensions#quickfix#location_text
                                  endif
                                endif
                              endfor
                              return ''
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/netrw.vim
Sourced 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000004 if !exists(':NetrwSettings')
                              finish
                            endif
                            
    1              0.000002 function! airline#extensions#netrw#apply(...)
                              if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#netrw#init(ext)
                              let g:netrw_force_overwrite_statusline = 0
                              call a:ext.add_statusline_func('airline#extensions#netrw#apply')
                            endfunction
                            
                            
    1              0.000002 function! airline#extensions#netrw#sortstring()
                              let order = (get(g:, 'netrw_sort_direction', 'n') =~ 'n') ? '+' : '-'
                              return g:netrw_sort_by . (g:airline_symbols.space) . '[' . order . ']'
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 function! airline#extensions#term#apply(...)
                              if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#term#inactive_apply(...)
                              if getbufvar(a:2.bufnr, '&buftype') == 'terminal'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', spc.'%f')
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! s:termname()
                              let bufname = bufname('%')
                              if has('nvim')
                                return matchstr(bufname, 'term.*:\zs.*')
                              else
                                " get rid of leading '!'
                                return bufname[1:]
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#term#init(ext)
                              call a:ext.add_statusline_func('airline#extensions#term#apply')
                              call a:ext.add_inactive_statusline_func('airline#extensions#term#inactive_apply')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim
Sourced 1 time
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000006 if !get(g:, 'loaded_signify', 0) && !get(g:, 'loaded_gitgutter', 0) && !get(g:, 'loaded_changes', 0) && !get(g:, 'loaded_quickfixsigns', 0)
                              finish
                            endif
                            
    1              0.000003 let s:non_zero_only = get(g:, 'airline#extensions#hunks#non_zero_only', 0)
    1              0.000004 let s:hunk_symbols = get(g:, 'airline#extensions#hunks#hunk_symbols', ['+', '~', '-'])
                            
    1              0.000002 function! s:get_hunks_signify()
                              let hunks = sy#repo#get_stats()
                              if hunks[0] >= 0
                                return hunks
                              endif
                              return []
                            endfunction
                            
    1              0.000001 function! s:is_branch_empty()
                              return exists('*airline#extensions#branch#head') &&
                                    \ empty(get(b:, 'airline_head', ''))
                            endfunction
                            
    1              0.000001 function! s:get_hunks_gitgutter()
                              if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
                              return GitGutterGetHunkSummary()
                            endfunction
                            
    1              0.000001 function! s:get_hunks_changes()
                              if !get(b:, 'changes_view_enabled', 0) || s:is_branch_empty()
                                return []
                              endif
                              let hunks = changes#GetStats()
                              return hunks == [0, 0, 0] ? [] : hunks
                            endfunction
                            
    1              0.000001 function! s:get_hunks_empty()
                              return ''
                            endfunction
                            
    1              0.000001 function! s:get_hunks()
                              if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
                              return {b:source_func}()
                            endfunction
                            
    1              0.000002 function! airline#extensions#hunks#get_hunks()
                              if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
                              if exists("b:airline_hunks") &&
                                \ get(b:,  'airline_changenr', 0) == b:changedtick &&
                                \ winwidth(0) == get(s:, 'airline_winwidth', 0) &&
                                \ get(b:, 'source_func', '') isnot# 's:get_hunks_signify' &&
                                \ get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' &&
                                \ get(b:, 'source_func', '') isnot# 's:get_hunks_empty' &&
                                \ get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
                              let hunks = s:get_hunks()
                              let string = ''
                              if !empty(hunks)
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
                              endif
                              let b:airline_hunks = string
                              let b:airline_changenr = b:changedtick
                              let s:airline_winwidth = winwidth(0)
                              return string
                            endfunction
                            
    1              0.000002 function! airline#extensions#hunks#init(ext)
                              call airline#parts#define_function('hunks', 'airline#extensions#hunks#get_hunks')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/ale.vim
Sourced 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bjorn Neergaard, w0rp et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 function! s:airline_ale_count(cnt, symbol)
                              return a:cnt ? a:symbol. a:cnt : ''
                            endfunction
                            
    1              0.000002 function! s:airline_ale_get_line_number(cnt, type) abort
                              if a:cnt == 0
                                return ''
                              endif
                            
                              let buffer       = bufnr('')
                              let problem_type = (a:type ==# 'error') ? 'E' : 'W'
                              let problems     = copy(ale#engine#GetLoclist(buffer))
                            
                              call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
                              if empty(problems)
                                return ''
                              endif
                            
                              let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . problems[0].lnum . close_lnum_symbol
                            endfunction
                            
    1              0.000002 function! airline#extensions#ale#get(type)
                              if !exists(':ALELint')
                                return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
                              let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
                              let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
                              let is_err = a:type ==# 'error'
                            
                              if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
                              endif
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              let counts = ale#statusline#Count(bufnr(''))
                              if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
                                let errors = counts.error + counts.style_error
                                let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
                              if show_line_numbers == 1
                                return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#ale#get_warning()
                              return airline#extensions#ale#get('warning')
                            endfunction
                            
    1              0.000002 function! airline#extensions#ale#get_error()
                              return airline#extensions#ale#get('error')
                            endfunction
                            
    1              0.000002 function! airline#extensions#ale#init(ext)
                              call airline#parts#define_function('ale_error_count', 'airline#extensions#ale#get_error')
                              call airline#parts#define_function('ale_warning_count', 'airline#extensions#ale#get_warning')
                              augroup airline_ale
                                autocmd!
                                autocmd CursorHold,BufWritePost * call <sid>ale_refresh()
                                autocmd User ALEJobStarted,ALELintPost call <sid>ale_refresh()
                              augroup END
                            endfunction
                            
    1              0.000001 function! s:ale_refresh()
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim
Sourced 1 time
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
                            " http://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000004 let s:show_message = get(g:, 'airline#extensions#whitespace#show_message', 1)
    1              0.000004 let s:symbol = get(g:, 'airline#extensions#whitespace#symbol', g:airline_symbols.whitespace)
    1              0.000003 let s:default_checks = ['indent', 'trailing', 'mixed-indent-file']
                            
    1              0.000003 let s:enabled = get(g:, 'airline#extensions#whitespace#enabled', 1)
    1              0.000003 let s:skip_check_ft = {'make': ['indent', 'mixed-indent-file']}
                            
    1              0.000002 function! s:check_mixed_indent()
                              let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
                              if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
                                return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif
                            endfunction
                            
    1              0.000001 function! s:check_mixed_indent_file()
                              let c_like_langs = get(g:, 'airline#extensions#c_like_langs',
                                    \ [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
                              if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
                                let head_spc = '\v(^ +)'
                              endif
                              let indent_tabs = search('\v(^\t+)', 'nw')
                              let indent_spc  = search(head_spc, 'nw')
                              if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#whitespace#check()
                              let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
                              if &readonly || !&modifiable || !s:enabled || line('$') > max_lines
                                      \ || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                              let skip_check_ft = extend(s:skip_check_ft,
                                    \ get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
                              if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
                              endif
                              return airline#util#shorten(b:airline_whitespace_check, 120, 9)
                            endfunction
                            
    1              0.000002 function! airline#extensions#whitespace#toggle()
                              if s:enabled
                                augroup airline_whitespace
                                  autocmd!
                                augroup END
                                augroup! airline_whitespace
                                let s:enabled = 0
                              else
                                call airline#extensions#whitespace#init()
                                let s:enabled = 1
                              endif
                            
                              if exists("g:airline#extensions#whitespace#enabled")
                                let g:airline#extensions#whitespace#enabled = s:enabled
                                if s:enabled && match(g:airline_section_warning, '#whitespace#check') < 0
                                  let g:airline_section_warning .= airline#section#create(['whitespace'])
                                  call airline#update_statusline()
                                endif
                              endif
                              call airline#util#warning(printf('Whitespace checking: %s',(s:enabled ? 'Enabled' : 'Disabled')))
                            endfunction
                            
    1              0.000002 function! airline#extensions#whitespace#disable()
                              if s:enabled
                                call airline#extensions#whitespace#toggle()
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#whitespace#init(...)
                              call airline#parts#define_function('whitespace', 'airline#extensions#whitespace#check')
                            
                              unlet! b:airline_whitespace_check
                              augroup airline_whitespace
                                autocmd!
                                autocmd CursorHold,BufWritePost * call <sid>ws_refresh()
                              augroup END
                            endfunction
                            
    1              0.000001 function! s:ws_refresh()
                              if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
                              let b:airline_ws_changedtick = b:changedtick
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/po.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 function! airline#extensions#po#shorten()
                              " Format and shorte the output of msgfmt
                              let b:airline_po_stats = substitute(get(b:, 'airline_po_stats', ''), ' \(message\|translation\)s*\.*', '', 'g')
                              let b:airline_po_stats = substitute(b:airline_po_stats, ', ', '/', 'g')
                              if exists("g:airline#extensions#po#displayed_limit")
                                let w:displayed_po_limit = g:airline#extensions#po#displayed_limit
                                if len(b:airline_po_stats) > w:displayed_po_limit - 1
                                  let b:airline_po_stats = b:airline_po_stats[0:(w:displayed_po_limit - 2)].(&encoding==?'utf-8' ? '…' : '.'). ']'
                                endif
                              endif
                              if strlen(get(b:, 'airline_po_stats', '')) >= 30 && winwidth(0) < 150
                                let fuzzy = ''
                                let untranslated = ''
                                let messages = ''
                                " Shorten [120 translated, 50 fuzzy, 4 untranslated] to [120T/50F/4U]
                                if b:airline_po_stats =~ 'fuzzy'
                                  let fuzzy = substitute(b:airline_po_stats, '.*\(\d\+\) fuzzy.*', '\1F', '')
                                endif
                                if b:airline_po_stats =~ 'untranslated'
                                  let untranslated = substitute(b:airline_po_stats, '.*\(\d\+\) untranslated.*', '\1U', '')
                                endif
                                let messages = substitute(b:airline_po_stats, '\(\d\+\) translated.*', '\1T', '')
                                let b:airline_po_stats = printf('%s%s%s', fuzzy, (empty(fuzzy) || empty(untranslated) ? '' : '/'), untranslated)
                                if strlen(b:airline_po_stats) < 8
                                  let b:airline_po_stats = messages. (!empty(b:airline_po_stats) ? '/':''). b:airline_po_stats
                                endif
                              endif
                              let b:airline_po_stats = '['.b:airline_po_stats. ']'
                            endfunction
                            
    1              0.000002 function! airline#extensions#po#on_winenter()
                              " only reset cache, if the window size changed
                              if get(b:, 'airline_winwidth', 0) != winwidth(0)
                                let b:airline_winwidth = winwidth(0)
                                " needs re-formatting
                                unlet! b:airline_po_stats
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#po#apply(...)
                              if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#po#stats()
                              if exists('b:airline_po_stats') && !empty(b:airline_po_stats)
                                return b:airline_po_stats
                              endif
                            
                              let cmd = 'msgfmt --statistics -o /dev/null -- '
                              if g:airline#init#vim_async
                                call airline#async#get_msgfmt_stat(cmd, expand('%:p'))
                              elseif has("nvim")
                                call airline#async#nvim_get_msgfmt_stat(cmd, expand('%:p'))
                              else
                                let airline_po_stats = system(cmd. shellescape(expand('%:p')))
                                if v:shell_error
                                  return ''
                                endif
                                try
                                  let b:airline_po_stats = split(airline_po_stats, '\n')[0]
                                catch
                                  let b:airline_po_stats = ''
                                endtry
                                call airline#extensions#po#shorten()
                              endif
                              return get(b:, 'airline_po_stats', '')
                            endfunction
                            
    1              0.000002 function! airline#extensions#po#init(ext)
                                call a:ext.add_statusline_func('airline#extensions#po#apply')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim
Sourced 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2 fdm=marker
                            
    1              0.000002 scriptencoding utf-8
                            
                            " get wordcount {{{1
    1              0.000003 if exists('*wordcount')
    1              0.000002   function! s:get_wordcount(visual_mode_active)
                                let query = a:visual_mode_active ? 'visual_words' : 'words'
                                return get(wordcount(), query, 0)
                              endfunction
    1              0.000002 else  " Pull wordcount from the g_ctrl-g stats
                              function! s:get_wordcount(visual_mode_active)
                                let pattern = a:visual_mode_active
                                      \ ? '^.\D*\d\+\D\+\d\+\D\+\zs\d\+'
                                      \ : '^.\D*\%(\d\+\D\+\)\{5}\zs\d\+'
                            
                                let save_status = v:statusmsg
                                if !a:visual_mode_active && col('.') == col('$')
                                  let save_pos = getpos('.')
                                  execute "silent normal! g\<c-g>"
                                  call setpos('.', save_pos)
                                else
                                  execute "silent normal! g\<c-g>"
                                endif
                                let stats = v:statusmsg
                                let v:statusmsg = save_status
                            
                                return str2nr(matchstr(stats, pattern))
                              endfunction
                            endif
                            
                            " format {{{1
    1              0.000004 let s:formatter = get(g:, 'airline#extensions#wordcount#formatter', 'default')
                            
                            " wrapper function for compatibility; redefined below for old-style formatters
    1              0.000002 function! s:format_wordcount(wordcount)
                              return airline#extensions#wordcount#formatters#{s:formatter}#to_string(a:wordcount)
                            endfunction
                            
                            " check user-defined formatter exists with appropriate functions, otherwise
                            " fall back to default
    1              0.000002 if s:formatter !=# 'default'
                              execute 'runtime! autoload/airline/extensions/wordcount/formatters/'.s:formatter
                              if !exists('*airline#extensions#wordcount#formatters#{s:formatter}#to_string')
                                if !exists('*airline#extensions#wordcount#formatters#{s:formatter}#format')
                                  let s:formatter = 'default'
                                else
                                  " redefine for backwords compatibility
                                  function! s:format_wordcount(_)
                                    if mode() ==? 'v'
                                      return b:airline_wordcount
                                    else
                                      return airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    endif
                                  endfunction
                                endif
                              endif
                            endif
                            
                            " update {{{1
    1              0.000002 let s:wordcount_cache = 0  " cache wordcount for performance when force_update=0
    1              0.000002 function! s:update_wordcount(force_update)
                              let wordcount = s:get_wordcount(0)
                              if wordcount != s:wordcount_cache || a:force_update
                                let s:wordcount_cache = wordcount
                                let b:airline_wordcount =  s:format_wordcount(wordcount)
                              endif
                            endfunction
                            
    1              0.000001 let s:visual_active = 0  " Boolean: for when to get visual wordcount
    1              0.000002 function airline#extensions#wordcount#get()
                              if s:visual_active
                                return s:format_wordcount(s:get_wordcount(1))
                              else
                                if get(b:, 'airline_changedtick', 0) != b:changedtick
                                  call s:update_wordcount(0)
                                  let b:airline_changedtick = b:changedtick
                                endif
                                return get(b:, 'airline_wordcount', '')
                              endif
                            endfunction
                            
                            " airline functions {{{1
                            " default filetypes:
    1              0.000003 let s:filetypes = ['help', 'markdown', 'rst', 'org', 'text', 'asciidoc', 'tex', 'mail']
    1              0.000002 function! airline#extensions#wordcount#apply(...)
                              let filetypes = get(g:, 'airline#extensions#wordcount#filetypes', s:filetypes)
                            
                              " Check if filetype needs testing
                              if did_filetype() || filetypes isnot s:filetypes
                                let s:filetypes = filetypes
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([]))
                                      \ ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1
                                      \ : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
                              if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section(
                                      \ 'z', '%{airline#extensions#wordcount#get()}')
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#wordcount#init(ext)
                              augroup airline_wordcount
                                autocmd! User AirlineModeChanged nested
                                      \ let s:visual_active = (mode() ==? 'v' || mode() ==? 's')
                              augroup END
                              call a:ext.add_statusline_func('airline#extensions#wordcount#apply')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/keymap.vim
Sourced 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Doron Behar, C.Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000003 if !has('keymap')
                              finish
                            endif
                            
    1              0.000003 function! airline#extensions#keymap#status()
                              if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
                                return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 function! airline#extensions#keymap#init(ext)
                              call airline#parts#define_function('keymap', 'airline#extensions#keymap#status')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/section.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000094

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000004 scriptencoding utf-8
                            
    1   0.000011   0.000006 call airline#init#bootstrap()
    1              0.000006 let s:spc = g:airline_symbols.space
                            
    1              0.000005 function! s:wrap_accent(part, value)
                              if exists('a:part.accent')
                                call airline#highlighter#add_accent(a:part.accent)
                                return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value
                            endfunction
                            
    1              0.000002 function! s:create(parts, append)
                              let _ = ''
                              for idx in range(len(a:parts))
                                let part = airline#parts#get(a:parts[idx])
                                let val = ''
                                let add_sep = get(l:, 'add_sep', 0)
                            
                                if exists('part.function')
                                  let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
                                let minwidth = get(part, 'minwidth', 0)
                            
                                if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
                                  let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
                                  let add_sep = 0
                                endif
                            
                                if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
                                let val .= s:wrap_accent(part, partval)
                                let _ .= val
                              endfor
                              return _
                            endfunction
                            
    1              0.000002 function! airline#section#create(parts)
                              return s:create(a:parts, 0)
                            endfunction
                            
    1              0.000003 function! airline#section#create_left(parts)
                              return s:create(a:parts, 1)
                            endfunction
                            
    1              0.000002 function! airline#section#create_right(parts)
                              return s:create(a:parts, -1)
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim
Sourced 1 time
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000021 let s:is_win32term = (has('win32') || has('win64')) &&
                                               \ !has('gui_running') &&
                                               \ (empty($CONEMUBUILD) || &term !=? 'xterm') &&
                                               \ !(exists("+termguicolors") && &termguicolors)
                            
    1              0.000002 let s:separators = {}
    1              0.000001 let s:accents = {}
    1              0.000002 let s:hl_groups = {}
                            
    1              0.000003 function! s:gui2cui(rgb, fallback)
                              if a:rgb == ''
                                return a:fallback
                              elseif match(a:rgb, '^\%(NONE\|[fb]g\)$') > -1
                                return a:rgb
                              endif
                              let rgb = map(split(a:rgb[1:], '..\zs'), '0 + ("0x".v:val)')
                              return airline#msdos#round_msdos_colors(rgb)
                            endfunction
                            
    1              0.000002 function! s:group_not_done(list, name)
                              if index(a:list, a:name) == -1
                                call add(a:list, a:name)
                                return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif
                            endfu
                            
    1              0.000002 function! s:get_syn(group, what)
                              if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
                              let color = ''
                              if hlexists(a:group)
                                let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
                              endif
                              if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
                              endif
                              return color
                            endfunction
                            
    1              0.000002 function! s:get_array(fg, bg, opts)
                              let opts=empty(a:opts) ? '' : join(a:opts, ',')
                              return g:airline_gui_mode ==# 'gui'
                                    \ ? [ a:fg, a:bg, '', '', opts ]
                                    \ : [ '', '', a:fg, a:bg, opts ]
                            endfunction
                            
    1              0.000002 function! airline#highlighter#reset_hlcache()
                              let s:hl_groups = {}
                            endfunction
                            
    1              0.000002 function! airline#highlighter#get_highlight(group, ...)
                              let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui'
                                  \ ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui')
                                  \ : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
                                  \|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
                              if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
                                let fg = s:get_syn(a:group, 'fg')
                                let bg = s:get_syn(a:group, 'bg')
                                let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
                                let opts = a:000
                                if bold
                                  let opts = ['bold']
                                endif
                                let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
                              endif
                              let s:hl_groups[a:group] = res
                              return res
                            endfunction
                            
    1              0.000002 function! airline#highlighter#get_highlight2(fg, bg, ...)
                              let fg = s:get_syn(a:fg[0], a:fg[1])
                              let bg = s:get_syn(a:bg[0], a:bg[1])
                              return s:get_array(fg, bg, a:000)
                            endfunction
                            
    1              0.000001 function! s:hl_group_exists(group)
                              if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
                              return 1
                            endfunction
                            
    1              0.000002 function! airline#highlighter#exec(group, colors)
                              if pumvisible()
                                return
                              endif
                              let colors = a:colors
                              if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
                              let old_hi = airline#highlighter#get_highlight(a:group)
                              if len(colors) == 4
                                call add(colors, '')
                              endif
                              if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
                              let colors = s:CheckDefined(colors)
                              if old_hi != new_hi || !s:hl_group_exists(a:group)
                                let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                exe cmd
                                if has_key(s:hl_groups, a:group)
                                  let s:hl_groups[a:group] = colors
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:CheckDefined(colors)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
                              if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
                              if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]
                            endfunction
                            
    1              0.000002 function! s:GetHiCmd(list)
                              " a:list needs to have 5 items!
                              let res = ''
                              let i = -1
                              while i < 4
                                let i += 1
                                let item = get(a:list, i, '')
                                if item is ''
                                  continue
                                endif
                                if i == 0
                                  let res .= ' guifg='.item
                                elseif i == 1
                                  let res .= ' guibg='.item
                                elseif i == 2
                                  let res .= ' ctermfg='.item
                                elseif i == 3
                                  let res .= ' ctermbg='.item
                                elseif i == 4
                                  let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
                                endif
                              endwhile
                              return res
                            endfunction
                            
    1              0.000002 function! s:exec_separator(dict, from, to, inverse, suffix)
                              if pumvisible()
                                return
                              endif
                              let group = a:from.'_to_'.a:to.a:suffix
                              let l:from = airline#themes#get_highlight(a:from.a:suffix)
                              let l:to = airline#themes#get_highlight(a:to.a:suffix)
                              if a:inverse
                                let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
                              else
                                let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
                              endif
                              let a:dict[group] = colors
                              call airline#highlighter#exec(group, colors)
                            endfunction
                            
    1              0.000002 function! airline#highlighter#load_theme()
                              if pumvisible()
                                return
                              endif
                              for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
                              call airline#highlighter#highlight(['inactive'])
                              if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
                              else
                                call airline#highlighter#highlight(['normal'])
                              endif
                            endfunction
                            
    1              0.000002 function! airline#highlighter#add_separator(from, to, inverse)
                              let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
                              call <sid>exec_separator({}, a:from, a:to, a:inverse, '')
                            endfunction
                            
    1              0.000002 function! airline#highlighter#add_accent(accent)
                              let s:accents[a:accent] = 1
                            endfunction
                            
    1              0.000002 function! airline#highlighter#highlight_modified_inactive(bufnr)
                              if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c')
                                      \ ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c')
                                      \ ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
                              endif
                            
                              if !empty(colors)
                                call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
                              endif
                            endfunction
                            
    1              0.000003 function! airline#highlighter#highlight(modes, ...)
                              let bufnr = a:0 ? a:1 : ''
                              let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
                              let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
                              let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
                              let airline_grouplist = []
                              let buffers_in_tabpage = sort(tabpagebuflist())
                              if exists("*uniq")
                                let buffers_in_tabpage = uniq(buffers_in_tabpage)
                              endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
                              for mode in reverse(mapped)
                                if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
                                  let dict = g:airline#themes#{g:airline_theme}#palette[mode]
                                  for kvp in items(dict)
                                    let mode_colors = kvp[1]
                                    let name = kvp[0]
                                    if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
                                    if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
                                    elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
                                      continue
                                    endif
                                    if s:group_not_done(airline_grouplist, name.suffix)
                                      call airline#highlighter#exec(name.suffix, mode_colors)
                                    endif
                            
                                    for accent in keys(s:accents)
                                      if !has_key(p.accents, accent)
                                        continue
                                      endif
                                      let colors = copy(mode_colors)
                                      if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
                                      endif
                                      if p.accents[accent][2] != ''
                                        let colors[2] = p.accents[accent][2]
                                      endif
                                      if len(colors) >= 5
                                        let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
                                      if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
                                        call airline#highlighter#exec(name.suffix.'_'.accent, colors)
                                      endif
                                    endfor
                                  endfor
                            
                                  if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
                                  for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
                                    call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
                                  endfor
                                endif
                              endfor
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/themes/dark.vim
Sourced 1 time
Total time:   0.000469
 Self time:   0.000233

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2 tw=80
                            
    1              0.000002 scriptencoding utf-8
                            
                            " Airline themes are generated based on the following concepts:
                            "   * The section of the status line, valid Airline statusline sections are:
                            "       * airline_a (left most section)
                            "       * airline_b (section just to the right of airline_a)
                            "       * airline_c (section just to the right of airline_b)
                            "       * airline_x (first section of the right most sections)
                            "       * airline_y (section just to the right of airline_x)
                            "       * airline_z (right most section)
                            "   * The mode of the buffer, as reported by the :mode() function.  Airline 
                            "     converts the values reported by mode() to the following:
                            "       * normal
                            "       * insert
                            "       * replace
                            "       * visual
                            "       * inactive
                            "       The last one is actually no real mode as returned by mode(), but used by
                            "       airline to style inactive statuslines (e.g. windows, where the cursor
                            "       currently does not reside in).
                            "   * In addition to each section and mode specified above, airline themes 
                            "     can also specify overrides.  Overrides can be provided for the following
                            "     scenarios:
                            "       * 'modified'
                            "       * 'paste'
                            "
                            " Airline themes are specified as a global viml dictionary using the above
                            " sections, modes and overrides as keys to the dictionary.  The name of the
                            " dictionary is significant and should be specified as:
                            "   * g:airline#themes#<theme_name>#palette
                            " where <theme_name> is substituted for the name of the theme.vim file where the
                            " theme definition resides.  Airline themes should reside somewhere on the
                            " 'runtimepath' where it will be loaded at vim startup, for example:  
                            "   * autoload/airline/themes/theme_name.vim
                            "
                            " For this, the dark.vim, theme, this is defined as
    1              0.000006 let g:airline#themes#dark#palette = {}
                            
                            " Keys in the dictionary are composed of the mode, and if specified the
                            " override.  For example:
                            "   * g:airline#themes#dark#palette.normal 
                            "       * the colors for a statusline while in normal mode
                            "   * g:airline#themes#dark#palette.normal_modified 
                            "       * the colors for a statusline while in normal mode when the buffer has
                            "         been modified
                            "   * g:airline#themes#dark#palette.visual 
                            "       * the colors for a statusline while in visual mode
                            "
                            " Values for each dictionary key is an array of color values that should be
                            " familiar for colorscheme designers:
                            "   * [guifg, guibg, ctermfg, ctermbg, opts]
                            " See "help attr-list" for valid values for the "opt" value.
                            "
                            " Each theme must provide an array of such values for each airline section of
                            " the statusline (airline_a through airline_z).  A convenience function, 
                            " airline#themes#generate_color_map() exists to mirror airline_a/b/c to
                            " airline_x/y/z, respectively.
                            
                            " The dark.vim theme:
    1              0.000003 let s:airline_a_normal   = [ '#00005f' , '#dfff00' , 17  , 190 ]
    1              0.000002 let s:airline_b_normal   = [ '#ffffff' , '#444444' , 255 , 238 ]
    1              0.000007 let s:airline_c_normal   = [ '#9cffd3' , '#202020' , 85  , 234 ]
    1   0.000174   0.000068 let g:airline#themes#dark#palette.normal = airline#themes#generate_color_map(s:airline_a_normal, s:airline_b_normal, s:airline_c_normal)
                            
                            " It should be noted the above is equivalent to:
                            " let g:airline#themes#dark#palette.normal = airline#themes#generate_color_map(
                            "    \  [ '#00005f' , '#dfff00' , 17  , 190 ],  " section airline_a
                            "    \  [ '#ffffff' , '#444444' , 255 , 238 ],  " section airline_b
                            "    \  [ '#9cffd3' , '#202020' , 85  , 234 ]   " section airline_c
                            "    \)
                            "
                            " In turn, that is equivalent to:
                            " let g:airline#themes#dark#palette.normal = {
                            "    \  'airline_a': [ '#00005f' , '#dfff00' , 17  , 190 ],  "section airline_a
                            "    \  'airline_b': [ '#ffffff' , '#444444' , 255 , 238 ],  "section airline_b
                            "    \  'airline_c': [ '#9cffd3' , '#202020' , 85  , 234 ],  "section airline_c
                            "    \  'airline_x': [ '#9cffd3' , '#202020' , 85  , 234 ],  "section airline_x
                            "    \  'airline_y': [ '#ffffff' , '#444444' , 255 , 238 ],  "section airline_y
                            "    \  'airline_z': [ '#00005f' , '#dfff00' , 17  , 190 ]   "section airline_z
                            "    \}
                            "
                            " airline#themes#generate_color_map() also uses the values provided as
                            " parameters to create intermediary groups such as:
                            "   airline_a_to_airline_b
                            "   airline_b_to_airline_c
                            "   etc...
                            
                            " Here we define overrides for when the buffer is modified.  This will be
                            " applied after g:airline#themes#dark#palette.normal, hence why only certain keys are
                            " declared.
    1              0.000005 let g:airline#themes#dark#palette.normal_modified = {
                                  \ 'airline_c': [ '#ffffff' , '#5f005f' , 255     , 53      , ''     ] ,
                                  \ }
                            
                            
    1              0.000002 let s:airline_a_insert = [ '#00005f' , '#00dfff' , 17  , 45  ]
    1              0.000002 let s:airline_b_insert = [ '#ffffff' , '#005fff' , 255 , 27  ]
    1              0.000002 let s:airline_c_insert = [ '#ffffff' , '#000080' , 15  , 17  ]
    1   0.000039   0.000006 let g:airline#themes#dark#palette.insert = airline#themes#generate_color_map(s:airline_a_insert, s:airline_b_insert, s:airline_c_insert)
    1              0.000005 let g:airline#themes#dark#palette.insert_modified = {
                                  \ 'airline_c': [ '#ffffff' , '#5f005f' , 255     , 53      , ''     ] ,
                                  \ }
    1              0.000007 let g:airline#themes#dark#palette.insert_paste = {
                                  \ 'airline_a': [ s:airline_a_insert[0]   , '#d78700' , s:airline_a_insert[2] , 172     , ''     ] ,
                                  \ }
                            
                            
    1              0.000004 let g:airline#themes#dark#palette.replace = copy(g:airline#themes#dark#palette.insert)
    1              0.000004 let g:airline#themes#dark#palette.replace.airline_a = [ s:airline_b_insert[0]   , '#af0000' , s:airline_b_insert[2] , 124     , ''     ]
    1              0.000002 let g:airline#themes#dark#palette.replace_modified = g:airline#themes#dark#palette.insert_modified
                            
                            
    1              0.000002 let s:airline_a_visual = [ '#000000' , '#ffaf00' , 232 , 214 ]
    1              0.000004 let s:airline_b_visual = [ '#000000' , '#ff5f00' , 232 , 202 ]
    1              0.000002 let s:airline_c_visual = [ '#ffffff' , '#5f0000' , 15  , 52  ]
    1   0.000037   0.000006 let g:airline#themes#dark#palette.visual = airline#themes#generate_color_map(s:airline_a_visual, s:airline_b_visual, s:airline_c_visual)
    1              0.000004 let g:airline#themes#dark#palette.visual_modified = {
                                  \ 'airline_c': [ '#ffffff' , '#5f005f' , 255     , 53      , ''     ] ,
                                  \ }
                            
                            
    1              0.000002 let s:airline_a_inactive = [ '#4e4e4e' , '#1c1c1c' , 239 , 234 , '' ]
    1              0.000002 let s:airline_b_inactive = [ '#4e4e4e' , '#262626' , 239 , 235 , '' ]
    1              0.000002 let s:airline_c_inactive = [ '#4e4e4e' , '#303030' , 239 , 236 , '' ]
    1   0.000040   0.000005 let g:airline#themes#dark#palette.inactive = airline#themes#generate_color_map(s:airline_a_inactive, s:airline_b_inactive, s:airline_c_inactive)
    1              0.000005 let g:airline#themes#dark#palette.inactive_modified = {
                                  \ 'airline_c': [ '#875faf' , '' , 97 , '' , '' ] ,
                                  \ }
                            
                            " For commandline mode, we use the colors from normal mode, except the mode
                            " indicator should be colored differently, e.g. blue on light green
    1              0.000002 let s:airline_a_commandline = [ '#0000ff' , '#0cff00' , 63  , 40 ]
    1              0.000002 let s:airline_b_commandline = [ '#ffffff' , '#444444' , 255 , 238 ]
    1              0.000002 let s:airline_c_commandline = [ '#9cffd3' , '#202020' , 85  , 234 ]
    1   0.000037   0.000006 let g:airline#themes#dark#palette.commandline = airline#themes#generate_color_map(s:airline_a_commandline, s:airline_b_commandline, s:airline_c_commandline)
                            
                            " Accents are used to give parts within a section a slightly different look or
                            " color. Here we are defining a "red" accent, which is used by the 'readonly'
                            " part by default. Only the foreground colors are specified, so the background
                            " colors are automatically extracted from the underlying section colors. What
                            " this means is that regardless of which section the part is defined in, it
                            " will be red instead of the section's foreground color. You can also have
                            " multiple parts with accents within a section.
    1              0.000003 let g:airline#themes#dark#palette.accents = {
                                  \ 'red': [ '#ff0000' , '' , 160 , ''  ]
                                  \ }
                            
                            
                            " Here we define the color map for ctrlp.  We check for the g:loaded_ctrlp
                            " variable so that related functionality is loaded iff the user is using
                            " ctrlp. Note that this is optional, and if you do not define ctrlp colors
                            " they will be chosen automatically from the existing palette.
    1              0.000002 if get(g:, 'loaded_ctrlp', 0)
                              let g:airline#themes#dark#palette.ctrlp = airline#extensions#ctrlp#generate_color_map(
                                    \ [ '#d7d7ff' , '#5f00af' , 189 , 55  , ''     ],
                                    \ [ '#ffffff' , '#875fd7' , 231 , 98  , ''     ],
                                    \ [ '#5f00af' , '#ffffff' , 55  , 231 , 'bold' ])
                            endif

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/themes.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
                            " generates a dictionary which defines the colors for each highlight group
    1              0.000003 function! airline#themes#generate_color_map(sect1, sect2, sect3, ...)
                              let palette = {
                                    \ 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] ,
                                    \ 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] ,
                                    \ 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] ,
                                    \ }
                            
                              if a:0 > 0
                                call extend(palette, {
                                      \ 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] ,
                                      \ 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] ,
                                      \ 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] ,
                                      \ })
                              else
                                call extend(palette, {
                                      \ 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] ,
                                      \ 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] ,
                                      \ 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] ,
                                      \ })
                              endif
                            
                              return palette
                            endfunction
                            
    1              0.000002 function! airline#themes#get_highlight(group, ...)
                              return call('airline#highlighter#get_highlight', [a:group] + a:000)
                            endfunction
                            
    1              0.000002 function! airline#themes#get_highlight2(fg, bg, ...)
                              return call('airline#highlighter#get_highlight2', [a:fg, a:bg] + a:000)
                            endfunction
                            
    1              0.000003 function! airline#themes#patch(palette)
                              for mode in keys(a:palette)
                                if mode == 'accents'
                                  continue
                                endif
                                if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
                                if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
                                endif
                                if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
                                endif
                              endfor
                            
                              let a:palette.accents = get(a:palette, 'accents', {})
                              let a:palette.accents.none = [ '', '', '', '', '' ]
                              let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
                              let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
                              if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
                              if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
                              if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
                              if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
                              if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
                              if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim
Sourced 1 time
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 let s:prototype = {}
                            
    1              0.000002 function! s:prototype.split(...) dict
                              call add(self._sections, ['|', a:0 ? a:1 : '%='])
                            endfunction
                            
    1              0.000002 function! s:prototype.add_section_spaced(group, contents) dict
                              let spc = empty(a:contents) ? '' : g:airline_symbols.space
                              call self.add_section(a:group, spc.a:contents.spc)
                            endfunction
                            
    1              0.000001 function! s:prototype.add_section(group, contents) dict
                              call add(self._sections, [a:group, a:contents])
                            endfunction
                            
    1              0.000001 function! s:prototype.add_raw(text) dict
                              call add(self._sections, ['', a:text])
                            endfunction
                            
    1              0.000002 function! s:prototype.insert_section(group, contents, position) dict
                              call insert(self._sections, [a:group, a:contents], a:position)
                            endfunction
                            
    1              0.000001 function! s:prototype.insert_raw(text, position) dict
                              call insert(self._sections, ['', a:text], a:position)
                            endfunction
                            
    1              0.000001 function! s:prototype.get_position() dict
                              return len(self._sections)
                            endfunction
                            
    1              0.000003 function! airline#builder#get_prev_group(sections, i)
                              let x = a:i - 1
                              while x >= 0
                                let group = a:sections[x][0]
                                if group != '' && group != '|'
                                  return group
                                endif
                                let x = x - 1
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000002 function! airline#builder#get_next_group(sections, i)
                              let x = a:i + 1
                              let l = len(a:sections)
                              while x < l
                                let group = a:sections[x][0]
                                if group != '' && group != '|'
                                  return group
                                endif
                                let x = x + 1
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000001 function! s:prototype.build() dict
                              let side = 1
                              let line = ''
                              let i = 0
                              let length = len(self._sections)
                              let split = 0
                              let is_empty = 0
                              let prev_group = ''
                            
                              while i < length
                                let section = self._sections[i]
                                let group = section[0]
                                let contents = section[1]
                                let pgroup = prev_group
                                let prev_group = airline#builder#get_prev_group(self._sections, i)
                                if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
                                if is_empty
                                  let prev_group = pgroup
                                endif
                                let is_empty = s:section_is_empty(self, contents)
                            
                                if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
                                if group == ''
                                  let line .= contents
                                elseif group == '|'
                                  let side = 0
                                  let line .= contents
                                  let split = 1
                                else
                                  if prev_group == ''
                                    let line .= '%#'.group.'#'
                                  elseif split
                                    if !is_empty
                                      let line .= s:get_transitioned_seperator(self, prev_group, group, side)
                                    endif
                                    let split = 0
                                  else
                                    if !is_empty
                                      let line .= s:get_seperator(self, prev_group, group, side)
                                    endif
                                  endif
                                  let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
                                endif
                            
                                let i = i + 1
                              endwhile
                            
                              if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
                              return line
                            endfunction
                            
    1              0.000002 function! airline#builder#should_change_group(group1, group2)
                              if a:group1 == a:group2
                                return 0
                              endif
                              let color1 = airline#highlighter#get_highlight(a:group1)
                              let color2 = airline#highlighter#get_highlight(a:group2)
                              if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif
                            endfunction
                            
    1              0.000002 function! s:get_transitioned_seperator(self, prev_group, group, side)
                              let line = ''
                              if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
                                call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
                                let line .= '%#'.a:group.'#'
                              endif
                              return line
                            endfunction
                            
    1              0.000002 function! s:get_seperator(self, prev_group, group, side)
                              if airline#builder#should_change_group(a:prev_group, a:group)
                                return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif
                            endfunction
                            
    1              0.000002 function! s:get_accented_line(self, group, contents)
                              if a:self._context.active
                                " active window
                                let contents = []
                                let content_parts = split(a:contents, '__accent')
                                for cpart in content_parts
                                  let accent = matchstr(cpart, '_\zs[^#]*\ze')
                                  call add(contents, cpart)
                                endfor
                                let line = join(contents, a:group)
                                let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
                              return line
                            endfunction
                            
    1              0.000002 function! s:section_is_empty(self, content)
                              let start=1
                            
                              " do not check for inactive windows or the tabline
                              if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1
                            endfunction
                            
    1              0.000002 function! airline#builder#new(context)
                              let builder = copy(s:prototype)
                              let builder._context = a:context
                              let builder._sections = []
                            
                              call extend(builder._context, {
                                    \ 'left_sep': g:airline_left_sep,
                                    \ 'left_alt_sep': g:airline_left_alt_sep,
                                    \ 'right_sep': g:airline_right_sep,
                                    \ 'right_alt_sep': g:airline_right_alt_sep,
                                    \ }, 'keep')
                              return builder
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim
Sourced 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2018 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000005 let s:section_use_groups     = get(g:, 'airline#extensions#default#section_use_groupitems', 1)
    1              0.000009 let s:section_truncate_width = get(g:, 'airline#extensions#default#section_truncate_width', {
                                  \ 'b': 79,
                                  \ 'x': 60,
                                  \ 'y': 88,
                                  \ 'z': 45,
                                  \ 'warning': 80,
                                  \ 'error': 80,
                                  \ })
    1              0.000005 let s:layout = get(g:, 'airline#extensions#default#layout', [
                                  \ [ 'a', 'b', 'c' ],
                                  \ [ 'x', 'y', 'z', 'warning', 'error' ]
                                  \ ])
                            
    1              0.000003 function! s:get_section(winnr, key, ...)
                              if has_key(s:section_truncate_width, a:key)
                                if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
                              endif
                              let spc = g:airline_symbols.space
                              if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
                              let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
                              let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
                              return empty(text) ? '' : prefix.text.suffix
                            endfunction
                            
    1              0.000002 function! s:build_sections(builder, context, keys)
                              for key in a:keys
                                if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
                                call s:add_section(a:builder, a:context, key)
                              endfor
                            endfunction
                            
                            " There still is a highlighting bug when using groups %(%) in the statusline,
                            " deactivate it, unless it is fixed (7.4.1511)
    1              0.000003 if s:section_use_groups && (v:version >= 704 || (v:version >= 703 && has('patch81')))
    1              0.000002   function! s:add_section(builder, context, key)
                                let condition = (a:key is# "warning" || a:key is# "error") &&
                                      \ (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
                                if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
                                if condition
                                  call a:builder.add_raw('%(')
                                endif
                                call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
                                if condition
                                  call a:builder.add_raw('%)')
                                endif
                              endfunction
    1              0.000001 else
                              " older version don't like the use of %(%)
                              function! s:add_section(builder, context, key)
                                if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
                                if a:key == 'warning'
                                  call a:builder.add_raw('%#airline_warning#'.s:get_section(a:context.winnr, a:key))
                                elseif a:key == 'error'
                                  call a:builder.add_raw('%#airline_error#'.s:get_section(a:context.winnr, a:key))
                                else
                                  call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
                                endif
                              endfunction
                            endif
                            
    1              0.000002 function! airline#extensions#default#apply(builder, context)
                              let winnr = a:context.winnr
                              let active = a:context.active
                            
                              if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
                                call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
                              call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
                              if airline#util#getwinvar(winnr, 'airline_render_right', 1)
                                call s:build_sections(a:builder, a:context, s:layout[1])
                              endif
                            
                              return 1
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale.vim
Sourced 1 time
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>, David Alexander <opensource@thelonelyghost.com>
                            " Description: Primary code path for the plugin
                            "   Manages execution of linters when requested by autocommands
                            
                            " Strings used for severity in the echoed message
    1              0.000009 let g:ale_echo_msg_error_str = get(g:, 'ale_echo_msg_error_str', 'Error')
    1              0.000006 let g:ale_echo_msg_info_str = get(g:, 'ale_echo_msg_info_str', 'Info')
    1              0.000006 let g:ale_echo_msg_warning_str = get(g:, 'ale_echo_msg_warning_str', 'Warning')
                            " Ignoring linters, for disabling some, or ignoring LSP diagnostics.
    1              0.000005 let g:ale_linters_ignore = get(g:, 'ale_linters_ignore', {})
                            
    1              0.000002 let s:lint_timer = -1
    1              0.000003 let s:getcmdwintype_exists = exists('*getcmdwintype')
                            
                            " Return 1 if a file is too large for ALE to handle.
    1              0.000003 function! ale#FileTooLarge(buffer) abort
                                let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
                                return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0
                            endfunction
                            
                            " A function for checking various conditions whereby ALE just shouldn't
                            " attempt to do anything, say if particular buffer types are open in Vim.
    1              0.000002 function! ale#ShouldDoNothing(buffer) abort
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
                                if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
                                if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
                                if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
                                if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
                                if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
                                if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
                                if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
                                if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
                                if exists(':CtrlPFunky') is 2
                                \&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000002 function! s:Lint(buffer, should_lint_file, timer_id) abort
                                " Use the filetype from the buffer
                                let l:filetype = getbufvar(a:buffer, '&filetype')
                                let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
                                let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
                                let l:linters = !empty(l:ignore_config)
                                \   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config)
                                \   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
                                let g:ale_want_results_buffer = a:buffer
                                silent doautocmd <nomodeline> User ALEWantResults
                                unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
                                if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
                                let l:lint_file = empty(l:linters)
                                \   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
                                call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)
                            endfunction
                            
                            " (delay, [linting_flag, buffer_number])
    1              0.000002 function! ale#Queue(delay, ...) abort
                                if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                let l:buffer = get(a:000, 1, v:null)
                            
                                if l:buffer is v:null
                                    let l:buffer = bufnr('')
                                endif
                            
                                if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                " Default linting_flag to ''
                                let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
                                if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
                                if a:delay > 0
                                    let s:lint_timer = timer_start(
                                    \   a:delay,
                                    \   function('s:Lint', [l:buffer, l:should_lint_file])
                                    \)
                                else
                                    call s:Lint(l:buffer, l:should_lint_file, 0)
                                endif
                            endfunction
                            
    1              0.000006 let g:ale_has_override = get(g:, 'ale_has_override', {})
                            
                            " Call has(), but check a global Dictionary so we can force flags on or off
                            " for testing purposes.
    1              0.000002 function! ale#Has(feature) abort
                                return get(g:ale_has_override, a:feature, has(a:feature))
                            endfunction
                            
                            " Given a buffer number and a variable name, look for that variable in the
                            " buffer scope, then in global scope. If the name does not exist in the global
                            " scope, an exception will be thrown.
                            "
                            " Every variable name will be prefixed with 'ale_'.
    1              0.000002 function! ale#Var(buffer, variable_name) abort
                                let l:full_name = 'ale_' . a:variable_name
                                let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
                                return get(l:vars, l:full_name, g:[l:full_name])
                            endfunction
                            
                            " As above, but curry the arguments so only the buffer number is required.
    1              0.000002 function! ale#VarFunc(variable_name) abort
                                return {buf -> ale#Var(buf, a:variable_name)}
                            endfunction
                            
                            " Initialize a variable with a default value, if it isn't already set.
                            "
                            " Every variable name will be prefixed with 'ale_'.
    1              0.000002 function! ale#Set(variable_name, default) abort
                                let l:full_name = 'ale_' . a:variable_name
                            
                                if !has_key(g:, l:full_name)
                                    let g:[l:full_name] = a:default
                                endif
                            endfunction
                            
                            " Given a string for adding to a command, return the string padded with a
                            " space on the left if it is not empty. Otherwise return an empty string.
                            "
                            " This can be used for making command strings cleaner and easier to test.
    1              0.000002 function! ale#Pad(string) abort
                                return !empty(a:string) ? ' ' . a:string : ''
                            endfunction
                            
                            " Given a environment variable name and a value, produce part of a command for
                            " setting an environment variable before running a command. The syntax will be
                            " valid for cmd on Windows, or most shells on Unix.
    1              0.000002 function! ale#Env(variable_name, value) abort
                                if has('win32')
                                    return 'set ' . a:variable_name . '=' . ale#Escape(a:value) . ' && '
                                endif
                            
                                return a:variable_name . '=' . ale#Escape(a:value) . ' '
                            endfunction
                            
                            " Escape a string suitably for each platform.
                            " shellescape does not work on Windows.
    1              0.000002 function! ale#Escape(str) abort
                                if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(
                                    \   a:str =~# ' '
                                    \       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'
                                    \       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),
                                    \   '%',
                                    \   '%%',
                                    \   'g',
                                    \)
                                endif
                            
                                return shellescape (a:str)
                            endfunction
                            
                            " Get the loclist item message according to a given format string.
                            "
                            " See `:help g:ale_loclist_msg_format` and `:help g:ale_echo_msg_format`
    1              0.000002 function! ale#GetLocItemMessage(item, format_string) abort
                                let l:msg = a:format_string
                                let l:severity = g:ale_echo_msg_warning_str
                                let l:code = get(a:item, 'code', '')
                                let l:type = get(a:item, 'type', 'E')
                                let l:linter_name = get(a:item, 'linter_name', '')
                                let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
                                if l:type is# 'E'
                                    let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
                                let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
                                let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
                                let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
                                return l:msg
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/util.vim
Sourced 1 time
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Contains miscellaneous functions
                            
                            " A wrapper function for mode() so we can test calls for it.
    1              0.000002 function! ale#util#Mode(...) abort
                                return call('mode', a:000)
                            endfunction
                            
                            " A wrapper function for feedkeys so we can test calls for it.
    1              0.000002 function! ale#util#FeedKeys(...) abort
                                return call('feedkeys', a:000)
                            endfunction
                            
                            " Show a message in as small a window as possible.
                            "
                            " Vim 8 does not support echoing long messages from asynchronous callbacks,
                            " but NeoVim does. Small messages can be echoed in Vim 8, and larger messages
                            " have to be shown in preview windows.
    1              0.000002 function! ale#util#ShowMessage(string) abort
                                if !has('nvim')
                                    call ale#preview#CloseIfTypeMatches('ale-preview.message')
                                endif
                            
                                " We have to assume the user is using a monospace font.
                                if has('nvim') || (a:string !~? "\n" && len(a:string) < &columns)
                                    execute 'echo a:string'
                                else
                                    call ale#preview#Show(split(a:string, "\n"), {
                                    \   'filetype': 'ale-preview.message',
                                    \   'stay_here': 1,
                                    \})
                                endif
                            endfunction
                            
                            " A wrapper function for execute, so we can test executing some commands.
    1              0.000002 function! ale#util#Execute(expr) abort
                                execute a:expr
                            endfunction
                            
    1              0.000003 if !exists('g:ale#util#nul_file')
                                " A null file for sending output to nothing.
    1              0.000006     let g:ale#util#nul_file = '/dev/null'
                            
    1              0.000005     if has('win32')
                                    let g:ale#util#nul_file = 'nul'
                                endif
    1              0.000001 endif
                            
                            " Given a job, a buffered line of data, a list of parts of lines, a mode data
                            " is being read in, and a callback, join the lines of output for a NeoVim job
                            " or socket together, and call the callback with the joined output.
                            "
                            " Note that jobs and IDs are the same thing on NeoVim.
    1              0.000003 function! ale#util#JoinNeovimOutput(job, last_line, data, mode, callback) abort
                                if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
                                endif
                            
                                let l:lines = a:data[:-2]
                            
                                if len(a:data) > 1
                                    let l:lines[0] = a:last_line . l:lines[0]
                                    let l:new_last_line = a:data[-1]
                                else
                                    let l:new_last_line = a:last_line . get(a:data, 0, '')
                                endif
                            
                                for l:line in l:lines
                                    call a:callback(a:job, l:line)
                                endfor
                            
                                return l:new_last_line
                            endfunction
                            
                            " Return the number of lines for a given buffer.
    1              0.000002 function! ale#util#GetLineCount(buffer) abort
                                return len(getbufline(a:buffer, 1, '$'))
                            endfunction
                            
    1              0.000002 function! ale#util#GetFunction(string_or_ref) abort
                                if type(a:string_or_ref) is v:t_string
                                    return function(a:string_or_ref)
                                endif
                            
                                return a:string_or_ref
                            endfunction
                            
                            " Open the file (at the given line).
                            " options['open_in'] can be:
                            "   current-buffer (default)
                            "   tab
                            "   vertical-split
                            "   horizontal-split
    1              0.000002 function! ale#util#Open(filename, line, column, options) abort
                                let l:open_in = get(a:options, 'open_in', 'current-buffer')
                                let l:args_to_open = '+' . a:line . ' ' . fnameescape(a:filename)
                            
                                if l:open_in is# 'tab'
                                    call ale#util#Execute('tabedit ' . l:args_to_open)
                                elseif l:open_in is# 'horizontal-split'
                                    call ale#util#Execute('split ' . l:args_to_open)
                                elseif l:open_in is# 'vertical-split'
                                    call ale#util#Execute('vsplit ' . l:args_to_open)
                                elseif bufnr(a:filename) isnot bufnr('')
                                    " Open another file only if we need to.
                                    call ale#util#Execute('edit ' . l:args_to_open)
                                else
                                    normal! m`
                                endif
                            
                                call cursor(a:line, a:column)
                            endfunction
                            
    1              0.000005 let g:ale#util#error_priority = 5
    1              0.000004 let g:ale#util#warning_priority = 4
    1              0.000004 let g:ale#util#info_priority = 3
    1              0.000004 let g:ale#util#style_error_priority = 2
    1              0.000004 let g:ale#util#style_warning_priority = 1
                            
    1              0.000002 function! ale#util#GetItemPriority(item) abort
                                if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
                                if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority
                            endfunction
                            
                            " Compare two loclist items for ALE, sorted by their buffers, filenames, and
                            " line numbers and column numbers.
    1              0.000002 function! ale#util#LocItemCompare(left, right) abort
                                if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
                                if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
                                if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
                                if a:left.lnum < a:right.lnum
                                    return -1
                                endif
                            
                                if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
                                if a:left.col < a:right.col
                                    return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " Compare two loclist items, including the text for the items.
                            "
                            " This function can be used for de-duplicating lists.
    1              0.000002 function! ale#util#LocItemCompareWithText(left, right) abort
                                let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                            
                                if l:cmp_value
                                    return l:cmp_value
                                endif
                            
                                if a:left.text < a:right.text
                                    return -1
                                endif
                            
                                if a:left.text > a:right.text
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function will perform a binary search and a small sequential search
                            " on the list to find the last problem in the buffer and line which is
                            " on or before the column. The index of the problem will be returned.
                            "
                            " -1 will be returned if nothing can be found.
    1              0.000002 function! ale#util#BinarySearch(loclist, buffer, line, column) abort
                                let l:min = 0
                                let l:max = len(a:loclist) - 1
                            
                                while 1
                                    if l:max < l:min
                                        return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0
                                        \&& a:loclist[l:index - 1].bufnr == a:buffer
                                        \&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max
                                        \&& a:loclist[l:index + 1].bufnr == a:buffer
                                        \&& a:loclist[l:index + 1].lnum == a:line
                                        \&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile
                            endfunction
                            
                            " A function for testing if a function is running inside a sandbox.
                            " See :help sandbox
    1              0.000002 function! ale#util#InSandbox() abort
                                try
                                    let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
                                return 0
                            endfunction
                            
    1              0.000002 function! ale#util#Tempname() abort
                                let l:clear_tempdir = 0
                            
                                if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
                                try
                                    let l:name = tempname() " no-custom-checks
                                finally
                                    if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
                                endtry
                            
                                return l:name
                            endfunction
                            
                            " Given a single line, or a List of lines, and a single pattern, or a List
                            " of patterns, return all of the matches for the lines(s) from the given
                            " patterns, using matchlist().
                            "
                            " Only the first pattern which matches a line will be returned.
    1              0.000002 function! ale#util#GetMatches(lines, patterns) abort
                                let l:matches = []
                                let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
                                let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
                                for l:line in l:lines
                                    for l:pattern in l:patterns
                                        let l:match = matchlist(l:line, l:pattern)
                            
                                        if !empty(l:match)
                                            call add(l:matches, l:match)
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:matches
                            endfunction
                            
    1              0.000002 function! s:LoadArgCount(function) abort
                                let l:Function = a:function
                            
                                redir => l:output
                                    silent! function Function
                                redir END
                            
                                if !exists('l:output')
                                    return 0
                                endif
                            
                                let l:match = matchstr(split(l:output, "\n")[0], '\v\([^)]+\)')[1:-2]
                                let l:arg_list = filter(split(l:match, ', '), 'v:val isnot# ''...''')
                            
                                return len(l:arg_list)
                            endfunction
                            
                            " Given the name of a function, a Funcref, or a lambda, return the number
                            " of named arguments for a function.
    1              0.000002 function! ale#util#FunctionArgCount(function) abort
                                let l:Function = ale#util#GetFunction(a:function)
                                let l:count = s:LoadArgCount(l:Function)
                            
                                " If we failed to get the count, forcibly load the autoload file, if the
                                " function is an autoload function. autoload functions aren't normally
                                " defined until they are called.
                                if l:count == 0
                                    let l:function_name = matchlist(string(l:Function), 'function([''"]\(.\+\)[''"])')[1]
                            
                                    if l:function_name =~# '#'
                                        execute 'runtime autoload/' . join(split(l:function_name, '#')[:-2], '/') . '.vim'
                                        let l:count = s:LoadArgCount(l:Function)
                                    endif
                                endif
                            
                                return l:count
                            endfunction
                            
                            " Escape a string so the characters in it will be safe for use inside of PCRE
                            " or RE2 regular expressions without characters having special meanings.
    1              0.000002 function! ale#util#EscapePCRE(unsafe_string) abort
                                return substitute(a:unsafe_string, '\([\-\[\]{}()*+?.^$|]\)', '\\\1', 'g')
                            endfunction
                            
                            " Escape a string so that it can be used as a literal string inside an evaled
                            " vim command.
    1              0.000002 function! ale#util#EscapeVim(unsafe_string) abort
                                return "'" . substitute(a:unsafe_string, "'", "''", 'g') . "'"
                            endfunction
                            
                            
                            " Given a String or a List of String values, try and decode the string(s)
                            " as a JSON value which can be decoded with json_decode. If the JSON string
                            " is invalid, the default argument value will be returned instead.
                            "
                            " This function is useful in code where the data can't be trusted to be valid
                            " JSON, and where throwing exceptions is mostly just irritating.
    1              0.000002 function! ale#util#FuzzyJSONDecode(data, default) abort
                                if empty(a:data)
                                    return a:default
                                endif
                            
                                let l:str = type(a:data) is v:t_string ? a:data : join(a:data, '')
                            
                                try
                                    let l:result = json_decode(l:str)
                            
                                    " Vim 8 only uses the value v:none for decoding blank strings.
                                    if !has('nvim') && l:result is v:none
                                        return a:default
                                    endif
                            
                                    return l:result
                                catch /E474/
                                    return a:default
                                endtry
                            endfunction
                            
                            " Write a file, including carriage return characters for DOS files.
                            "
                            " The buffer number is required for determining the fileformat setting for
                            " the buffer.
    1              0.000003 function! ale#util#Writefile(buffer, lines, filename) abort
                                let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'
                                \   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')
                                \   : a:lines
                            
                                call writefile(l:corrected_lines, a:filename) " no-custom-checks
                            endfunction
                            
    1              0.000003 if !exists('s:patial_timers')
    1              0.000002     let s:partial_timers = {}
    1              0.000001 endif
                            
    1              0.000002 function! s:ApplyPartialTimer(timer_id) abort
                                if has_key(s:partial_timers, a:timer_id)
                                    let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
                                    call call(l:Callback, [a:timer_id] + l:args)
                                endif
                            endfunction
                            
                            " Given a delay, a callback, a List of arguments, start a timer with
                            " timer_start() and call the callback provided with [timer_id] + args.
                            "
                            " The timer must not be stopped with timer_stop().
                            " Use ale#util#StopPartialTimer() instead, which can stop any timer, and will
                            " clear any arguments saved for executing callbacks later.
    1              0.000002 function! ale#util#StartPartialTimer(delay, callback, args) abort
                                let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
                                let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
                                return l:timer_id
                            endfunction
                            
    1              0.000003 function! ale#util#StopPartialTimer(timer_id) abort
                                call timer_stop(a:timer_id)
                            
                                if has_key(s:partial_timers, a:timer_id)
                                    call remove(s:partial_timers, a:timer_id)
                                endif
                            endfunction
                            
                            " Given a possibly multi-byte string and a 1-based character position on a
                            " line, return the 1-based byte position on that line.
    1              0.000002 function! ale#util#Col(str, chr) abort
                                if a:chr < 2
                                    return a:chr
                                endif
                            
                                return strlen(join(split(a:str, '\zs')[0:a:chr - 2], '')) + 1
                            endfunction
                            
    1              0.000002 function! ale#util#FindItemAtCursor(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                let l:loclist = get(l:info, 'loclist', [])
                                let l:pos = getcurpos()
                                let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
                                let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
                                return [l:info, l:loc]
                            endfunction
                            

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/linter.vim
Sourced 1 time
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Linter registration and lazy-loading
                            "   Retrieves linters as requested by the engine, loading them if needed.
                            
    1              0.000003 let s:runtime_loaded_map = {}
    1              0.000001 let s:linters = {}
                            
                            " Default filetype aliases.
                            " The user defined aliases will be merged with this Dictionary.
                            "
                            " NOTE: Update the g:ale_linter_aliases documentation when modifying this.
    1              0.000013 let s:default_ale_linter_aliases = {
                            \   'Dockerfile': 'dockerfile',
                            \   'csh': 'sh',
                            \   'plaintex': 'tex',
                            \   'systemverilog': 'verilog',
                            \   'verilog_systemverilog': ['verilog_systemverilog', 'verilog'],
                            \   'vimwiki': 'markdown',
                            \   'vue': ['vue', 'javascript'],
                            \   'zsh': 'sh',
                            \}
                            
                            " Default linters to run for particular filetypes.
                            " The user defined linter selections will be merged with this Dictionary.
                            "
                            " No linters are used for plaintext files by default.
                            "
                            " Only cargo is enabled for Rust by default.
                            " rpmlint is disabled by default because it can result in code execution.
                            " hhast is disabled by default because it executes code in the project root.
                            "
                            " NOTE: Update the g:ale_linters documentation when modifying this.
    1              0.000018 let s:default_ale_linters = {
                            \   'csh': ['shell'],
                            \   'elixir': ['credo', 'dialyxir', 'dogma', 'elixir-ls'],
                            \   'go': ['gofmt', 'golint', 'go vet'],
                            \   'hack': ['hack'],
                            \   'help': [],
                            \   'perl': ['perlcritic'],
                            \   'perl6': [],
                            \   'python': ['flake8', 'mypy', 'pylint'],
                            \   'rust': ['cargo'],
                            \   'spec': [],
                            \   'text': [],
                            \   'vue': ['eslint', 'vls'],
                            \   'zsh': ['shell'],
                            \}
                            
                            " Testing/debugging helper to unload all linters.
    1              0.000002 function! ale#linter#Reset() abort
                                let s:runtime_loaded_map = {}
                                let s:linters = {}
                            endfunction
                            
                            " Return a reference to the linters loaded.
                            " This is only for tests.
                            " Do not call this function.
    1              0.000003 function! ale#linter#GetLintersLoaded() abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                return s:linters
                            endfunction
                            
    1              0.000007 function! s:IsCallback(value) abort
                                return type(a:value) is v:t_string || type(a:value) is v:t_func
                            endfunction
                            
    1              0.000003 function! s:IsBoolean(value) abort
                                return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)
                            endfunction
                            
    1              0.000003 function! s:LanguageGetter(buffer) dict abort
                                return l:self.language
                            endfunction
                            
    1              0.000003 function! ale#linter#PreProcess(filetype, linter) abort
                                if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
                                endif
                            
                                let l:obj = {
                                \   'add_newline': get(a:linter, 'add_newline', 0),
                                \   'name': get(a:linter, 'name'),
                                \   'lsp': get(a:linter, 'lsp', ''),
                                \}
                            
                                if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
                                endif
                            
                                let l:needs_address = l:obj.lsp is# 'socket'
                                let l:needs_executable = l:obj.lsp isnot# 'socket'
                                let l:needs_command = l:obj.lsp isnot# 'socket'
                                let l:needs_lsp_details = !empty(l:obj.lsp)
                            
                                if empty(l:obj.lsp)
                                    let l:obj.callback = get(a:linter, 'callback')
                            
                                    if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
                                    endif
                                endif
                            
                                if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
                                endif
                            
                                if !l:needs_executable
                                    if has_key(a:linter, 'executable')
                                    \|| has_key(a:linter, 'executable_callback')
                                        throw '`executable` and `executable_callback` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'executable_callback')
                                    let l:obj.executable_callback = a:linter.executable_callback
                            
                                    if !s:IsCallback(l:obj.executable_callback)
                                        throw '`executable_callback` must be a callback if defined'
                                    endif
                                elseif has_key(a:linter, 'executable')
                                    let l:obj.executable = a:linter.executable
                            
                                    if type(l:obj.executable) isnot v:t_string
                                        throw '`executable` must be a string if defined'
                                    endif
                                else
                                    throw 'Either `executable` or `executable_callback` must be defined'
                                endif
                            
                                if !l:needs_command
                                    if has_key(a:linter, 'command')
                                    \|| has_key(a:linter, 'command_callback')
                                    \|| has_key(a:linter, 'command_chain')
                                        throw '`command` and `command_callback` and `command_chain` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'command_chain')
                                    let l:obj.command_chain = a:linter.command_chain
                            
                                    if type(l:obj.command_chain) isnot v:t_list
                                        throw '`command_chain` must be a List'
                                    endif
                            
                                    if empty(l:obj.command_chain)
                                        throw '`command_chain` must contain at least one item'
                                    endif
                            
                                    let l:link_index = 0
                            
                                    for l:link in l:obj.command_chain
                                        let l:err_prefix = 'The `command_chain` item ' . l:link_index . ' '
                            
                                        if !s:IsCallback(get(l:link, 'callback'))
                                            throw l:err_prefix . 'must define a `callback` function'
                                        endif
                            
                                        if has_key(l:link, 'output_stream')
                                            if type(l:link.output_stream) isnot v:t_string
                                            \|| index(['stdout', 'stderr', 'both'], l:link.output_stream) < 0
                                                throw l:err_prefix . '`output_stream` flag must be '
                                                \   . "'stdout', 'stderr', or 'both'"
                                            endif
                                        endif
                            
                                        if has_key(l:link, 'read_buffer') && !s:IsBoolean(l:link.read_buffer)
                                            throw l:err_prefix . 'value for `read_buffer` must be `0` or `1`'
                                        endif
                            
                                        let l:link_index += 1
                                    endfor
                                elseif has_key(a:linter, 'command_callback')
                                    let l:obj.command_callback = a:linter.command_callback
                            
                                    if !s:IsCallback(l:obj.command_callback)
                                        throw '`command_callback` must be a callback if defined'
                                    endif
                                elseif has_key(a:linter, 'command')
                                    let l:obj.command = a:linter.command
                            
                                    if type(l:obj.command) isnot v:t_string
                                        throw '`command` must be a string if defined'
                                    endif
                                else
                                    throw 'Either `command`, `executable_callback`, `command_chain` '
                                    \   . 'must be defined'
                                endif
                            
                                if (
                                \   has_key(a:linter, 'command')
                                \   + has_key(a:linter, 'command_chain')
                                \   + has_key(a:linter, 'command_callback')
                                \) > 1
                                    throw 'Only one of `command`, `command_callback`, or `command_chain` '
                                    \   . 'should be set'
                                endif
                            
                                if !l:needs_address
                                    if has_key(a:linter, 'address_callback')
                                        throw '`address_callback` cannot be used when lsp != ''socket'''
                                    endif
                                elseif has_key(a:linter, 'address_callback')
                                    let l:obj.address_callback = a:linter.address_callback
                            
                                    if !s:IsCallback(l:obj.address_callback)
                                        throw '`address_callback` must be a callback if defined'
                                    endif
                                else
                                    throw '`address_callback` must be defined for getting the LSP address'
                                endif
                            
                                if l:needs_lsp_details
                                    if has_key(a:linter, 'language_callback')
                                        if has_key(a:linter, 'language')
                                            throw 'Only one of `language` or `language_callback` '
                                            \   . 'should be set'
                                        endif
                            
                                        let l:obj.language_callback = get(a:linter, 'language_callback')
                            
                                        if !s:IsCallback(l:obj.language_callback)
                                            throw '`language_callback` must be a callback for LSP linters'
                                        endif
                                    else
                                        " Default to using the filetype as the language.
                                        let l:obj.language = get(a:linter, 'language', a:filetype)
                            
                                        if type(l:obj.language) isnot v:t_string
                                            throw '`language` must be a string'
                                        endif
                            
                                        " Make 'language_callback' return the 'language' value.
                                        let l:obj.language_callback = function('s:LanguageGetter')
                                    endif
                            
                                    let l:obj.project_root_callback = get(a:linter, 'project_root_callback')
                            
                                    if !s:IsCallback(l:obj.project_root_callback)
                                        throw '`project_root_callback` must be a callback for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options_callback')
                                        if has_key(a:linter, 'initialization_options')
                                            throw 'Only one of `initialization_options` or '
                                            \   . '`initialization_options_callback` should be set'
                                        endif
                            
                                        let l:obj.initialization_options_callback = a:linter.initialization_options_callback
                            
                                        if !s:IsCallback(l:obj.initialization_options_callback)
                                            throw '`initialization_options_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config_callback')
                                        if has_key(a:linter, 'lsp_config')
                                            throw 'Only one of `lsp_config` or `lsp_config_callback` should be set'
                                        endif
                            
                                        let l:obj.lsp_config_callback = a:linter.lsp_config_callback
                            
                                        if !s:IsCallback(l:obj.lsp_config_callback)
                                            throw '`lsp_config_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict
                                            throw '`lsp_config` must be a Dictionary'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
                                endif
                            
                                let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
                                if type(l:obj.output_stream) isnot v:t_string
                                \|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
                                endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
                                let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
                                if !s:IsBoolean(l:obj.lint_file)
                                    throw '`lint_file` must be `0` or `1`'
                                endif
                            
                                " An option indicating that the buffer should be read.
                                let l:obj.read_buffer = get(a:linter, 'read_buffer', !l:obj.lint_file)
                            
                                if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
                                endif
                            
                                if l:obj.lint_file && l:obj.read_buffer
                                    throw 'Only one of `lint_file` or `read_buffer` can be `1`'
                                endif
                            
                                let l:obj.aliases = get(a:linter, 'aliases', [])
                            
                                if type(l:obj.aliases) isnot v:t_list
                                \|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
                                endif
                            
                                return l:obj
                            endfunction
                            
    1              0.000002 function! ale#linter#Define(filetype, linter) abort
                                " This command will throw from the sandbox.
                                let &l:equalprg=&l:equalprg
                            
                                if !has_key(s:linters, a:filetype)
                                    let s:linters[a:filetype] = []
                                endif
                            
                                let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
                                call add(s:linters[a:filetype], l:new_linter)
                            endfunction
                            
                            " Prevent any linters from being loaded for a given filetype.
    1              0.000002 function! ale#linter#PreventLoading(filetype) abort
                                let s:runtime_loaded_map[a:filetype] = 1
                            endfunction
                            
    1              0.000002 function! ale#linter#GetAll(filetypes) abort
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
                                if ale#util#InSandbox()
                                    return []
                                endif
                            
                                let l:combined_linters = []
                            
                                for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
                                    if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
                                    call extend(l:combined_linters, get(s:linters, l:filetype, []))
                                endfor
                            
                                return l:combined_linters
                            endfunction
                            
    1              0.000002 function! s:GetAliasedFiletype(original_filetype) abort
                                let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
                                if type(l:buffer_aliases) is v:t_list
                                \|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
                                for l:dict in [
                                \   l:buffer_aliases,
                                \   g:ale_linter_aliases,
                                \   s:default_ale_linter_aliases,
                                \]
                                    if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
                                endfor
                            
                                return a:original_filetype
                            endfunction
                            
    1              0.000002 function! ale#linter#ResolveFiletype(original_filetype) abort
                                let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
                                if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
                                endif
                            
                                return l:filetype
                            endfunction
                            
    1              0.000001 function! s:GetLinterNames(original_filetype) abort
                                let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
                                if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
                                if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'
                            endfunction
                            
    1              0.000002 function! ale#linter#Get(original_filetypes) abort
                                let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
                                for l:original_filetype in split(a:original_filetypes, '\.')
                                    let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                                    let l:linter_names = s:GetLinterNames(l:original_filetype)
                                    let l:all_linters = ale#linter#GetAll(l:filetype)
                                    let l:filetype_linters = []
                            
                                    if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
                                    call extend(l:possibly_duplicated_linters, l:filetype_linters)
                                endfor
                            
                                let l:name_list = []
                                let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
                                for l:linter in reverse(l:possibly_duplicated_linters)
                                    if index(l:name_list, l:linter.name) < 0
                                        call add(l:name_list, l:linter.name)
                                        call add(l:combined_linters, l:linter)
                                    endif
                                endfor
                            
                                return reverse(l:combined_linters)
                            endfunction
                            
                            " Given a buffer and linter, get the executable String for the linter.
    1              0.000002 function! ale#linter#GetExecutable(buffer, linter) abort
                                return has_key(a:linter, 'executable_callback')
                                \   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)
                                \   : a:linter.executable
                            endfunction
                            
                            " Given a buffer and linter, get the command String for the linter.
                            " The command_chain key is not supported.
    1              0.000003 function! ale#linter#GetCommand(buffer, linter) abort
                                return has_key(a:linter, 'command_callback')
                                \   ? ale#util#GetFunction(a:linter.command_callback)(a:buffer)
                                \   : a:linter.command
                            endfunction
                            
                            " Given a buffer and linter, get the address for connecting to the server.
    1              0.000002 function! ale#linter#GetAddress(buffer, linter) abort
                                return has_key(a:linter, 'address_callback')
                                \   ? ale#util#GetFunction(a:linter.address_callback)(a:buffer)
                                \   : a:linter.address
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/ale_linters/vim/ale_custom_linting_rules.vim
Sourced 1 time
Total time:   0.000561
 Self time:   0.000250

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: A linter for checking ALE project code itself.
                            
    1              0.000192 function! ale_linters#vim#ale_custom_linting_rules#GetExecutable(buffer) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:dir_list = []
                            
                                for l:dir in split(&runtimepath, ',')
                                    if l:filename[:len(l:dir) - 1] is# l:dir
                                        call add(l:dir_list, l:dir)
                                    endif
                                endfor
                            
                                return !empty(l:dir_list)
                                \   ? findfile('test/script/custom-linting-rules', join(l:dir_list, ','))
                                \   : ''
                            endfunction
                            
    1              0.000003 function! s:GetALEProjectDir(buffer) abort
                                let l:executable = ale_linters#vim#ale_custom_linting_rules#GetExecutable(a:buffer)
                            
                                return ale#path#Dirname(ale#path#Dirname(ale#path#Dirname(l:executable)))
                            endfunction
                            
    1              0.000003 function! ale_linters#vim#ale_custom_linting_rules#GetCommand(buffer) abort
                                let l:dir = s:GetALEProjectDir(a:buffer)
                            
                                let l:temp_dir = ale#engine#CreateDirectory(a:buffer)
                                let l:temp_file = l:temp_dir . '/example.vim'
                            
                                let l:lines = getbufline(a:buffer, 1, '$')
                                call ale#util#Writefile(a:buffer, l:lines, l:temp_file)
                            
                                return ale#path#CdString(l:dir) . '%e ' . ale#Escape(l:temp_dir)
                            endfunction
                            
    1              0.000002 function! ale_linters#vim#ale_custom_linting_rules#Handle(buffer, lines) abort
                                let l:dir = s:GetALEProjectDir(a:buffer)
                                let l:output = []
                                let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+) (.+)$'
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " Ignore trailing whitespace errors if we've turned them off.
                                    if !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    \&& l:match[3] is# 'Trailing whitespace'
                                        continue
                                    endif
                            
                                    call add(l:output, {
                                    \   'lnum': l:match[2],
                                    \   'text': l:match[3],
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000327   0.000016 call ale#linter#Define('vim', {
                            \   'name': 'ale_custom_linting_rules',
                            \   'executable_callback': 'ale_linters#vim#ale_custom_linting_rules#GetExecutable',
                            \   'command_callback': 'ale_linters#vim#ale_custom_linting_rules#GetCommand',
                            \   'callback': 'ale_linters#vim#ale_custom_linting_rules#Handle',
                            \   'read_buffer': 0,
                            \})

SCRIPT  /home/greg/.config/nvim/plugged/ale/ale_linters/vim/vint.vim
Sourced 1 time
Total time:   0.000604
 Self time:   0.000239

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>, KabbAmine <amine.kabb@gmail.com>
                            " Description: This file adds support for checking Vim code with Vint.
                            
                            " This flag can be used to change enable/disable style issues.
    1   0.000029   0.000006 call ale#Set('vim_vint_show_style_issues', 1)
    1   0.000015   0.000004 call ale#Set('vim_vint_executable', 'vint')
    1              0.000006 let s:enable_neovim = has('nvim') ? ' --enable-neovim' : ''
    1              0.000003 let s:format = '-f "{file_path}:{line_number}:{column_number}: {severity}: {description} (see {reference})"'
                            
    1              0.000154 function! ale_linters#vim#vint#GetExecutable(buffer) abort
                                return ale#Var(a:buffer, 'vim_vint_executable')
                            endfunction
                            
    1              0.000003 function! ale_linters#vim#vint#VersionCommand(buffer) abort
                                let l:executable = ale_linters#vim#vint#GetExecutable(a:buffer)
                            
                                " Check the Vint version if we haven't checked it already.
                                return !ale#semver#HasVersion(l:executable)
                                \   ? ale#Escape(l:executable) . ' --version'
                                \   : ''
                            endfunction
                            
    1              0.000002 function! ale_linters#vim#vint#GetCommand(buffer, version_output) abort
                                let l:executable = ale_linters#vim#vint#GetExecutable(a:buffer)
                                let l:version = ale#semver#GetVersion(l:executable, a:version_output)
                            
                                let l:can_use_no_color_flag = empty(l:version)
                                \   || ale#semver#GTE(l:version, [0, 3, 7])
                            
                                let l:warning_flag = ale#Var(a:buffer, 'vim_vint_show_style_issues') ? '-s' : '-w'
                            
                                return ale#Escape(l:executable)
                                \   . ' ' . l:warning_flag
                                \   . (l:can_use_no_color_flag ? ' --no-color' : '')
                                \   . s:enable_neovim
                                \   . ' ' . s:format
                                \   . ' %t'
                            endfunction
                            
    1              0.000006 let s:word_regex_list = [
                            \   '\v^Undefined variable: ([^ ]+)',
                            \   '\v^Make the scope explicit like ...([^ ]+). ',
                            \   '\v^.*start with a capital or contain a colon: ([^ ]+)',
                            \   '\v.*instead of .(\=[=~]).',
                            \]
                            
    1              0.000003 function! ale_linters#vim#vint#Handle(buffer, lines) abort
                                let l:loclist = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
                            
                                for l:item in l:loclist
                                    let l:match = []
                            
                                    for l:regex in s:word_regex_list
                                        let l:match = matchlist(l:item.text, l:regex)
                            
                                        if !empty(l:match)
                                            let l:item.end_col = l:item.col + len(l:match[1]) - 1
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                return l:loclist
                            endfunction
                            
    1   0.000348   0.000016 call ale#linter#Define('vim', {
                            \   'name': 'vint',
                            \   'executable_callback': 'ale_linters#vim#vint#GetExecutable',
                            \   'command_chain': [
                            \       {'callback': 'ale_linters#vim#vint#VersionCommand', 'output_stream': 'stderr'},
                            \       {'callback': 'ale_linters#vim#vint#GetCommand', 'output_stream': 'stdout'},
                            \   ],
                            \   'callback': 'ale_linters#vim#vint#Handle',
                            \})

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/engine.vim
Sourced 1 time
Total time:   0.000549
 Self time:   0.000549

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Backend execution and job management
                            "   Executes linters in the background, using NeoVim or Vim 8 jobs
                            
                            " Remapping of linter problems.
    1              0.000007 let g:ale_type_map = get(g:, 'ale_type_map', {})
                            
                            " Stores information for each job including:
                            "
                            " linter: The linter dictionary for the job.
                            " buffer: The buffer number for the job.
                            " output: The array of lines for the output of the job.
    1              0.000002 if !has_key(s:, 'job_info_map')
    1              0.000002     let s:job_info_map = {}
    1              0.000001 endif
                            
    1              0.000002 if !has_key(s:, 'executable_cache_map')
    1              0.000002     let s:executable_cache_map = {}
    1              0.000001 endif
                            
                            
    1              0.000003 function! ale#engine#CleanupEveryBuffer() abort
                                for l:key in keys(g:ale_buffer_info)
                                    " The key could be a filename or a buffer number, so try and
                                    " convert it to a number. We need a number for the other
                                    " functions.
                                    let l:buffer = str2nr(l:key)
                            
                                    if l:buffer > 0
                                        " Stop all jobs and clear the results for everything, and delete
                                        " all of the data we stored for the buffer.
                                        call ale#engine#Cleanup(l:buffer)
                                    endif
                                endfor
                            endfunction
                            
    1              0.000002 function! ale#engine#ResetExecutableCache() abort
                                let s:executable_cache_map = {}
                            endfunction
                            
                            " Check if files are executable, and if they are, remember that they are
                            " for subsequent calls. We'll keep checking until programs can be executed.
    1              0.000002 function! ale#engine#IsExecutable(buffer, executable) abort
                                if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
                                let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
                                if l:result isnot v:null
                                    return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result
                            endfunction
                            
    1              0.000003 function! ale#engine#InitBufferInfo(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {
                                    \   'job_list': [],
                                    \   'active_linter_list': [],
                                    \   'active_other_sources_list': [],
                                    \   'loclist': [],
                                    \   'temporary_file_list': [],
                                    \   'temporary_directory_list': [],
                                    \}
                            
                                    return 1
                                endif
                            
                                return 0
                            endfunction
                            
                            " This function is documented and part of the public API.
                            "
                            " Return 1 if ALE is busy checking a given buffer
    1              0.000002 function! ale#engine#IsCheckingBuffer(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                return !empty(get(l:info, 'active_linter_list', []))
                                \   || !empty(get(l:info, 'active_other_sources_list', []))
                            endfunction
                            
                            " Register a temporary file to be managed with the ALE engine for
                            " a current job run.
    1              0.000002 function! ale#engine#ManageFile(buffer, filename) abort
                                call ale#engine#InitBufferInfo(a:buffer)
                                call add(g:ale_buffer_info[a:buffer].temporary_file_list, a:filename)
                            endfunction
                            
                            " Same as the above, but manage an entire directory.
    1              0.000003 function! ale#engine#ManageDirectory(buffer, directory) abort
                                call ale#engine#InitBufferInfo(a:buffer)
                                call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)
                            endfunction
                            
    1              0.000002 function! ale#engine#CreateFile(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP'
                                endif
                            
                                let l:temporary_file = ale#util#Tempname()
                                call ale#engine#ManageFile(a:buffer, l:temporary_file)
                            
                                return l:temporary_file
                            endfunction
                            
                            " Create a new temporary directory and manage it in one go.
    1              0.000002 function! ale#engine#CreateDirectory(buffer) abort
                                " This variable can be set to 1 in tests to stub this out.
                                if get(g:, 'ale_create_dummy_temporary_file')
                                    return 'TEMP_DIR'
                                endif
                            
                                let l:temporary_directory = ale#util#Tempname()
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                            
                                return l:temporary_directory
                            endfunction
                            
    1              0.000002 function! ale#engine#RemoveManagedFiles(buffer) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
                                if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
                                if has_key(l:info, 'temporary_file_list')
                                    for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    let l:info.temporary_file_list = []
                                endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
                                if has_key(l:info, 'temporary_directory_list')
                                    for l:directory in l:info.temporary_directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    let l:info.temporary_directory_list = []
                                endif
                            endfunction
                            
    1              0.000002 function! s:GatherOutput(job_id, line) abort
                                if has_key(s:job_info_map, a:job_id)
                                    call add(s:job_info_map[a:job_id].output, a:line)
                                endif
                            endfunction
                            
    1              0.000003 function! ale#engine#HandleLoclist(linter_name, buffer, loclist, from_other_source) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                if empty(l:info)
                                    return
                                endif
                            
                                if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
                                    call filter(l:info.active_linter_list, 'v:val isnot# a:linter_name')
                                endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
                                let l:linter_loclist = ale#engine#FixLocList(
                                \   a:buffer,
                                \   a:linter_name,
                                \   a:from_other_source,
                                \   a:loclist,
                                \)
                            
                                " Remove previous items for this linter.
                                call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
                                if !empty(l:linter_loclist)
                                    " Add the new items.
                                    call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
                                    call sort(l:info.loclist, 'ale#util#LocItemCompare')
                                endif
                            
                                if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                call ale#engine#SetResults(a:buffer, l:info.loclist)
                            endfunction
                            
    1              0.000002 function! s:HandleExit(job_id, exit_code) abort
                                if !has_key(s:job_info_map, a:job_id)
                                    return
                                endif
                            
                                let l:job_info = s:job_info_map[a:job_id]
                                let l:linter = l:job_info.linter
                                let l:output = l:job_info.output
                                let l:buffer = l:job_info.buffer
                                let l:executable = l:job_info.executable
                                let l:next_chain_index = l:job_info.next_chain_index
                            
                                if g:ale_history_enabled
                                    call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
                                endif
                            
                                " Remove this job from the list.
                                call ale#job#Stop(a:job_id)
                                call remove(s:job_info_map, a:job_id)
                                call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
                                call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
                                if ale#util#InSandbox()
                                    return
                                endif
                            
                                if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
                                if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:executable, l:linter, l:next_chain_index, l:output)
                            
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
                                if g:ale_history_enabled && g:ale_history_log_output
                                    call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
                                endif
                            
                                try
                                    let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
                                endtry
                            
                                call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist, 0)
                            endfunction
                            
    1              0.000002 function! ale#engine#SetResults(buffer, loclist) abort
                                let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
                                if g:ale_set_signs
                                    call ale#sign#SetSigns(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_quickfix || g:ale_set_loclist
                                    call ale#list#SetLists(a:buffer, a:loclist)
                                endif
                            
                                if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
                                if g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
                                endif
                            
                                if l:linting_is_done
                                    if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#cursor#EchoCursorWarning()
                                    endif
                            
                                    if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
                                    call setbufvar(
                                    \   a:buffer,
                                    \   'ale_linted',
                                    \   getbufvar(a:buffer, 'ale_linted', 0) + 1
                                    \)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
                                    call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
                                    silent doautocmd <nomodeline> User ALELintPost
                                endif
                            endfunction
                            
    1              0.000002 function! s:RemapItemTypes(type_map, loclist) abort
                                for l:item in a:loclist
                                    let l:key = l:item.type
                                    \   . (get(l:item, 'sub_type', '') is# 'style' ? 'S' : '')
                                    let l:new_key = get(a:type_map, l:key, '')
                            
                                    if l:new_key is# 'E'
                                    \|| l:new_key is# 'ES'
                                    \|| l:new_key is# 'W'
                                    \|| l:new_key is# 'WS'
                                    \|| l:new_key is# 'I'
                                        let l:item.type = l:new_key[0]
                            
                                        if l:new_key is# 'ES' || l:new_key is# 'WS'
                                            let l:item.sub_type = 'style'
                                        elseif has_key(l:item, 'sub_type')
                                            call remove(l:item, 'sub_type')
                                        endif
                                    endif
                                endfor
                            endfunction
                            
    1              0.000002 function! ale#engine#FixLocList(buffer, linter_name, from_other_source, loclist) abort
                                let l:bufnr_map = {}
                                let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
                                let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
                                for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
                                    let l:item = {
                                    \   'bufnr': a:buffer,
                                    \   'text': l:old_item.text,
                                    \   'lnum': str2nr(l:old_item.lnum),
                                    \   'col': str2nr(get(l:old_item, 'col', 0)),
                                    \   'vcol': 0,
                                    \   'type': get(l:old_item, 'type', 'E'),
                                    \   'nr': get(l:old_item, 'nr', -1),
                                    \   'linter_name': a:linter_name,
                                    \}
                            
                                    if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
                                    if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
                                    if has_key(l:old_item, 'filename')
                                    \&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
                                    if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
                                    if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
                                    if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
                                    if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
                                    if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line
                                            \   ? getbufline(a:buffer, l:item.end_lnum)[0]
                                            \   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
                                    call add(l:new_loclist, l:item)
                                endfor
                            
                                let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
                                if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
                                return l:new_loclist
                            endfunction
                            
                            " Given part of a command, replace any % with %%, so that no characters in
                            " the string will be replaced with filenames, etc.
    1              0.000003 function! ale#engine#EscapeCommandPart(command_part) abort
                                return substitute(a:command_part, '%', '%%', 'g')
                            endfunction
                            
    1              0.000002 function! s:CreateTemporaryFileForJob(buffer, temporary_file) abort
                                if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
                                let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
                                call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
                                call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
                                let l:lines = getbufline(a:buffer, 1, '$')
                                call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
                                return 1
                            endfunction
                            
                            " Run a job.
                            "
                            " Returns 1 when the job was started successfully.
    1              0.000002 function! s:RunJob(options) abort
                                let l:command = a:options.command
                            
                                if empty(l:command)
                                    return 0
                                endif
                            
                                let l:executable = a:options.executable
                                let l:buffer = a:options.buffer
                                let l:linter = a:options.linter
                                let l:output_stream = a:options.output_stream
                                let l:next_chain_index = a:options.next_chain_index
                                let l:read_buffer = a:options.read_buffer
                                let l:info = g:ale_buffer_info[l:buffer]
                            
                                let [l:temporary_file, l:command] = ale#command#FormatCommand(
                                \   l:buffer,
                                \   l:executable,
                                \   l:command,
                                \   l:read_buffer,
                                \)
                            
                                if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
                                    let l:read_buffer = 0
                                endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
                                if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
                                let l:command = ale#job#PrepareCommand(l:buffer, l:command)
                                let l:job_options = {
                                \   'mode': 'nl',
                                \   'exit_cb': function('s:HandleExit'),
                                \}
                            
                                if l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                else
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                endif
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
                                    let l:job_id = ale#job#Start(l:command, l:job_options)
                                endif
                            
                                let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
                                if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
                                    call add(l:info.job_list, l:job_id)
                            
                                    if index(l:info.active_linter_list, l:linter.name) < 0
                                        call add(l:info.active_linter_list, l:linter.name)
                                    endif
                            
                                    let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
                                    let s:job_info_map[l:job_id] = {
                                    \   'linter': l:linter,
                                    \   'buffer': l:buffer,
                                    \   'executable': l:executable,
                                    \   'output': [],
                                    \   'next_chain_index': l:next_chain_index,
                                    \}
                            
                                    silent doautocmd <nomodeline> User ALEJobStarted
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
                                endif
                            
                                if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(
                                    \   type(l:command) is v:t_list
                                    \   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])
                                    \   : l:command
                                    \)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
                                return l:job_id != 0
                            endfunction
                            
                            " Determine which commands to run for a link in a command chain, or
                            " just a regular command.
    1              0.000003 function! ale#engine#ProcessChain(buffer, linter, chain_index, input) abort
                                let l:output_stream = get(a:linter, 'output_stream', 'stdout')
                                let l:read_buffer = a:linter.read_buffer
                                let l:chain_index = a:chain_index
                                let l:input = a:input
                            
                                if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(
                                            \   a:buffer
                                            \)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(
                                            \   a:buffer,
                                            \   l:input
                                            \)
                                        endif
                            
                                        " If we have a command to run, execute that.
                                        if !empty(l:command)
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                else
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                endif
                            
                                return {
                                \   'command': l:command,
                                \   'buffer': a:buffer,
                                \   'linter': a:linter,
                                \   'output_stream': l:output_stream,
                                \   'next_chain_index': l:chain_index + 1,
                                \   'read_buffer': l:read_buffer,
                                \}
                            endfunction
                            
    1              0.000002 function! s:InvokeChain(buffer, executable, linter, chain_index, input) abort
                                let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                                let l:options.executable = a:executable
                            
                                return s:RunJob(l:options)
                            endfunction
                            
    1              0.000004 function! s:StopCurrentJobs(buffer, include_lint_file_jobs) abort
                                let l:info = get(g:ale_buffer_info, a:buffer, {})
                                let l:new_job_list = []
                                let l:new_active_linter_list = []
                            
                                for l:job_id in get(l:info, 'job_list', [])
                                    let l:job_info = get(s:job_info_map, l:job_id, {})
                            
                                    if !empty(l:job_info)
                                        if a:include_lint_file_jobs || !l:job_info.linter.lint_file
                                            call ale#job#Stop(l:job_id)
                                            call remove(s:job_info_map, l:job_id)
                                        else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
                                    endif
                                endfor
                            
                                " Remove duplicates from the active linter list.
                                call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
                                let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
                                let l:info.active_linter_list = l:new_active_linter_list
                            endfunction
                            
                            
    1              0.000002 function! s:RemoveProblemsForDisabledLinters(buffer, linters) abort
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
                                let l:name_map = {}
                            
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                call filter(
                                \   get(g:ale_buffer_info[a:buffer], 'loclist', []),
                                \   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',
                                \)
                            endfunction
                            
    1              0.000002 function! s:AddProblemsFromOtherBuffers(buffer, linters) abort
                                let l:filename = expand('#' . a:buffer . ':p')
                                let l:loclist = []
                                let l:name_map = {}
                            
                                " Build a map of the active linters.
                                for l:linter in a:linters
                                    let l:name_map[l:linter.name] = 1
                                endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
                                for l:info in values(g:ale_buffer_info)
                                    for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')
                                        \&& l:item.filename is# l:filename
                                        \&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
                                    endfor
                                endfor
                            
                                if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
                                endif
                            endfunction
                            
                            " Run a linter for a buffer.
                            "
                            " Returns 1 if the linter was successfully run.
    1              0.000002 function! s:RunLinter(buffer, linter) abort
                                if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
                                    let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
                                    if ale#engine#IsExecutable(a:buffer, l:executable)
                                        return s:InvokeChain(a:buffer, l:executable, a:linter, 0, [])
                                    endif
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000002 function! ale#engine#RunLinters(buffer, linters, should_lint_file) abort
                                " Initialise the buffer information if needed.
                                let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                                call s:StopCurrentJobs(a:buffer, a:should_lint_file)
                                call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
                                let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                silent doautocmd <nomodeline> User ALELintPre
                            
                                for l:linter in a:linters
                                    " Only run lint_file linters if we should.
                                    if !l:linter.lint_file || a:should_lint_file
                                        if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
                                        endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
                                endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
                                if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif
                            endfunction
                            
                            " Clean up a buffer.
                            "
                            " This function will stop all current jobs for the buffer,
                            " clear the state of everything, and remove the Dictionary for managing
                            " the buffer.
    1              0.000002 function! ale#engine#Cleanup(buffer) abort
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
                                if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)
                            endfunction
                            
                            " Given a buffer number, return the warnings and errors for a given buffer.
    1              0.000002 function! ale#engine#GetLoclist(buffer) abort
                                if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
                                return g:ale_buffer_info[a:buffer].loclist
                            endfunction
                            
                            " This function can be called with a timeout to wait for all jobs to finish.
                            " If the jobs to not finish in the given number of milliseconds,
                            " an exception will be thrown.
                            "
                            " The time taken will be a very rough approximation, and more time may be
                            " permitted than is specified.
    1              0.000002 function! ale#engine#WaitForJobs(deadline) abort
                                let l:start_time = ale#events#ClockMilliseconds()
                            
                                if l:start_time == 0
                                    throw 'Failed to read milliseconds from the clock!'
                                endif
                            
                                let l:job_list = []
                            
                                " Gather all of the jobs from every buffer.
                                for l:info in values(g:ale_buffer_info)
                                    call extend(l:job_list, get(l:info, 'job_list', []))
                                endfor
                            
                                " NeoVim has a built-in API for this, so use that.
                                if has('nvim')
                                    let l:nvim_code_list = jobwait(l:job_list, a:deadline)
                            
                                    if index(l:nvim_code_list, -1) >= 0
                                        throw 'Jobs did not complete on time!'
                                    endif
                            
                                    return
                                endif
                            
                                let l:should_wait_more = 1
                            
                                while l:should_wait_more
                                    let l:should_wait_more = 0
                            
                                    for l:job_id in l:job_list
                                        if ale#job#IsRunning(l:job_id)
                                            let l:now = ale#events#ClockMilliseconds()
                            
                                            if l:now - l:start_time > a:deadline
                                                " Stop waiting after a timeout, so we don't wait forever.
                                                throw 'Jobs did not complete on time!'
                                            endif
                            
                                            " Wait another 10 milliseconds
                                            let l:should_wait_more = 1
                                            sleep 10ms
                                            break
                                        endif
                                    endfor
                                endwhile
                            
                                " Sleep for a small amount of time after all jobs finish.
                                " This seems to be enough to let handlers after jobs end run, and
                                " prevents the occasional failure where this function exits after jobs
                                " end, but before handlers are run.
                                sleep 10ms
                            
                                " We must check the buffer data again to see if new jobs started
                                " for command_chain linters.
                                let l:has_new_jobs = 0
                            
                                " Check again to see if any jobs are running.
                                for l:info in values(g:ale_buffer_info)
                                    for l:job_id in get(l:info, 'job_list', [])
                                        if ale#job#IsRunning(l:job_id)
                                            let l:has_new_jobs = 1
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                if l:has_new_jobs
                                    " We have to wait more. Offset the timeout by the time taken so far.
                                    let l:now = ale#events#ClockMilliseconds()
                                    let l:new_deadline = a:deadline - (l:now - l:start_time)
                            
                                    if l:new_deadline <= 0
                                        " Enough time passed already, so stop immediately.
                                        throw 'Jobs did not complete on time!'
                                    endif
                            
                                    call ale#engine#WaitForJobs(l:new_deadline)
                                endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/history.vim
Sourced 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Tools for managing command history
                            
                            " A flag for controlling the maximum size of the command history to store.
    1              0.000008 let g:ale_max_buffer_history_size = get(g:, 'ale_max_buffer_history_size', 20)
                            
                            " Return a shallow copy of the command history for a given buffer number.
    1              0.000003 function! ale#history#Get(buffer) abort
                                return copy(getbufvar(a:buffer, 'ale_history', []))
                            endfunction
                            
    1              0.000002 function! ale#history#Add(buffer, status, job_id, command) abort
                                if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
                                let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
                                if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
                                endif
                            
                                call add(l:history, {
                                \   'status': a:status,
                                \   'job_id': a:job_id,
                                \   'command': a:command,
                                \})
                            
                                call setbufvar(a:buffer, 'ale_history', l:history)
                            endfunction
                            
    1              0.000002 function! s:FindHistoryItem(buffer, job_id) abort
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
                                for l:obj in reverse(ale#history#Get(a:buffer))
                                    if l:obj.job_id == a:job_id
                                        return l:obj
                                    endif
                                endfor
                            
                                return {}
                            endfunction
                            
                            " Set an exit code for a command which finished.
    1              0.000002 function! ale#history#SetExitCode(buffer, job_id, exit_code) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
                                let l:obj.exit_code = a:exit_code
                                let l:obj.status = 'finished'
                            endfunction
                            
                            " Set the output for a command which finished.
    1              0.000002 function! ale#history#RememberOutput(buffer, job_id, output) abort
                                let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                let l:obj.output = a:output
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/sign.vim
Sourced 1 time
Total time:   0.000482
 Self time:   0.000402

count  total (s)   self (s)
    1              0.000004 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Draws error and warning signs into signcolumn
                            
                            " This flag can be set to some integer to control the maximum number of signs
                            " that ALE will set.
    1              0.000007 let g:ale_max_signs = get(g:, 'ale_max_signs', -1)
                            " This flag can be set to 1 to enable changing the sign column colors when
                            " there are errors.
    1              0.000003 let g:ale_change_sign_column_color = get(g:, 'ale_change_sign_column_color', 0)
                            " These variables dictate what signs are used to indicate errors and warnings.
    1              0.000003 let g:ale_sign_error = get(g:, 'ale_sign_error', '>>')
    1              0.000003 let g:ale_sign_style_error = get(g:, 'ale_sign_style_error', g:ale_sign_error)
    1              0.000003 let g:ale_sign_warning = get(g:, 'ale_sign_warning', '--')
    1              0.000003 let g:ale_sign_style_warning = get(g:, 'ale_sign_style_warning', g:ale_sign_warning)
    1              0.000003 let g:ale_sign_info = get(g:, 'ale_sign_info', g:ale_sign_warning)
                            " This variable sets an offset which can be set for sign IDs.
                            " This ID can be changed depending on what IDs are set for other plugins.
                            " The dummy sign will use the ID exactly equal to the offset.
    1              0.000002 let g:ale_sign_offset = get(g:, 'ale_sign_offset', 1000000)
                            " This flag can be set to 1 to keep sign gutter always open
    1              0.000003 let g:ale_sign_column_always = get(g:, 'ale_sign_column_always', 0)
                            
    1              0.000007 if !hlexists('ALEErrorSign')
                                highlight link ALEErrorSign error
                            endif
                            
    1              0.000011 if !hlexists('ALEStyleErrorSign')
    1              0.000017     highlight link ALEStyleErrorSign ALEErrorSign
    1              0.000001 endif
                            
    1              0.000005 if !hlexists('ALEWarningSign')
                                highlight link ALEWarningSign todo
                            endif
                            
    1              0.000009 if !hlexists('ALEStyleWarningSign')
    1              0.000013     highlight link ALEStyleWarningSign ALEWarningSign
    1              0.000001 endif
                            
    1              0.000009 if !hlexists('ALEInfoSign')
    1              0.000013     highlight link ALEInfoSign ALEWarningSign
    1              0.000001 endif
                            
    1              0.000010 if !hlexists('ALESignColumnWithErrors')
    1              0.000015     highlight link ALESignColumnWithErrors error
    1              0.000001 endif
                            
    1              0.000003 function! ale#sign#SetUpDefaultColumnWithoutErrorsHighlight() abort
                                redir => l:output
                                    0verbose silent highlight SignColumn
                                redir end
                            
                                let l:highlight_syntax = join(split(l:output)[2:])
                                let l:match = matchlist(l:highlight_syntax, '\vlinks to (.+)$')
                            
                                if !empty(l:match)
                                    execute 'highlight link ALESignColumnWithoutErrors ' . l:match[1]
                                elseif l:highlight_syntax isnot# 'cleared'
                                    execute 'highlight ALESignColumnWithoutErrors ' . l:highlight_syntax
                                endif
                            endfunction
                            
    1              0.000009 if !hlexists('ALESignColumnWithoutErrors')
    1   0.000086   0.000006     call ale#sign#SetUpDefaultColumnWithoutErrorsHighlight()
    1              0.000001 endif
                            
                            " Signs show up on the left for error markers.
    1              0.000017 execute 'sign define ALEErrorSign text=' . g:ale_sign_error
                            \   . ' texthl=ALEErrorSign linehl=ALEErrorLine'
    1              0.000006 execute 'sign define ALEStyleErrorSign text=' . g:ale_sign_style_error
                            \   . ' texthl=ALEStyleErrorSign linehl=ALEErrorLine'
    1              0.000015 execute 'sign define ALEWarningSign text=' . g:ale_sign_warning
                            \   . ' texthl=ALEWarningSign linehl=ALEWarningLine'
    1              0.000006 execute 'sign define ALEStyleWarningSign text=' . g:ale_sign_style_warning
                            \   . ' texthl=ALEStyleWarningSign linehl=ALEWarningLine'
    1              0.000012 execute 'sign define ALEInfoSign text=' . g:ale_sign_info
                            \   . ' texthl=ALEInfoSign linehl=ALEInfoLine'
    1              0.000001 sign define ALEDummySign
                            
    1              0.000003 function! ale#sign#GetSignName(sublist) abort
                                let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
                                for l:item in a:sublist
                                    let l:item_priority = ale#util#GetItemPriority(l:item)
                            
                                    if l:item_priority > l:priority
                                        let l:priority = l:item_priority
                                    endif
                                endfor
                            
                                if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'
                            endfunction
                            
                            " Read sign data for a buffer to a list of lines.
    1              0.000004 function! ale#sign#ReadSigns(buffer) abort
                                redir => l:output
                                   silent execute 'sign place buffer=' . a:buffer
                                redir end
                            
                                return split(l:output, "\n")
                            endfunction
                            
                            " Given a list of lines for sign output, return a List of [line, id, group]
    1              0.000002 function! ale#sign#ParseSigns(line_list) abort
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
                                let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
                                let l:result = []
                                let l:is_dummy_sign_set = 0
                            
                                for l:line in a:line_list
                                    let l:match = matchlist(l:line, l:pattern)
                            
                                    if len(l:match) > 0
                                        if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
                                            call add(l:result, [
                                            \   str2nr(l:match[1]),
                                            \   str2nr(l:match[2]),
                                            \   l:match[3],
                                            \])
                                        endif
                                    endif
                                endfor
                            
                                return [l:is_dummy_sign_set, l:result]
                            endfunction
                            
    1              0.000002 function! ale#sign#FindCurrentSigns(buffer) abort
                                let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                return ale#sign#ParseSigns(l:line_list)
                            endfunction
                            
                            " Given a loclist, group the List into with one List per line.
    1              0.000002 function! s:GroupLoclistItems(buffer, loclist) abort
                                let l:grouped_items = []
                                let l:last_lnum = -1
                            
                                for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
                                endfor
                            
                                return l:grouped_items
                            endfunction
                            
    1              0.000002 function! s:UpdateLineNumbers(buffer, current_sign_list, loclist) abort
                                let l:line_map = {}
                                let l:line_numbers_changed = 0
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
                                for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
                                endfor
                            
                                " When the line numbers change, sort the list again
                                if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif
                            endfunction
                            
    1              0.000003 function! s:BuildSignMap(buffer, current_sign_list, grouped_items) abort
                                let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
                                if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
                                    let l:selected_grouped_items = a:grouped_items
                                endif
                            
                                let l:sign_map = {}
                                let l:sign_offset = g:ale_sign_offset
                            
                                for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {
                                    \   'current_id_list': [],
                                    \   'current_name_list': [],
                                    \   'new_id': 0,
                                    \   'new_name': '',
                                    \   'items': [],
                                    \})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(
                                    \   l:sign_info.current_name_list,
                                    \   l:sign_info.new_name
                                    \)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
                                return l:sign_map
                            endfunction
                            
    1              0.000003 function! ale#sign#GetSignCommands(buffer, was_sign_set, sign_map) abort
                                let l:command_list = []
                                let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
                                if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '
                                    \   .  g:ale_sign_offset
                                    \   . ' line=1 name=ALEDummySign buffer='
                                    \   . a:buffer
                                    \)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
                                for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '
                                            \   . (l:info.new_id)
                                            \   . ' line=' . l:line_str
                                            \   . ' name=' . (l:info.new_name)
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endif
                                endfor
                            
                                " Remove signs without new IDs.
                                for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '
                                            \   . l:current_id
                                            \   . ' buffer=' . a:buffer
                                            \)
                                        endif
                                    endfor
                                endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
                                if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '
                                    \   . g:ale_sign_offset
                                    \   . ' buffer=' . a:buffer
                                    \)
                                endif
                            
                                return l:command_list
                            endfunction
                            
                            " This function will set the signs which show up on the left.
    1              0.000002 function! ale#sign#SetSigns(buffer, loclist) abort
                                if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
                                let [l:is_dummy_sign_set, l:current_sign_list] =
                                \   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
                                call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
                                let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
                                let l:sign_map = s:BuildSignMap(
                                \   a:buffer,
                                \   l:current_sign_list,
                                \   l:grouped_items,
                                \)
                            
                                let l:command_list = ale#sign#GetSignCommands(
                                \   a:buffer,
                                \   l:is_dummy_sign_set,
                                \   l:sign_map,
                                \)
                            
                                " Change the sign column color if the option is on.
                                if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
                                for l:command in l:command_list
                                    silent! execute l:command
                                endfor
                            
                                " Reset the sign column color when there are no more errors.
                                if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/list.vim
Sourced 1 time
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
                            " Author: Bjorn Neergaard <bjorn@neersighted.com>, modified by Yann fery <yann@fery.me>
                            " Description: Manages the loclist and quickfix lists
                            
                            " This flag dictates if ale open the configured loclist
    1              0.000004 let g:ale_open_list = get(g:, 'ale_open_list', 0)
                            " This flag dictates if ale keeps open loclist even if there is no error in loclist
    1              0.000003 let g:ale_keep_list_window_open = get(g:, 'ale_keep_list_window_open', 0)
                            " This flag dictates that quickfix windows should be opened vertically
    1              0.000003 let g:ale_list_vertical = get(g:, 'ale_list_vertical', 0)
                            " The window size to set for the quickfix and loclist windows
    1              0.000003 let g:ale_list_window_size = get(g:, 'ale_list_window_size', 10)
                            " A string format for the loclist messages.
    1              0.000005 let g:ale_loclist_msg_format = get(g:, 'ale_loclist_msg_format',
                            \   get(g:, 'ale_echo_msg_format', '%code: %%s')
                            \)
                            
    1              0.000002 if !exists('s:timer_args')
    1              0.000002     let s:timer_args = {}
    1              0.000001 endif
                            
                            " Return 1 if there is a buffer with buftype == 'quickfix' in bufffer list
    1              0.000002 function! ale#list#IsQuickfixOpen() abort
                                for l:buf in range(1, bufnr('$'))
                                    if getbufvar(l:buf, '&buftype') is# 'quickfix'
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " Check if we should open the list, based on the save event being fired, and
                            " that setting being on, or the setting just being set to `1`.
    1              0.000002 function! s:ShouldOpen(buffer) abort
                                let l:val = ale#Var(a:buffer, 'open_list')
                                let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
                                return l:val is 1 || (l:val is# 'on_save' && l:saved)
                            endfunction
                            
    1              0.000002 function! ale#list#GetCombinedList() abort
                                let l:list = []
                            
                                for l:info in values(g:ale_buffer_info)
                                    call extend(l:list, l:info.loclist)
                                endfor
                            
                                call sort(l:list, function('ale#util#LocItemCompareWithText'))
                                call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
                                return l:list
                            endfunction
                            
    1              0.000002 function! s:FixList(buffer, list) abort
                                let l:format = ale#Var(a:buffer, 'loclist_msg_format')
                                let l:new_list = []
                            
                                for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
                                endfor
                            
                                return l:new_list
                            endfunction
                            
    1              0.000001 function! s:BufWinId(buffer) abort
                                return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0
                            endfunction
                            
    1              0.000002 function! s:SetListsImpl(timer_id, buffer, loclist) abort
                                let l:title = expand('#' . a:buffer . ':p')
                            
                                if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
                                    let l:id = s:BufWinId(a:buffer)
                            
                                    if has('nvim')
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                    else
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                        call setloclist(l:id, [], 'r', {'title': l:title})
                                    endif
                                endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
                                if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
                                if !ale#engine#IsCheckingBuffer(a:buffer)
                                    call s:CloseWindowIfNeeded(a:buffer)
                                endif
                            endfunction
                            
    1              0.000002 function! ale#list#SetLists(buffer, loclist) abort
                                if get(g:, 'ale_set_lists_synchronously') == 1
                                \|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
                                    call ale#util#StartPartialTimer(
                                    \   0,
                                    \   function('s:SetListsImpl'),
                                    \   [a:buffer, a:loclist],
                                    \)
                                endif
                            endfunction
                            
    1              0.000002 function! s:CloseWindowIfNeeded(buffer) abort
                                if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
                                    return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/highlight.vim
Sourced 1 time
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    1              0.000003 scriptencoding utf8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: This module implements error/warning highlighting.
                            
    1              0.000010 if !hlexists('ALEError')
    1              0.000018     highlight link ALEError SpellBad
    1              0.000001 endif
                            
    1              0.000009 if !hlexists('ALEStyleError')
    1              0.000009     highlight link ALEStyleError ALEError
    1              0.000001 endif
                            
    1              0.000009 if !hlexists('ALEWarning')
    1              0.000015     highlight link ALEWarning SpellCap
    1              0.000001 endif
                            
    1              0.000009 if !hlexists('ALEStyleWarning')
    1              0.000009     highlight link ALEStyleWarning ALEWarning
    1              0.000001 endif
                            
    1              0.000008 if !hlexists('ALEInfo')
    1              0.000009     highlight link ALEInfo ALEWarning
    1              0.000001 endif
                            
                            " The maximum number of items for the second argument of matchaddpos()
    1              0.000002 let s:MAX_POS_VALUES = 8
    1              0.000002 let s:MAX_COL_SIZE = 1073741824 " pow(2, 30)
                            
    1              0.000003 function! ale#highlight#CreatePositions(line, col, end_line, end_col) abort
                                if a:line >= a:end_line
                                    " For single lines, just return the one position.
                                    return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =
                                \   [[a:line, a:col, s:MAX_COL_SIZE]]
                                \   + range(a:line + 1, a:end_line - 1)
                                \   + [[a:end_line, 1, a:end_col]]
                            
                                return map(
                                \   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),
                                \   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',
                                \)
                            endfunction
                            
                            " Given a loclist for current items to highlight, remove all highlights
                            " except these which have matching loclist item entries.
    1              0.000002 function! ale#highlight#RemoveHighlights() abort
                                for l:match in getmatches()
                                    if l:match.group =~# '^ALE'
                                        call matchdelete(l:match.id)
                                    endif
                                endfor
                            endfunction
                            
    1              0.000002 function! ale#highlight#UpdateHighlights() abort
                                let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled
                                \   ? get(b:, 'ale_highlight_items', [])
                                \   : []
                            
                                call ale#highlight#RemoveHighlights()
                            
                                for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:line = l:item.lnum
                                    let l:col = l:item.col
                                    let l:end_line = get(l:item, 'end_lnum', l:line)
                                    let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
                                    call map(
                                    \   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),
                                    \   'matchaddpos(l:group, v:val)'
                                    \)
                                endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
                                if !g:ale_set_signs
                                    let l:available_groups = {
                                    \   'ALEWarningLine': hlexists('ALEWarningLine'),
                                    \   'ALEInfoLine': hlexists('ALEInfoLine'),
                                    \   'ALEErrorLine': hlexists('ALEErrorLine'),
                                    \}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif
                            endfunction
                            
    1              0.000002 function! ale#highlight#BufferHidden(buffer) abort
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
                                call ale#highlight#RemoveHighlights()
                            endfunction
                            
    1              0.000002 augroup ALEHighlightBufferGroup
    1              0.000028     autocmd!
    1              0.000006     autocmd BufEnter * call ale#highlight#UpdateHighlights()
    1              0.000005     autocmd BufHidden * call ale#highlight#BufferHidden(expand('<abuf>'))
    1              0.000001 augroup END
                            
    1              0.000003 function! ale#highlight#SetHighlights(buffer, loclist) abort
                                let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled
                                \   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')
                                \   : []
                            
                                " Set the list in the buffer variable.
                                call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
                                call ale#highlight#UpdateHighlights()
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/cursor.vim
Sourced 1 time
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            " Author: w0rp <devw0rp@gmail.com>
                            " Author: João Paulo S. de Souza <joao.paulo.silvasouza@hotmail.com>
                            " Description: Echoes lint message for the current line, if any
                            
                            " Controls the milliseconds delay before echoing a message.
    1              0.000004 let g:ale_echo_delay = get(g:, 'ale_echo_delay', 10)
                            " A string format for the echoed message.
    1              0.000003 let g:ale_echo_msg_format = get(g:, 'ale_echo_msg_format', '%code: %%s')
                            
    1              0.000002 let s:cursor_timer = -1
    1              0.000002 let s:last_pos = [0, 0, 0]
                            
    1              0.000003 function! ale#cursor#TruncatedEcho(original_message) abort
                                let l:message = a:original_message
                                " Change tabs to spaces.
                                let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
                                let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
                                let l:shortmess_options = &l:shortmess
                            
                                try
                                    let l:cursor_position = getcurpos()
                            
                                    " The message is truncated and saved to the history.
                                    setlocal shortmess+=T
                            
                                    try
                                        exec "norm! :echomsg l:message\n"
                                    catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
                                    if l:cursor_position != getcurpos()
                                        call setpos('.', l:cursor_position)
                                    endif
                                finally
                                    let &l:shortmess = l:shortmess_options
                                endtry
                            endfunction
                            
    1              0.000002 function! s:StopCursorTimer() abort
                                if s:cursor_timer != -1
                                    call timer_stop(s:cursor_timer)
                                    let s:cursor_timer = -1
                                endif
                            endfunction
                            
    1              0.000002 function! ale#cursor#EchoCursorWarning(...) abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if g:ale_echo_cursor
                                    if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
                                endif
                            
                                if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif
                            endfunction
                            
    1              0.000003 function! ale#cursor#EchoCursorWarningWithDelay() abort
                                let l:buffer = bufnr('')
                            
                                if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode(1) isnot# 'n'
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
                                if l:pos != s:last_pos
                                    let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
                                    let s:last_pos = l:pos
                                    let s:cursor_timer = timer_start(
                                    \   l:delay,
                                    \   function('ale#cursor#EchoCursorWarning')
                                    \)
                                endif
                            endfunction
                            
    1              0.000012 function! s:ShowCursorDetailForItem(loc, options) abort
                                let l:stay_here = get(a:options, 'stay_here', 0)
                            
                                let s:last_detailed_line = line('.')
                                let l:message = get(a:loc, 'detail', a:loc.text)
                                let l:lines = split(l:message, "\n")
                                call ale#preview#Show(l:lines, {'stay_here': l:stay_here})
                            
                                " Clear the echo message if we manually displayed details.
                                if !l:stay_here
                                    execute 'echo'
                                endif
                            endfunction
                            
    1              0.000002 function! ale#cursor#ShowCursorDetail() abort
                                let l:buffer = bufnr('')
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
                                if mode() isnot# 'n'
                                    return
                                endif
                            
                                if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
                                call s:StopCursorTimer()
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if !empty(l:loc)
                                    call s:ShowCursorDetailForItem(l:loc, {'stay_here': 0})
                                endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    1              0.000004 let s:t_string = type('')
                            
                            " Primary functions {{{
                            
    1              0.000003 function! gitgutter#all(force) abort
                              let visible = tabpagebuflist()
                            
                              for bufnr in range(1, bufnr('$') + 1)
                                if buflisted(bufnr)
                                  let file = expand('#'.bufnr.':p')
                                  if !empty(file)
                                    if index(visible, bufnr) != -1
                                      call gitgutter#init_buffer(bufnr)
                                      call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
                                    endif
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            
                            " Finds the file's path relative to the repo root.
    1              0.000002 function! gitgutter#init_buffer(bufnr)
                              if gitgutter#utility#is_active(a:bufnr)
                                let p = gitgutter#utility#repo_path(a:bufnr, 0)
                                if type(p) != s:t_string || empty(p)
                                  call gitgutter#utility#set_repo_path(a:bufnr)
                                  call s:setup_maps()
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#process_buffer(bufnr, force) abort
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
                              if gitgutter#utility#is_active(a:bufnr)
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = ''
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#disable() abort
                              " get list of all buffers (across all tabs)
                              for bufnr in range(1, bufnr('$') + 1)
                                if buflisted(bufnr)
                                  let file = expand('#'.bufnr.':p')
                                  if !empty(file)
                                    call s:clear(bufnr)
                                  endif
                                endif
                              endfor
                            
                              let g:gitgutter_enabled = 0
                            endfunction
                            
    1              0.000002 function! gitgutter#enable() abort
                              let g:gitgutter_enabled = 1
                              call gitgutter#all(1)
                            endfunction
                            
    1              0.000002 function! gitgutter#toggle() abort
                              if g:gitgutter_enabled
                                call gitgutter#disable()
                              else
                                call gitgutter#enable()
                              endif
                            endfunction
                            
                            " }}}
                            
    1              0.000002 function! s:setup_maps()
                              if !g:gitgutter_map_keys
                                return
                              endif
                            
                              if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>GitGutterPrevHunk
                              endif
                              if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>GitGutterNextHunk
                              endif
                            
                              if !hasmapto('<Plug>GitGutterStageHunk') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>GitGutterStageHunk
                              endif
                              if !hasmapto('<Plug>GitGutterUndoHunk') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>GitGutterUndoHunk
                              endif
                              if !hasmapto('<Plug>GitGutterPreviewHunk') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>GitGutterPreviewHunk
                              endif
                            
                              if !hasmapto('<Plug>GitGutterTextObjectInnerPending') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectOuterPending') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectInnerVisual') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectOuterVisual') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
                              endif
                            endfunction
                            
    1              0.000002 function! s:has_fresh_changes(bufnr) abort
                              return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')
                            endfunction
                            
    1              0.000001 function! s:reset_tick(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)
                            endfunction
                            
    1              0.000001 function! s:clear(bufnr)
                              call gitgutter#sign#clear_signs(a:bufnr)
                              call gitgutter#sign#remove_dummy_sign(a:bufnr, 1)
                              call gitgutter#hunk#reset(a:bufnr)
                              call s:reset_tick(a:bufnr)
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    1              0.000011 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000003 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                call job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000002 function! s:on_stderr_nvim(_job_id, _data, _event) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000002 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000001 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000002 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile
                            
                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    1              0.000008 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000003 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000002 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000002 let s:new_log_session = 1
                            
                            
    1              0.000003 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                              call s:option('shell')
                              call s:option('shellcmdflag')
                              call s:option('shellpipe')
                              call s:option('shellquote')
                              call s:option('shellredir')
                              call s:option('shellslash')
                              call s:option('shelltemp')
                              call s:option('shelltype')
                              call s:option('shellxescape')
                              call s:option('shellxquote')
                            endfunction
                            
                            
    1              0.000002 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000001 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000001 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000001 function! s:grep_version()
                              let v = system('grep --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system('grep --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000002 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000001 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000002 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000002 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.105640
 Self time:   0.000763

count  total (s)   self (s)
    1              0.000008 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000003 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'
                            
                            " True for git v1.7.2+.
    1              0.000004 function! s:git_supports_command_line_config_override() abort
                              call system(g:gitgutter_git_executable.' -c foo.bar=baz --version')
                              return !v:shell_error
                            endfunction
                            
    1   0.104894   0.000017 let s:c_flag = s:git_supports_command_line_config_override()
                            
                            
    1              0.000007 let s:temp_from = tempname()
    1              0.000003 let s:temp_buffer = tempname()
    1              0.000002 let s:counter = 0
                            
                            " Returns a diff of the buffer against the index or the working tree.
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
                            "
                            " When diffing against the index:
                            "
                            " The buffer contents is not the same as the file on disk so we need to pass
                            " two instances of the file to git-diff:
                            "
                            "     git diff myfileA myfileB
                            "
                            " where myfileA comes from
                            "
                            "     git show :myfile > myfileA
                            "
                            " and myfileB is the buffer contents.
                            "
                            " Regarding line endings:
                            "
                            " git-show does not convert line endings.
                            " git-diff FILE FILE does convert line endings for the given files.
                            "
                            " If a file has CRLF line endings and git's core.autocrlf is true,
                            " the file in git's object store will have LF line endings.  Writing
                            " it out via git-show will produce a file with LF line endings.
                            "
                            " If this last file is one of the files passed to git-diff, git-diff will
                            " convert its line endings to CRLF before diffing -- which is what we want --
                            " but also by default output a warning on stderr.
                            "
                            "   warning: LF will be replace by CRLF in <temp file>.
                            "   The file will have its original line endings in your working directory.
                            "
                            " When running the diff asynchronously, the warning message triggers the stderr
                            " callbacks which assume the overall command has failed and reset all the
                            " signs.  As this is not what we want, and we can safely ignore the warning,
                            " we turn it off by passing the '-c "core.safecrlf=false"' argument to
                            " git-diff.
                            "
                            " When writing the temporary files we preserve the original file's extension
                            " so that repos using .gitattributes to control EOL conversion continue to
                            " convert correctly.
                            "
                            " Arguments:
                            "
                            " bufnr              - the number of the buffer to be diffed
                            " from               - 'index' or 'working_tree'; what the buffer is diffed against
                            " preserve_full_diff - truthy to return the full diff or falsey to return only
                            "                      the hunk headers (@@ -x,y +m,n @@); only possible if
                            "                      grep is available.
    1              0.000008 function! gitgutter#diff#run_diff(bufnr, from, preserve_full_diff) abort
                              while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
                              let s:counter = (s:counter + 1) % 20
                              let buff_file .= '.'.s:counter
                            
                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)
                            
                              if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
                                let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                let from_file .= '.'.s:counter
                            
                                if !empty(extension)
                                  let from_file .= '.'.extension
                                endif
                            
                                " Write file from index to temporary file.
                                let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
                                let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
                              let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'
                            
                              let cmd .= ')'
                            
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {
                                      \   'out': function('gitgutter#diff#handler'),
                                      \   'err': function('gitgutter#hunk#reset'),
                                      \ })
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif
                            endfunction
                            
                            
    1              0.000004 function! gitgutter#diff#handler(bufnr, diff) abort
                              call gitgutter#debug#log(a:diff)
                            
                              if !bufexists(a:bufnr)
                                return
                              endif
                            
                              call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
                              let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
                              let signs_count = len(modified_lines)
                              if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf(
                                      \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
                                      \ signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
                                if g:gitgutter_signs || g:gitgutter_highlight_lines
                                  call gitgutter#sign#update_signs(a:bufnr, modified_lines)
                                endif
                              endif
                            
                              call s:save_last_seen_change(a:bufnr)
                              if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction
                            
    1              0.000003 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction
                            
                            " This function is public so it may be used by other plugins
                            " e.g. vim-signature.
    1              0.000003 function! gitgutter#diff#process_hunks(bufnr, hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
                              return modified_lines
                            endfunction
                            
                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000003 function! s:process_hunk(bufnr, hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]
                            
                              if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
                              return modifications
                            endfunction
                            
    1              0.000011 function! s:is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction
                            
    1              0.000002 function! s:is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction
                            
    1              0.000002 function! s:is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction
                            
    1              0.000002 function! s:is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction
                            
    1              0.000002 function! s:is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction
                            
    1              0.000003 function! s:process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction
                            
    1              0.000003 function! s:process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction
                            
    1              0.000003 function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction
                            
                            
                            " Returns a diff for the current hunk.
                            " Assumes there is only 1 current hunk unless the optional argument is given,
                            " in which case the cursor is in two hunks and the argument specifies the one
                            " to choose.
                            "
                            " Optional argument: 0 (to use the first hunk) or 1 (to use the second).
    1              0.000003 function! gitgutter#diff#hunk_diff(bufnr, full_diff, ...)
                              let modified_diff = []
                              let hunk_index = 0
                              let keep_line = 1
                              " Don't keepempty when splitting because the diff we want may not be the
                              " final one.  Instead add trailing NL at end of function.
                              for line in split(a:full_diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)
                            
                                  if a:0 && hunk_index != a:1
                                    let keep_line = 0
                                  endif
                            
                                  let hunk_index += 1
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                              return join(modified_diff, "\n")."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')
                            
                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
                              call writefile(bufcontents, a:file)
                            endfunction
                            
                            
    1              0.000003 function! s:save_last_seen_change(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
                            endfunction
                            
                            

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim
Sourced 1 time
Total time:   0.000859
 Self time:   0.000859

count  total (s)   self (s)
    1              0.000006 function! gitgutter#hunk#set_hunks(bufnr, hunks) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
    1              0.000004 function! gitgutter#hunk#hunks(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])
                            endfunction
                            
    1              0.000004 function! gitgutter#hunk#reset(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#hunk#summary(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000004 function! s:reset_summary(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000004 function! gitgutter#hunk#increment_lines_added(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[0] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000004 function! gitgutter#hunk#increment_lines_modified(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[1] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000004 function! gitgutter#hunk#increment_lines_removed(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[2] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#hunk#next_hunk(count) abort
                              let bufnr = bufnr('')
                              if gitgutter#utility#is_active(bufnr)
                                let current_line = line('.')
                                let hunk_count = 0
                                for hunk in gitgutter#hunk#hunks(bufnr)
                                  if hunk[2] > current_line
                                    let hunk_count += 1
                                    if hunk_count == a:count
                                      execute 'normal!' hunk[2] . 'Gzv'
                                      return
                                    endif
                                  endif
                                endfor
                                call gitgutter#utility#warn('No more hunks')
                              endif
                            endfunction
                            
    1              0.000004 function! gitgutter#hunk#prev_hunk(count) abort
                              let bufnr = bufnr('')
                              if gitgutter#utility#is_active(bufnr)
                                let current_line = line('.')
                                let hunk_count = 0
                                for hunk in reverse(copy(gitgutter#hunk#hunks(bufnr)))
                                  if hunk[2] < current_line
                                    let hunk_count += 1
                                    if hunk_count == a:count
                                      let target = hunk[2] == 0 ? 1 : hunk[2]
                                      execute 'normal!' target . 'Gzv'
                                      return
                                    endif
                                  endif
                                endfor
                                call gitgutter#utility#warn('No previous hunks')
                              endif
                            endfunction
                            
                            " Returns the hunk the cursor is currently in or an empty list if the cursor
                            " isn't in a hunk.
    1              0.000003 function! s:current_hunk() abort
                              let bufnr = bufnr('')
                              let current_hunk = []
                            
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  let current_hunk = hunk
                                  break
                                endif
                              endfor
                            
                              return current_hunk
                            endfunction
                            
                            " Returns truthy if the cursor is in two hunks (which can only happen if the
                            " cursor is on the first line and lines above have been deleted and lines
                            " immediately below have been deleted) or falsey otherwise.
    1              0.000003 function! s:cursor_in_two_hunks()
                              let hunks = gitgutter#hunk#hunks(bufnr(''))
                            
                              if line('.') == 1 && len(hunks) > 1 && hunks[0][2:3] == [0, 0] && hunks[1][2:3] == [1, 0]
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " A line can be in 0 or 1 hunks, with the following exception: when the first
                            " line(s) of a file has been deleted, and the new second line (and
                            " optionally below) has been deleted, the new first line is in two hunks.
    1              0.000004 function! gitgutter#hunk#cursor_in_hunk(hunk) abort
                              let current_line = line('.')
                            
                              if current_line == 1 && a:hunk[2] == 0
                                return 1
                              endif
                            
                              if current_line >= a:hunk[2] && current_line < a:hunk[2] + (a:hunk[3] == 0 ? 1 : a:hunk[3])
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#text_object(inner) abort
                              let hunk = s:current_hunk()
                            
                              if empty(hunk)
                                return
                              endif
                            
                              let [first_line, last_line] = [hunk[2], hunk[2] + hunk[3] - 1]
                            
                              if ! a:inner
                                let lnum = last_line
                                let eof = line('$')
                                while lnum < eof && empty(getline(lnum + 1))
                                  let lnum +=1
                                endwhile
                                let last_line = lnum
                              endif
                            
                              execute 'normal! 'first_line.'GV'.last_line.'G'
                            endfunction
                            
                            
    1              0.000003 function! gitgutter#hunk#stage() abort
                              call s:hunk_op(function('s:stage'))
                              silent! call repeat#set("\<Plug>GitGutterStageHunk", -1)<CR>
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#undo() abort
                              call s:hunk_op(function('s:undo'))
                              silent! call repeat#set("\<Plug>GitGutterUndoHunk", -1)<CR>
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#preview() abort
                              call s:hunk_op(function('s:preview'))
                              silent! call repeat#set("\<Plug>GitGutterPreviewHunk", -1)<CR>
                            endfunction
                            
                            
    1              0.000003 function! s:hunk_op(op)
                              let bufnr = bufnr('')
                            
                              if gitgutter#utility#is_active(bufnr)
                                " Get a (synchronous) diff.
                                let [async, g:gitgutter_async] = [g:gitgutter_async, 0]
                                let diff = gitgutter#diff#run_diff(bufnr, 'index', 1)
                                let g:gitgutter_async = async
                            
                                call gitgutter#hunk#set_hunks(bufnr, gitgutter#diff#parse_diff(diff))
                            
                                if empty(s:current_hunk())
                                  call gitgutter#utility#warn('cursor is not in a hunk')
                                elseif s:cursor_in_two_hunks()
                                  let choice = input('Choose hunk: upper or lower (u/l)? ')
                                  " Clear input
                                  normal! :<ESC>
                                  if choice =~ 'u'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 0))
                                  elseif choice =~ 'l'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 1))
                                  else
                                    call gitgutter#utility#warn('did not recognise your choice')
                                  endif
                                else
                                  call a:op(gitgutter#diff#hunk_diff(bufnr, diff))
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:stage(hunk_diff)
                              let bufnr = bufnr('')
                              let diff = s:adjust_header(bufnr, a:hunk_diff)
                              " Apply patch to index.
                              call gitgutter#utility#system(
                                    \ gitgutter#utility#cd_cmd(bufnr, g:gitgutter_git_executable.' apply --cached --unidiff-zero - '),
                                    \ diff)
                            
                              " Refresh gitgutter's view of buffer.
                              call gitgutter#process_buffer(bufnr, 1)
                            endfunction
                            
                            
    1              0.000002 function! s:undo(hunk_diff)
                              " Apply reverse patch to buffer.
                              let hunk  = gitgutter#diff#parse_hunk(split(a:hunk_diff, '\n')[4])
                              let lines = map(split(a:hunk_diff, '\n')[5:], 'v:val[1:]')
                              let lnum  = hunk[2]
                              let added_only   = hunk[1] == 0 && hunk[3]  > 0
                              let removed_only = hunk[1]  > 0 && hunk[3] == 0
                            
                              if removed_only
                                call append(lnum, lines)
                              elseif added_only
                                execute lnum .','. (lnum+len(lines)-1) .'d'
                              else
                                call append(lnum-1, lines[0:hunk[1]])
                                execute (lnum+hunk[1]) .','. (lnum+hunk[1]+hunk[3]) .'d'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:preview(hunk_diff)
                              let hunk_lines = split(s:discard_header(a:hunk_diff), "\n")
                              let hunk_lines_length = len(hunk_lines)
                              let previewheight = min([hunk_lines_length, &previewheight])
                            
                              silent! wincmd P
                              if !&previewwindow
                                noautocmd execute 'bo' previewheight 'new'
                                set previewwindow
                              else
                                execute 'resize' previewheight
                              endif
                            
                              setlocal noreadonly modifiable filetype=diff buftype=nofile bufhidden=delete noswapfile
                              execute "%delete_"
                              call append(0, hunk_lines)
                              normal! gg
                              setlocal readonly nomodifiable
                            
                              noautocmd wincmd p
                            endfunction
                            
                            
    1              0.000003 function! s:adjust_header(bufnr, hunk_diff)
                              let filepath = gitgutter#utility#repo_path(a:bufnr, 0)
                              return s:adjust_hunk_summary(s:fix_file_references(filepath, a:hunk_diff))
                            endfunction
                            
                            
                            " Replaces references to temp files with the actual file.
    1              0.000003 function! s:fix_file_references(filepath, hunk_diff)
                              let lines = split(a:hunk_diff, '\n')
                            
                              let left_prefix  = matchstr(lines[2], '[abciow12]').'/'
                              let right_prefix = matchstr(lines[3], '[abciow12]').'/'
                              let quote        = lines[0][11] == '"' ? '"' : ''
                            
                              let left_file  = quote.left_prefix.a:filepath.quote
                              let right_file = quote.right_prefix.a:filepath.quote
                            
                              let lines[0] = 'diff --git '.left_file.' '.right_file
                              let lines[2] = '--- '.left_file
                              let lines[3] = '+++ '.right_file
                            
                              return join(lines, "\n")."\n"
                            endfunction
                            
    1              0.000004 if $VIM_GITGUTTER_TEST
                              function! gitgutter#hunk#fix_file_references(filepath, hunk_diff)
                                return s:fix_file_references(a:filepath, a:hunk_diff)
                              endfunction
                            endif
                            
                            
    1              0.000002 function! s:adjust_hunk_summary(hunk_diff) abort
                              let line_adjustment = s:line_adjustment_for_current_hunk()
                              let diff = split(a:hunk_diff, '\n', 1)
                              let diff[4] = substitute(diff[4], '+\@<=\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                              return join(diff, "\n")
                            endfunction
                            
                            
    1              0.000002 function! s:discard_header(hunk_diff)
                              return join(split(a:hunk_diff, '\n', 1)[5:], "\n")
                            endfunction
                            
                            
                            " Returns the number of lines the current hunk is offset from where it would
                            " be if any changes above it in the file didn't exist.
    1              0.000003 function! s:line_adjustment_for_current_hunk() abort
                              let bufnr = bufnr('')
                              let adj = 0
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  break
                                else
                                  let adj += hunk[1] - hunk[3]
                                endif
                              endfor
                              return adj
                            endfunction
                            

SCRIPT  /home/greg/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.000463
 Self time:   0.000463

count  total (s)   self (s)
                            " Vim doesn't namespace sign ids so every plugin shares the same
                            " namespace.  Sign ids are simply integers so to avoid clashes with other
                            " signs we guess at a clear run.
                            "
                            " Note also we currently never reset s:next_sign_id.
    1              0.000004 let s:first_sign_id = 3000
    1              0.000003 let s:next_sign_id  = s:first_sign_id
    1              0.000003 let s:dummy_sign_id = s:first_sign_id - 1
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000005 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))
                            
                            
    1              0.000004 function! gitgutter#sign#enable() abort
                              let old_signs = g:gitgutter_signs
                            
                              let g:gitgutter_signs = 1
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !old_signs && !g:gitgutter_highlight_lines
                                call gitgutter#all(1)
                              endif
                            endfunction
                            
    1              0.000003 function! gitgutter#sign#disable() abort
                              let g:gitgutter_signs = 0
                              call gitgutter#highlight#define_sign_text_highlights()
                            
                              if !g:gitgutter_highlight_lines
                                call gitgutter#sign#clear_signs(bufnr(''))
                                call gitgutter#sign#remove_dummy_sign(bufnr(''), 0)
                              endif
                            endfunction
                            
    1              0.000003 function! gitgutter#sign#toggle() abort
                              if g:gitgutter_signs
                                call gitgutter#sign#disable()
                              else
                                call gitgutter#sign#enable()
                              endif
                            endfunction
                            
                            
                            " Removes gitgutter's signs (excluding dummy sign) from the buffer being processed.
    1              0.000003 function! gitgutter#sign#clear_signs(bufnr) abort
                              call s:find_current_signs(a:bufnr)
                            
                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
                            endfunction
                            
                            
                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000004 function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
                              if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
                              if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:add_dummy_sign(bufnr) abort
                              if !gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 1)
                              endif
                            endfunction
                            
    1              0.000004 function! gitgutter#sign#remove_dummy_sign(bufnr, force) abort
                              if gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
                                execute "sign unplace" s:dummy_sign_id "buffer=" . a:bufnr
                                call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 0)
                              endif
                            endfunction
                            
                            
                            "
                            " Internal functions
                            "
                            
                            
    1              0.000003 function! s:find_current_signs(bufnr) abort
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              let other_signs = []      " [<line_number (number),...]
                              let dummy_sign_placed = 0
                            
                              redir => signs
                                silent execute "sign place buffer=" . a:bufnr
                              redir END
                            
                              for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
                              call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
                              call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
                            endfunction
                            
                            
                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000004 function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction
                            
                            
    1              0.000003 function! s:remove_signs(bufnr, sign_ids, all_signs) abort
                              if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
                              let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              " Handle special case where the first line is the site of two hunks:
                              " lines deleted above at the start of the file, and lines deleted
                              " immediately below.
                              if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                let modified_lines = [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              else
                                let modified_lines = a:modified_lines
                              endif
                            
                              for line in modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction
                            
                            
    1              0.000002 function! s:next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction
                            
                            
                            " Only for testing.
    1              0.000003 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction
                            
                            
    1              0.000003 function! s:highlight_name_for_change(text) abort
                              if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif
                            endfunction
                            
                            

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/autoload/deoplete/init.vim
Sourced 1 time
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: init.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 if !exists('s:is_handler_enabled')
    1              0.000003   let s:is_handler_enabled = 0
    1              0.000001 endif
                            
    1              0.000004 function! deoplete#init#_is_handler_enabled() abort
                              return s:is_handler_enabled
                            endfunction
                            
    1              0.000003 function! deoplete#init#_initialize() abort
                              if exists('g:deoplete#_initialized')
                                return 1
                              endif
                            
                              let g:deoplete#_initialized = v:false
                            
                              call s:init_internal_variables()
                              call deoplete#init#_custom_variables()
                            
                              if deoplete#init#_channel()
                                return 1
                              endif
                            
                              call deoplete#mapping#_init()
                            endfunction
    1              0.000004 function! deoplete#init#_channel() abort
                              if !exists('g:deoplete#_serveraddr')
                                return 1
                              endif
                            
                              let python3 = get(g:, 'python3_host_prog', 'python3')
                              if !executable(python3)
                                call deoplete#util#print_error(
                                      \ string(python3) . ' is not executable.')
                                call deoplete#util#print_error(
                                      \ 'You need to set g:python3_host_prog.')
                              endif
                              if has('nvim') && !has('nvim-0.3.0')
                                call deoplete#util#print_error('deoplete requires nvim 0.3.0+.')
                                return 1
                              endif
                            
                              try
                                if deoplete#util#has_yarp()
                                  let g:deoplete#_yarp = yarp#py3('deoplete')
                                  call g:deoplete#_yarp.notify('deoplete_init')
                                else
                                  " rplugin.vim may not be loaded on VimEnter
                                  if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                            
                                  call _deoplete_init()
                                endif
                              catch
                                call deoplete#util#print_error(v:exception)
                                call deoplete#util#print_error(v:throwpoint)
                            
                                if !has('python3')
                                  call deoplete#util#print_error(
                                        \ 'deoplete requires Python3 support("+python3").')
                                endif
                            
                                if deoplete#util#has_yarp()
                                  echomsg string(expand('<sfile>'))
                                  if !exists('*yarp#py3')
                                    call deoplete#util#print_error(
                                          \ 'deoplete requires nvim-yarp plugin.')
                                  endif
                                else
                                  call deoplete#util#print_error(
                                      \ 'deoplete failed to load. '
                                      \ .'Try the :UpdateRemotePlugins command and restart Neovim. '
                                      \ .'See also :checkhealth.')
                                endif
                            
                                return 1
                              endtry
                            endfunction
    1              0.000004 function! deoplete#init#_channel_initialized() abort
                              return get(g:, 'deoplete#_initialized', v:false)
                            endfunction
    1              0.000003 function! deoplete#init#_enable_handler() abort
                              call deoplete#handler#_init()
                              let s:is_handler_enabled = 1
                            endfunction
    1              0.000003 function! deoplete#init#_disable_handler() abort
                              augroup deoplete
                                autocmd!
                              augroup END
                              let s:is_handler_enabled = 0
                            endfunction
                            
    1              0.000003 function! s:init_internal_variables() abort
                              call deoplete#init#_prev_completion()
                            
                              let g:deoplete#_context = {}
                            
                              if !exists('g:deoplete#_logging')
                                let g:deoplete#_logging = {}
                              endif
                              unlet! g:deoplete#_initialized
                              try
                                let g:deoplete#_serveraddr =
                                      \ deoplete#util#has_yarp() ?
                                      \ neovim_rpc#serveraddr() : v:servername
                                if g:deoplete#_serveraddr ==# ''
                                  " Use NVIM_LISTEN_ADDRESS
                                  let g:deoplete#_serveraddr = $NVIM_LISTEN_ADDRESS
                                endif
                              catch
                                if deoplete#util#has_yarp() && !exists('*neovim_rpc#serveraddr')
                                  call deoplete#util#print_error(
                                        \ 'deoplete requires vim-hug-neovim-rpc plugin in Vim.')
                                endif
                              endtry
                            endfunction
    1              0.000004 function! deoplete#init#_custom_variables() abort
                              if get(g:, 'deoplete#disable_auto_complete', v:false)
                                call deoplete#custom#option('auto_complete', v:false)
                              endif
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_complete_delay',
                                    \ 'auto_complete_delay')
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_refresh_delay',
                                    \ 'auto_refresh_delay')
                              call s:check_custom_option(
                                    \ 'g:deoplete#camel_case',
                                    \ 'camel_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#delimiters',
                                    \ 'delimiters')
                              call s:check_custom_option(
                                    \ 'g:deoplete#ignore_case',
                                    \ 'ignore_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#ignore_sources',
                                    \ 'ignore_sources')
                              call s:check_custom_option(
                                    \ 'g:deoplete#keyword_patterns',
                                    \ 'keyword_patterns')
                              call s:check_custom_option(
                                    \ 'g:deoplete#max_list',
                                    \ 'max_list')
                              call s:check_custom_option(
                                    \ 'g:deoplete#num_processes',
                                    \ 'num_processes')
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_complete_start_length',
                                    \ 'min_pattern_length')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_on_insert_enter',
                                    \ 'on_insert_enter')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_profile',
                                    \ 'profile')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_refresh_always',
                                    \ 'refresh_always')
                              call s:check_custom_option(
                                    \ 'g:deoplete#skip_chars',
                                    \ 'skip_chars')
                              call s:check_custom_option(
                                    \ 'g:deoplete#sources',
                                    \ 'sources')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_smart_case',
                                    \ 'smart_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_yarp',
                                    \ 'yarp')
                            
                              " Source variables
                              call s:check_custom_var('file',
                                    \ 'g:deoplete#file#enable_buffer_path',
                                    \ 'enable_buffer_path')
                              call s:check_custom_var('omni',
                                    \ 'g:deoplete#omni#input_patterns',
                                    \ 'input_patterns')
                              call s:check_custom_var('omni',
                                    \ 'g:deoplete#omni#functions',
                                    \ 'functions')
                            endfunction
                            
    1              0.000004 function! s:check_custom_var(source_name, old_var, new_var) abort
                              if exists(a:old_var)
                                call deoplete#custom#var(a:source_name, a:new_var, eval(a:old_var))
                              endif
                            endfunction
    1              0.000003 function! s:check_custom_option(old_var, new_var) abort
                              if exists(a:old_var)
                                call deoplete#custom#option(a:new_var, eval(a:old_var))
                              endif
                            endfunction
                            
    1              0.000003 function! deoplete#init#_option() abort
                              " Note: HTML omni func use search().
                              return {
                                    \ 'auto_complete': v:true,
                                    \ 'auto_complete_delay': 0,
                                    \ 'auto_refresh_delay': 20,
                                    \ 'camel_case': v:false,
                                    \ 'delimiters': ['/'],
                                    \ 'ignore_case': &ignorecase,
                                    \ 'ignore_sources': {},
                                    \ 'candidate_marks': [],
                                    \ 'max_list': 500,
                                    \ 'num_processes': 4,
                                    \ 'keyword_patterns': {'_': '[a-zA-Z_]\k*'},
                                    \ 'omni_patterns': {},
                                    \ 'on_insert_enter': v:true,
                                    \ 'on_text_changed_i': v:true,
                                    \ 'profile': v:false,
                                    \ 'min_pattern_length': 2,
                                    \ 'refresh_always': v:true,
                                    \ 'skip_chars': ['(', ')'],
                                    \ 'skip_multibyte': v:false,
                                    \ 'smart_case': &smartcase,
                                    \ 'sources': {},
                                    \ 'trigger_key': v:char,
                                    \ 'yarp': v:false,
                                    \ }
                            endfunction
    1              0.000004 function! deoplete#init#_prev_completion() abort
                              let g:deoplete#_prev_completion = {
                                    \ 'event': '',
                                    \ 'input': '',
                                    \ 'candidates': [],
                                    \ 'complete_position': -1,
                                    \ }
                            endfunction
                            
    1              0.000003 function! deoplete#init#_python_version_check() abort
                              python3 << EOF
                            import vim
                            import sys
                            vim.vars['deoplete#_python_version_check'] = (
                                sys.version_info.major,
                                sys.version_info.minor,
                                sys.version_info.micro) < (3, 5, 0)
                            EOF
                              return g:deoplete#_python_version_check
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/autoload/deoplete/util.vim
Sourced 1 time
Total time:   0.000567
 Self time:   0.000567

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000005 function! deoplete#util#print_error(string, ...) abort
                              let name = a:0 ? a:1 : 'deoplete'
                              echohl Error | echomsg printf('[%s] %s', name,
                                    \ deoplete#util#string(a:string)) | echohl None
                            endfunction
    1              0.000004 function! deoplete#util#print_warning(string) abort
                              echohl WarningMsg | echomsg '[deoplete] '
                                    \ . deoplete#util#string(a:string) | echohl None
                            endfunction
    1              0.000004 function! deoplete#util#print_debug(string) abort
                              echomsg '[deoplete] ' . deoplete#util#string(a:string)
                            endfunction
                            
    1              0.000003 function! deoplete#util#convert2list(expr) abort
                              return type(a:expr) ==# v:t_list ? a:expr : [a:expr]
                            endfunction
    1              0.000003 function! deoplete#util#string(expr) abort
                              return type(a:expr) ==# v:t_string ? a:expr : string(a:expr)
                            endfunction
                            
    1              0.000005 function! deoplete#util#get_input(event) abort
                              let mode = mode()
                              if a:event ==# 'InsertEnter'
                                let mode = 'i'
                              endif
                              let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?
                                    \      getline('.') :
                                    \      matchstr(getline('.'),
                                    \         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)
                                    \         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
                              if a:event ==# 'InsertCharPre'
                                let input .= v:char
                              endif
                            
                              return input
                            endfunction
    1              0.000003 function! deoplete#util#get_next_input(event) abort
                              return getline('.')[len(deoplete#util#get_input(a:event)) :]
                            endfunction
                            
    1              0.000003 function! deoplete#util#vimoption2python(option) abort
                              return '[\w' . s:vimoption2python(a:option) . ']'
                            endfunction
    1              0.000003 function! deoplete#util#vimoption2python_not(option) abort
                              return '[^\w' . s:vimoption2python(a:option) . ']'
                            endfunction
    1              0.000003 function! s:vimoption2python(option) abort
                              let has_dash = 0
                              let patterns = []
                              for pattern in split(a:option, ',')
                                if pattern =~# '\d\+'
                                  let pattern = substitute(pattern, '\d\+',
                                        \ '\=nr2char(submatch(0))', 'g')
                                endif
                            
                                if pattern ==# ''
                                  " ,
                                  call add(patterns, ',')
                                elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
                                  let has_dash = 1
                                else
                                  call add(patterns, pattern)
                                endif
                              endfor
                            
                              " Dash must be last.
                              if has_dash
                                call add(patterns, '-')
                              endif
                            
                              return join(deoplete#util#uniq(patterns), '')
                            endfunction
                            
    1              0.000004 function! deoplete#util#uniq(list) abort
                              let list = map(copy(a:list), '[v:val, v:val]')
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction
                            
    1              0.000003 function! deoplete#util#get_syn_names() abort
                              if col('$') >= 200
                                return []
                              endif
                            
                              let names = []
                              try
                                " Note: synstack() seems broken in concealed text.
                                for id in synstack(line('.'), (mode() ==# 'i' ? col('.')-1 : col('.')))
                                  let name = synIDattr(id, 'name')
                                  call add(names, name)
                                  if synIDattr(synIDtrans(id), 'name') !=# name
                                    call add(names, synIDattr(synIDtrans(id), 'name'))
                                  endif
                                endfor
                              catch
                                " Ignore error
                              endtry
                              return names
                            endfunction
                            
    1              0.000003 function! deoplete#util#neovim_version() abort
                              redir => v
                              silent version
                              redir END
                              return split(v, '\n')[0]
                            endfunction
                            
    1              0.000003 function! deoplete#util#has_yarp() abort
                              return !has('nvim') || deoplete#custom#_get_option('yarp')
                            endfunction
                            
    1              0.000004 function! deoplete#util#get_context_filetype(input, event) abort
                              if !exists('s:context_filetype')
                                let s:context_filetype = {}
                            
                                " Force context_filetype call.
                                try
                                  call context_filetype#get_filetype()
                                catch
                                  " Ignore error
                                endtry
                              endif
                            
                              if empty(s:context_filetype)
                                    \ || s:context_filetype.prev_filetype !=# &filetype
                                    \ || s:context_filetype.line != line('.')
                                    \ || s:context_filetype.bufnr != bufnr('%')
                                    \ || (a:input =~# '\W$' &&
                                    \     substitute(a:input, '\s\zs\s\+$', '', '') !=#
                                    \     substitute(s:context_filetype.input, '\s\zs\s\+$', '', ''))
                                    \ || (a:input =~# '\w$' &&
                                    \     substitute(a:input, '\w\+$', '', '') !=#
                                    \     substitute(s:context_filetype.input, '\w\+$', '', ''))
                                    \ || a:event ==# 'InsertEnter'
                            
                                let s:context_filetype.line = line('.')
                                let s:context_filetype.bufnr = bufnr('%')
                                let s:context_filetype.input = a:input
                                let s:context_filetype.prev_filetype = &filetype
                                let s:context_filetype.filetype =
                                      \ (exists('*context_filetype#get_filetype') ?
                                      \   context_filetype#get_filetype() :
                                      \   (&filetype ==# '' ? 'nothing' : &filetype))
                                let s:context_filetype.filetypes =
                                      \ exists('*context_filetype#get_filetypes') ?
                                      \   context_filetype#get_filetypes() :
                                      \   &filetype ==# '' ? ['nothing'] :
                                      \                     deoplete#util#uniq([&filetype]
                                      \                          + split(&filetype, '\.'))
                                let s:context_filetype.same_filetypes =
                                      \ exists('*context_filetype#get_same_filetypes') ?
                                      \   context_filetype#get_same_filetypes() : []
                              endif
                              return [ s:context_filetype.filetype,
                                    \  s:context_filetype.filetypes, s:context_filetype.same_filetypes]
                            endfunction
                            
    1              0.000004 function! deoplete#util#get_keyword_pattern(filetype) abort
                              let keyword_patterns = deoplete#custom#_get_option('keyword_patterns')
                              if empty(keyword_patterns)
                                let patterns = deoplete#custom#_get_filetype_option(
                                    \   'keyword_patterns', a:filetype, '')
                              else
                                let filetype = has_key(keyword_patterns, a:filetype) ? a:filetype : '_'
                                let patterns = get(keyword_patterns, filetype, '')
                              endif
                              let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
                              let k_pattern = deoplete#util#vimoption2python(
                                    \ &l:iskeyword . (&l:lisp ? ',-' : ''))
                              return substitute(pattern, '\\k', '\=k_pattern', 'g')
                            endfunction
                            
    1              0.000003 function! deoplete#util#rpcnotify(event, context) abort
                              if !deoplete#init#_channel_initialized()
                                return ''
                              endif
                            
                              let a:context['rpc'] = a:event
                            
                              if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:event, a:context)
                              else
                                call rpcnotify(g:deoplete#_channel_id, a:event, a:context)
                              endif
                            
                              return ''
                            endfunction
                            
                            " Compare versions.  Return values is the distance between versions.  Each
                            " version integer (from right to left) is an ascending power of 100.
                            "
                            " Example:
                            " '0.1.10' is (1 * 100) + 10, or 110.
                            " '1.2.3' is (1 * 10000) + (2 * 100) + 3, or 10203.
                            "
                            " Returns:
                            " <0 if a < b
                            " >0 if a > b
                            " 0 if versions are equal.
    1              0.000005 function! deoplete#util#versioncmp(a, b) abort
                              let a = map(split(a:a, '\.'), 'str2nr(v:val)')
                              let b = map(split(a:b, '\.'), 'str2nr(v:val)')
                              let l = min([len(a), len(b)])
                              let d = 0
                            
                              " Only compare the parts that are common to both versions.
                              for i in range(l)
                                let d += (a[i] - b[i]) * pow(100, l - i - 1)
                              endfor
                            
                              return d
                            endfunction
                            
    1              0.000003 function! deoplete#util#split(string) abort
                              return split(a:string, '\s*,\s*')
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/autoload/deoplete/custom.vim
Sourced 1 time
Total time:   0.000571
 Self time:   0.000571

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: custom.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 function! deoplete#custom#_init() abort
                              let s:custom = {}
                              let s:custom.source = {}
                              let s:custom.source._ = {}
                              let s:custom.option = deoplete#init#_option()
                            endfunction
    1              0.000004 function! deoplete#custom#_init_buffer() abort
                              let b:custom = {}
                              let b:custom.option = {}
                              let b:custom.source_vars = {}
                            endfunction
                            
    1              0.000003 function! deoplete#custom#_get() abort
                              if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
                              return s:custom
                            endfunction
    1              0.000003 function! deoplete#custom#_get_buffer() abort
                              if !exists('b:custom')
                                call deoplete#custom#_init_buffer()
                              endif
                            
                              return b:custom
                            endfunction
                            
    1              0.000005 function! deoplete#custom#_get_source(source_name) abort
                              let custom = deoplete#custom#_get().source
                            
                              if !has_key(custom, a:source_name)
                                let custom[a:source_name] = {}
                              endif
                            
                              return custom[a:source_name]
                            endfunction
    1              0.000005 function! deoplete#custom#_get_option(name) abort
                              if has_key(deoplete#custom#_get_buffer().option, a:name)
                                return deoplete#custom#_get_buffer().option[a:name]
                              endif
                              return deoplete#custom#_get().option[a:name]
                            endfunction
    1              0.000007 function! deoplete#custom#_get_filetype_option(name, filetype, default) abort
                              let buffer_option = deoplete#custom#_get_buffer().option
                              if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
                              let option = deoplete#custom#_get_option(a:name)
                              let filetype = has_key(option, a:filetype) ? a:filetype : '_'
                              return get(option, filetype, a:default)
                            endfunction
    1              0.000006 function! deoplete#custom#_get_source_vars(name) abort
                              let global_vars = get(deoplete#custom#_get_source(a:name), 'vars', {})
                              let buffer_vars = get(deoplete#custom#_get_buffer().source_vars,
                                    \ a:name, {})
                              return extend(copy(global_vars), buffer_vars)
                            endfunction
                            
    1              0.000006 function! deoplete#custom#source(source_name, name_or_dict, ...) abort
                              for key in deoplete#util#split(a:source_name)
                                let custom_source = deoplete#custom#_get_source(key)
                                call s:set_custom(custom_source, a:name_or_dict, get(a:000, 0, ''))
                              endfor
                            endfunction
                            
    1              0.000005 function! deoplete#custom#var(source_name, name_or_dict, ...) abort
                              for key in deoplete#util#split(a:source_name)
                                let custom_source = deoplete#custom#_get_source(key)
                                let vars = get(custom_source, 'vars', {})
                                call s:set_custom(vars, a:name_or_dict, get(a:000, 0, ''))
                                call deoplete#custom#source(key, 'vars', vars)
                              endfor
                            endfunction
    1              0.000019 function! deoplete#custom#buffer_var(source_name, name_or_dict, ...) abort
                              let custom = deoplete#custom#_get_buffer().source_vars
                              for key in deoplete#util#split(a:source_name)
                                if !has_key(custom, key)
                                  let custom[key] = {}
                                endif
                                let vars = custom[key]
                                call s:set_custom(vars, a:name_or_dict, get(a:000, 0, ''))
                              endfor
                            endfunction
                            
    1              0.000005 function! deoplete#custom#option(name_or_dict, ...) abort
                              let custom = deoplete#custom#_get().option
                              call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))
                            endfunction
    1              0.000016 function! deoplete#custom#buffer_option(name_or_dict, ...) abort
                              let custom = deoplete#custom#_get_buffer().option
                              call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))
                            endfunction
                            
    1              0.000006 function! s:set_custom(dest, name_or_dict, value) abort
                              if type(a:name_or_dict) == v:t_dict
                                call extend(a:dest, a:name_or_dict)
                              else
                                call s:set_value(a:dest, a:name_or_dict, a:value)
                              endif
                            endfunction
    1              0.000005 function! s:set_value(dest, name, value) abort
                              if type(a:value) == v:t_dict && !empty(a:value)
                                if !has_key(a:dest, a:name)
                                  let a:dest[a:name] = {}
                                endif
                                call extend(a:dest[a:name], a:value)
                              else
                                let a:dest[a:name] = a:value
                              endif
                            endfunction

SCRIPT  /usr/share/nvim/runtime/autoload/provider/pythonx.vim
Sourced 1 time
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
                            " The Python provider helper
    1              0.000007 if exists('s:loaded_pythonx_provider')
                              finish
                            endif
                            
    1              0.000005 let s:loaded_pythonx_provider = 1
                            
    1              0.000006 function! provider#pythonx#Require(host) abort
                              let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
                              let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
                              let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
                              let python_plugins = remote#host#PluginsForHost(a:host.name)
                              for plugin in python_plugins
                                call add(args, plugin.path)
                              endfor
                            
                              return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')
                            endfunction
                            
    1              0.000006 function! provider#pythonx#Detect(major_ver) abort
                              if a:major_ver == 2
                                if exists('g:python_host_prog')
                                  return [g:python_host_prog, '']
                                else
                                  let progs = ['python2', 'python2.7', 'python2.6', 'python']
                                endif
                              else
                                if exists('g:python3_host_prog')
                                  return [g:python3_host_prog, '']
                                else
                                  let progs = ['python3', 'python3.7', 'python3.6', 'python3.5',
                                        \ 'python3.4', 'python3.3', 'python']
                                endif
                              endif
                            
                              let errors = []
                            
                              for prog in progs
                                let [result, err] = s:check_interpreter(prog, a:major_ver)
                                if result
                                  return [prog, err]
                                endif
                                " Accumulate errors in case we don't find
                                " any suitable Python interpreter.
                                call add(errors, err)
                              endfor
                            
                              " No suitable Python interpreter found.
                              return ['', 'provider/pythonx: Could not load Python ' . a:major_ver
                                    \ . ":\n" .  join(errors, "\n")]
                            endfunction
                            
    1              0.000006 function! s:check_interpreter(prog, major_ver) abort
                              let prog_path = exepath(a:prog)
                              if prog_path ==# ''
                                return [0, a:prog . ' not found in search path or not executable.']
                              endif
                            
                              let min_version = (a:major_ver == 2) ? '2.6' : '3.3'
                            
                              " Try to load neovim module, and output Python version.
                              " Return codes:
                              "   0  Neovim module can be loaded.
                              "   2  Neovim module cannot be loaded.
                              "   Otherwise something else went wrong (e.g. 1 or 127).
                              let prog_ver = system([ a:prog , '-c' ,
                                    \ 'import sys; ' .
                                    \ 'sys.path.remove(""); ' .
                                    \ 'sys.stdout.write(str(sys.version_info[0]) + "." + str(sys.version_info[1])); ' .
                                    \ 'import pkgutil; ' .
                                    \ 'exit(2*int(pkgutil.get_loader("neovim") is None))'
                                    \ ])
                            
                              if v:shell_error == 2 || v:shell_error == 0
                                " Check version only for expected return codes.
                                if prog_ver !~ '^' . a:major_ver
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python '
                                        \ . a:major_ver . '.']
                                elseif prog_ver =~ '^' . a:major_ver && prog_ver < min_version
                                  return [0, prog_path . ' is Python ' . prog_ver . ' and cannot provide Python >= '
                                        \ . min_version . '.']
                                endif
                              endif
                            
                              if v:shell_error == 2
                                return [0, prog_path.' does not have the "neovim" module. :help provider-python']
                              elseif v:shell_error == 127
                                " This can happen with pyenv's shims.
                                return [0, prog_path . ' does not exist: ' . prog_ver]
                              elseif v:shell_error
                                return [0, 'Checking ' . prog_path . ' caused an unknown error. '
                                      \ . '(' . v:shell_error . ', output: ' . prog_ver . ')'
                                      \ . ' Report this at https://github.com/neovim/neovim']
                              endif
                            
                              return [1, '']
                            endfunction

SCRIPT  /usr/share/nvim/runtime/autoload/provider/python3.vim
Sourced 1 time
Total time:   0.031079
 Self time:   0.000172

count  total (s)   self (s)
                            " The Python3 provider uses a Python3 host to emulate an environment for running
                            " python3 plugins. :help provider
                            "
                            " Associating the plugin with the Python3 host is the first step because
                            " plugins will be passed as command-line arguments
                            
    1              0.000006 if exists('g:loaded_python3_provider')
                              finish
                            endif
    1              0.000004 let g:loaded_python3_provider = 1
                            
    1   0.030830   0.000011 let [s:prog, s:err] = provider#pythonx#Detect(3)
                            
    1              0.000005 function! provider#python3#Prog() abort
                              return s:prog
                            endfunction
                            
    1              0.000003 function! provider#python3#Error() abort
                              return s:err
                            endfunction
                            
    1              0.000002 if s:prog == ''
                              " Detection failed
                              finish
                            endif
                            
                            " The Python3 provider plugin will run in a separate instance of the Python3
                            " host.
    1   0.000031   0.000013 call remote#host#RegisterClone('legacy-python3-provider', 'python3')
    1   0.000076   0.000006 call remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])
                            
    1              0.000003 function! provider#python3#Call(method, args) abort
                              if s:err != ''
                                return
                              endif
                              if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
                            endfunction

SCRIPT  /usr/share/nvim/runtime/autoload/provider.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            " Common functions for providers
                            
                            " Start the provider and perform a 'poll' request
                            "
                            " Returns a valid channel on success
    1              0.000005 function! provider#Poll(argv, orig_name, log_env) abort
                              let job = {'rpc': v:true, 'stderr_buffered': v:true}
                              try
                                let channel_id = jobstart(a:argv, job)
                                if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
                                  return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
                              endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/autoload/deoplete/mapping.vim
Sourced 1 time
Total time:   0.000277
 Self time:   0.000277

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: mapping.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 function! deoplete#mapping#_init() abort
                              " Note: The dummy function is needed for cpoptions bug in neovim
                              inoremap <expr><silent> <Plug>_ deoplete#mapping#_dummy_complete()
                            endfunction
                            
    1              0.000003 function! deoplete#mapping#_dummy_complete() abort
                              return "\<C-r>=deoplete#mapping#_complete()\<CR>"
                            endfunction
    1              0.000003 function! deoplete#mapping#_completefunc(findstart, base) abort
                              if a:findstart
                                return g:deoplete#_context.complete_position
                              else
                                return g:deoplete#_context.candidates
                              endif
                            endfunction
    1              0.000003 function! deoplete#mapping#_complete() abort
                              call complete(g:deoplete#_context.complete_position + 1,
                                    \ g:deoplete#_context.candidates)
                            
                              return ''
                            endfunction
    1              0.000003 function! deoplete#mapping#_set_completeopt() abort
                              if exists('g:deoplete#_saved_completeopt')
                                return
                              endif
                              let g:deoplete#_saved_completeopt = &completeopt
                              set completeopt-=longest
                              set completeopt+=menuone
                              set completeopt-=menu
                              if &completeopt !~# 'noinsert\|noselect'
                                set completeopt+=noselect
                              endif
                            endfunction
    1              0.000003 function! deoplete#mapping#_restore_completeopt() abort
                              if exists('g:deoplete#_saved_completeopt')
                                let &completeopt = g:deoplete#_saved_completeopt
                                unlet g:deoplete#_saved_completeopt
                              endif
                            endfunction
    1              0.000003 function! deoplete#mapping#_rpcrequest_wrapper(sources) abort
                              return deoplete#util#rpcnotify(
                                    \ 'deoplete_manual_completion_begin',
                                    \ {
                                    \  'event': 'Manual',
                                    \  'sources': deoplete#util#convert2list(a:sources)
                                    \ })
                            endfunction
    1              0.000003 function! deoplete#mapping#_undo_completion() abort
                              if empty(v:completed_item)
                                return ''
                              endif
                            
                              let input = deoplete#util#get_input('')
                              if strridx(input, v:completed_item.word) !=
                                    \ len(input) - len(v:completed_item.word)
                                return ''
                              endif
                            
                              return deoplete#smart_close_popup() .
                                    \  repeat("\<C-h>", strchars(v:completed_item.word))
                            endfunction
    1              0.000003 function! deoplete#mapping#_complete_common_string() abort
                              if !deoplete#is_enabled()
                                return ''
                              endif
                            
                              " Get cursor word.
                              let complete_str = matchstr(deoplete#util#get_input(''), '\w*$')
                            
                              if complete_str ==# '' || !has_key(g:deoplete#_context, 'candidates')
                                return ''
                              endif
                            
                              let candidates = filter(copy(g:deoplete#_context.candidates),
                                    \ 'stridx(tolower(v:val.word), tolower(complete_str)) == 0')
                            
                              if empty(candidates)
                                return ''
                              endif
                            
                              let common_str = candidates[0].word
                              for candidate in candidates[1:]
                                while stridx(tolower(candidate.word), tolower(common_str)) != 0
                                  let common_str = common_str[: -2]
                                endwhile
                              endfor
                            
                              if common_str ==# '' || complete_str ==? common_str
                                return ''
                              endif
                            
                              return (pumvisible() ? "\<C-e>" : '')
                                    \ . repeat("\<BS>", strchars(complete_str)) . common_str
                            endfunction
    1              0.000003 function! deoplete#mapping#_insert_candidate(number) abort
                              let prev = g:deoplete#_prev_completion
                              let candidates = get(prev, 'candidates', [])
                              let word = get(candidates, a:number, {'word': ''}).word
                              if word ==# ''
                                return ''
                              endif
                            
                              " Get cursor word.
                              let complete_str = prev.input[prev.complete_position :]
                              return (pumvisible() ? "\<C-e>" : '')
                                    \ . repeat("\<BS>", strchars(complete_str)) . word
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/deoplete.nvim/autoload/deoplete/handler.vim
Sourced 1 time
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: handler.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#handler#_init() abort
                              augroup deoplete
                                autocmd!
                                autocmd InsertLeave * call s:on_insert_leave()
                                autocmd CompleteDone * call s:on_complete_done()
                                autocmd InsertLeave * call s:completion_timer_stop()
                              augroup END
                            
                              for event in ['InsertEnter', 'BufReadPost', 'BufWritePost', 'BufDelete']
                                call s:define_on_event(event)
                              endfor
                            
                              if deoplete#custom#_get_option('on_text_changed_i')
                                call s:define_completion_via_timer('TextChangedI')
                              endif
                              if deoplete#custom#_get_option('on_insert_enter')
                                call s:define_completion_via_timer('InsertEnter')
                              endif
                              if deoplete#custom#_get_option('refresh_always')
                                if exists('##TextChangedP')
                                  call s:define_completion_via_timer('TextChangedP')
                                endif
                                call s:define_completion_via_timer('InsertCharPre')
                              endif
                            
                              " Note: Vim 8 GUI(MacVim and Win32) is broken
                              " dummy timer call is needed before complete()
                              if !has('nvim') && has('gui_running')
                                    \ && (has('gui_macvim') || has('win32'))
                                let s:dummy_timer = timer_start(200, {timer -> 0}, {'repeat': -1})
                              endif
                            
                              if deoplete#util#has_yarp()
                                " To fix "RuntimeError: Event loop is closed" issue
                                " Note: Workaround
                                autocmd deoplete VimLeavePre * call s:kill_yarp()
                              endif
                            
                              let s:check_insert_charpre = v:false
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_do_complete() abort
                              let context = g:deoplete#_context
                              let event = get(context, 'event', '')
                              let modes = (event ==# 'InsertEnter') ? ['n', 'i'] : ['i']
                              if s:is_exiting() || index(modes, mode()) < 0
                                call s:completion_timer_stop()
                                return
                              endif
                            
                              if empty(get(context, 'candidates', []))
                                    \ || deoplete#util#get_input(context.event) !=# context.input
                                return
                              endif
                            
                              let prev = g:deoplete#_prev_completion
                              let prev.event = context.event
                              let prev.input = context.input
                              let prev.candidates = context.candidates
                              let prev.complete_position = context.complete_position
                            
                              if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt')
                                call deoplete#mapping#_set_completeopt()
                              endif
                            
                              call feedkeys("\<Plug>_", 'i')
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_check_omnifunc(context) abort
                              let prev = g:deoplete#_prev_completion
                              let blacklist = ['LanguageClient#complete']
                              if a:context.event ==# 'Manual'
                                    \ || &l:omnifunc ==# ''
                                    \ || index(blacklist, &l:omnifunc) >= 0
                                    \ || prev.input ==# a:context.input
                                return
                              endif
                            
                              for filetype in a:context.filetypes
                                for pattern in deoplete#util#convert2list(
                                      \ deoplete#custom#_get_filetype_option(
                                      \   'omni_patterns', filetype, ''))
                                  if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    call deoplete#mapping#_set_completeopt()
                                    call feedkeys("\<C-x>\<C-o>", 'in')
                                    return 1
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000002 function! s:completion_timer_start(event) abort
                              if exists('s:completion_timer')
                                call s:completion_timer_stop()
                              endif
                            
                              let delay = deoplete#custom#_get_option('auto_complete_delay')
                              if delay > 0
                                let s:completion_timer = timer_start(
                                      \ delay, {-> s:completion_begin(a:event)})
                              else
                                call s:completion_begin(a:event)
                              endif
                            endfunction
    1              0.000001 function! s:completion_timer_stop() abort
                              if !exists('s:completion_timer')
                                return
                              endif
                            
                              call timer_stop(s:completion_timer)
                              unlet s:completion_timer
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_async_timer_start() abort
                              if exists('s:async_timer')
                                call deoplete#handler#_async_timer_stop()
                              endif
                            
                              let delay = deoplete#custom#_get_option('auto_refresh_delay')
                              if delay <= 0
                                return
                              endif
                            
                              let s:async_timer = { 'event': 'Async', 'changedtick': b:changedtick }
                              let s:async_timer.id = timer_start(
                                    \ max([20, delay]),
                                    \ function('s:completion_async'), {'repeat': -1})
                            endfunction
    1              0.000002 function! deoplete#handler#_async_timer_stop() abort
                              if exists('s:async_timer')
                                call timer_stop(s:async_timer.id)
                                unlet s:async_timer
                              endif
                            endfunction
    1              0.000002 function! s:completion_async(timer) abort
                              if mode() !=# 'i' || s:is_exiting()
                                call deoplete#handler#_async_timer_stop()
                                return
                              endif
                            
                              call s:completion_begin(s:async_timer.event)
                            endfunction
                            
    1              0.000001 function! s:completion_begin(event) abort
                              let s:check_insert_charpre = (a:event ==# 'InsertCharPre')
                            
                              if s:is_skip(a:event)
                                call deoplete#mapping#_restore_completeopt()
                                let g:deoplete#_context.candidates = []
                                return
                              endif
                            
                              if a:event !=# 'Async'
                                call deoplete#init#_prev_completion()
                              endif
                            
                              call deoplete#util#rpcnotify(
                                    \ 'deoplete_auto_completion_begin', {'event': a:event})
                            endfunction
    1              0.000001 function! s:is_skip(event) abort
                              if a:event ==# 'TextChangedP' && !s:check_insert_charpre
                                return 1
                              endif
                            
                              if s:is_skip_text(a:event)
                                return 1
                              endif
                            
                              let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
                              if &paste
                                    \ || (a:event !=# 'Manual' && a:event !=# 'Async' && !auto_complete)
                                    \ || (&l:completefunc !=# '' && &l:buftype =~# 'nofile')
                                    \ || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                    \ || (exists('b:eskk') && !empty(b:eskk))
                                return 1
                              endif
                            
                              return 0
                            endfunction
    1              0.000001 function! s:is_skip_text(event) abort
                              let input = deoplete#util#get_input(a:event)
                            
                              let lastchar = matchstr(input, '.$')
                              let skip_multibyte = deoplete#custom#_get_option('skip_multibyte')
                              if skip_multibyte && len(lastchar) != strwidth(lastchar)
                                return 1
                              endif
                            
                              let context = g:deoplete#_context
                              if has_key(context, 'input')
                                    \ && a:event !=# 'Manual'
                                    \ && a:event !=# 'Async'
                                    \ && a:event !=# 'TextChangedP'
                                    \ && input ==# context.input
                                return 1
                              endif
                            
                              let displaywidth = strdisplaywidth(input) + 1
                              if &l:formatoptions =~# '[tca]' && &l:textwidth > 0
                                    \     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]'
                                      \ || !empty(filter(deoplete#util#get_syn_names(),
                                      \                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
                              endif
                            
                              let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
                              return (a:event !=# 'Manual' && input !=# ''
                                    \     && index(skip_chars, input[-1:]) >= 0)
                            endfunction
                            
    1              0.000001 function! s:define_on_event(event) abort
                              if !exists('##' . a:event)
                                return
                              endif
                            
                              execute 'autocmd deoplete' a:event
                                    \ '* if !&l:previewwindow | call deoplete#send_event('
                                    \ .string(a:event).') | endif'
                            endfunction
    1              0.000002 function! s:define_completion_via_timer(event) abort
                              if !exists('##' . a:event)
                                return
                              endif
                            
                              execute 'autocmd deoplete' a:event
                                    \ '* call s:completion_timer_start('.string(a:event).')'
                            endfunction
                            
    1              0.000001 function! s:on_insert_leave() abort
                              call deoplete#mapping#_restore_completeopt()
                              let g:deoplete#_context = {}
                              call deoplete#init#_prev_completion()
                            endfunction
                            
    1              0.000002 function! s:on_complete_done() abort
                              if get(v:completed_item, 'word', '') ==# ''
                                return
                              endif
                              call deoplete#handler#_skip_next_completion()
                            endfunction
                            
    1              0.000002 function! deoplete#handler#_skip_next_completion() abort
                              if !exists('g:deoplete#_context')
                                return
                              endif
                            
                              let input = deoplete#util#get_input('CompleteDone')
                              if input !~# '[/.]$'
                                let g:deoplete#_context.input = input
                              endif
                              call deoplete#init#_prev_completion()
                            endfunction
                            
    1              0.000001 function! s:is_exiting() abort
                              return exists('v:exiting') && v:exiting != v:null
                            endfunction
                            
    1              0.000001 function! s:kill_yarp() abort
                              if !exists('g:deoplete#_yarp')
                                return
                              endif
                            
                              if g:deoplete#_yarp.job_is_dead
                                return
                              endif
                            
                              let job = g:deoplete#_yarp.job
                              if !has('nvim') && !exists('g:yarp_jobstart')
                                " Get job object from vim-hug-neovim-rpc
                                let job = g:_neovim_rpc_jobs[job].job
                              endif
                            
                              if has('nvim')
                                call jobstop(job)
                              else
                                call job_stop(job, 'kill')
                              endif
                            
                              let g:deoplete#_yarp.job_is_dead = 1
                            endfunction

SCRIPT  /home/greg/.config/nvim/plugged/ale/autoload/ale/statusline.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            " Author: KabbAmine <amine.kabb@gmail.com>
                            " Description: Statusline related function(s)
                            
    1              0.000004 function! s:CreateCountDict() abort
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
                                return {
                                \   '0': 0,
                                \   '1': 0,
                                \   'error': 0,
                                \   'warning': 0,
                                \   'info': 0,
                                \   'style_error': 0,
                                \   'style_warning': 0,
                                \   'total': 0,
                                \}
                            endfunction
                            
                            " Update the buffer error/warning count with data from loclist.
    1              0.000003 function! ale#statusline#Update(buffer, loclist) abort
                                if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
                                let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
                                let l:count = s:CreateCountDict()
                                let l:count.total = len(l:loclist)
                            
                                for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
                                            let l:count.warning += 1
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
                                        let l:count.error += 1
                                    endif
                                endfor
                            
                                " Set keys for backwards compatibility.
                                let l:count[0] = l:count.error + l:count.style_error
                                let l:count[1] = l:count.total - l:count[0]
                            
                                let g:ale_buffer_info[a:buffer].count = l:count
                            endfunction
                            
                            " Get the counts for the buffer, and update the counts if needed.
    1              0.000002 function! s:GetCounts(buffer) abort
                                if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
                                if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
                                return g:ale_buffer_info[a:buffer].count
                            endfunction
                            
                            " Returns a Dictionary with counts for use in third party integrations.
    1              0.000002 function! ale#statusline#Count(buffer) abort
                                " The Dictionary is copied here before exposing it to other plugins.
                                return copy(s:GetCounts(a:buffer))
                            endfunction

FUNCTION  gitgutter#highlight#define_signs()
Called 1 time
Total time:   0.000077
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000002   sign define GitGutterLineAdded
    1              0.000001   sign define GitGutterLineModified
    1              0.000001   sign define GitGutterLineRemoved
    1              0.000001   sign define GitGutterLineRemovedFirstLine
    1              0.000001   sign define GitGutterLineRemovedAboveAndBelow
    1              0.000001   sign define GitGutterLineModifiedRemoved
    1              0.000001   sign define GitGutterDummy
                            
    1   0.000027   0.000004   call s:define_sign_text()
    1   0.000022   0.000006   call gitgutter#highlight#define_sign_text_highlights()
    1   0.000020   0.000003   call s:define_sign_line_highlights()

FUNCTION  gitgutter#async#execute()
Called 2 times
Total time:   0.002327
 Self time:   0.002051

count  total (s)   self (s)
    2   0.000376   0.000107   call gitgutter#debug#log('[async] '.a:cmd)
                            
    2              0.000009   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    2   0.000015   0.000008   let command = s:build_command(a:cmd)
                            
    2              0.000005   if has('nvim')
    2              0.001880     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    2              0.000007   else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                              endif

FUNCTION  gitgutter#utility#set_repo_path()
Called 2 times
Total time:   0.003007
 Self time:   0.000335

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    2   0.000047   0.000010   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    2   0.000209   0.000024   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    2   0.000235   0.000113   if g:gitgutter_async && gitgutter#async#available()
    2              0.000004     if has('lambda')
    2   0.002430   0.000103       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
    2              0.000002     else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:not_tracked_by_git') })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                  endif
                                endif
    2              0.000002   else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif

FUNCTION  gitgutter#highlight#define_highlights()
Called 1 time
Total time:   0.000268
 Self time:   0.000155

count  total (s)   self (s)
    1   0.000122   0.000009   let [guibg, ctermbg] = s:get_background_colors('SignColumn')
                            
                              " Highlights used by the signs.
                            
    1              0.000014   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
    1              0.000012   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
    1              0.000011   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
    1              0.000027   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
                            
    1              0.000013   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000011   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000011   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    1              0.000005   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
                            
    1              0.000001   highlight default link GitGutterAdd          GitGutterAddDefault
    1              0.000001   highlight default link GitGutterChange       GitGutterChangeDefault
    1              0.000001   highlight default link GitGutterDelete       GitGutterDeleteDefault
    1              0.000001   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
                            
                              " Highlights used for the whole line.
                            
    1              0.000009   highlight default link GitGutterAddLine          DiffAdd
    1              0.000009   highlight default link GitGutterChangeLine       DiffChange
    1              0.000009   highlight default link GitGutterDeleteLine       DiffDelete
    1              0.000005   highlight default link GitGutterChangeDeleteLine GitGutterChangeLine

FUNCTION  gitgutter#process_buffer()
Called 2 times
Total time:   0.121821
 Self time:   0.000321

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    2   0.000356   0.000011   if gitgutter#utility#is_active(a:bufnr)
    2   0.000034   0.000010     if a:force || s:has_fresh_changes(a:bufnr)
                            
    2              0.000004       let diff = ''
    2              0.000003       try
    2   0.118002   0.000184         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
                                  catch /gitgutter not tracked/
    2   0.000231   0.000027         call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
    2              0.000003       catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    2              0.000004       if diff != 'async'
    2   0.003124   0.000015         call gitgutter#diff#handler(a:bufnr, diff)
    2              0.000001       endif
                            
    2              0.000001     endif
    2              0.000001   endif

FUNCTION  gitgutter#utility#is_active()
Called 4 times
Total time:   0.000546
 Self time:   0.000067

count  total (s)   self (s)
    4   0.000541   0.000063   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  gitgutter#utility#cd_cmd()
Called 2 times
Total time:   0.000132
 Self time:   0.000025

count  total (s)   self (s)
    2   0.000066   0.000014   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    2   0.000064   0.000009   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  gitgutter#diff#process_hunks()
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000004   let modified_lines = []
    2              0.000004   for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
    2              0.000003   return modified_lines

FUNCTION  gitgutter#debug#log()
Called 6 times
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
    6              0.000009   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 2 times
Total time:   0.000032
 Self time:   0.000012

count  total (s)   self (s)
    2   0.000031   0.000011   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitgutter#diff#parse_diff()
Called 2 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000004   let hunks = []
    2              0.000013   for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
    2              0.000003   return hunks

FUNCTION  gitgutter#all()
Called 1 time
Total time:   0.008939
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000004   let visible = tabpagebuflist()
                            
    3              0.000008   for bufnr in range(1, bufnr('$') + 1)
    2              0.000005     if buflisted(bufnr)
    1              0.000012       let file = expand('#'.bufnr.':p')
    1              0.000003       if !empty(file)
    1              0.000003         if index(visible, bufnr) != -1
    1   0.001443   0.000006           call gitgutter#init_buffer(bufnr)
    1   0.007424   0.000010           call gitgutter#process_buffer(bufnr, a:force)
    1              0.000001         elseif a:force
                                      call s:reset_tick(bufnr)
                                    endif
    1              0.000001       endif
    1              0.000001     endif
    2              0.000002   endfor

FUNCTION  gitgutter#utility#shellescape()
Called 10 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
   10              0.000193   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   10              0.000014     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  gitgutter#async#available()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return s:available

FUNCTION  gitgutter#sign#update_signs()
Called 2 times
Total time:   0.000831
 Self time:   0.000111

count  total (s)   self (s)
    2   0.000451   0.000014   call s:find_current_signs(a:bufnr)
                            
    2              0.000011   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    2   0.000109   0.000018   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    2              0.000010   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    2              0.000003   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    2   0.000079   0.000016   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    2   0.000143   0.000013   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    2              0.000003   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 18 times
Total time:   0.000420
 Self time:   0.000420

count  total (s)   self (s)
   18              0.000041   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   18              0.000054   let bvars = getbufvar(buffer, '')
   18              0.000031   if empty(bvars)
                                let bvars = {}
                              endif
   18              0.000063   let dict = get(bvars, 'gitgutter', {})
   18              0.000044   let needs_setting = empty(dict)
   18              0.000051   let dict[a:varname] = a:val
   18              0.000019   if needs_setting
    1              0.000002     call setbufvar(buffer, 'gitgutter', dict)
    1              0.000001   endif

FUNCTION  gitgutter#highlight#define_sign_column_highlight()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   if g:gitgutter_override_sign_column_highlight
    1              0.000010     highlight! link SignColumn LineNr
    1              0.000001   else
                                highlight default link SignColumn LineNr
                              endif

FUNCTION  gitgutter#utility#repo_path()
Called 8 times
Total time:   0.000190
 Self time:   0.000087

count  total (s)   self (s)
    8   0.000153   0.000050   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    8              0.000028   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#utility#windows()
Called 4 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    4              0.000031   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#init_buffer()
Called 2 times
Total time:   0.003691
 Self time:   0.000074

count  total (s)   self (s)
    2   0.000213   0.000012   if gitgutter#utility#is_active(a:bufnr)
    2   0.000044   0.000010     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    2              0.000005     if type(p) != s:t_string || empty(p)
    2   0.003024   0.000017       call gitgutter#utility#set_repo_path(a:bufnr)
    2   0.000396   0.000023       call s:setup_maps()
    2              0.000002     endif
    2              0.000002   endif

FUNCTION  gitgutter#diff#run_diff()
Called 2 times
Total time:   0.012132
 Self time:   0.011172

count  total (s)   self (s)
    4   0.000164   0.000051   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
    2   0.011886   0.011081     sleep 5m
    2              0.000007   endwhile
                            
    2   0.000051   0.000009   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
    1              0.121636     throw 'gitgutter not tracked'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
                              let s:counter = (s:counter + 1) % 20
                              let buff_file .= '.'.s:counter
                            
                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)
                            
                              if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
                                let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                let from_file .= '.'.s:counter
                            
                                if !empty(extension)
                                  let from_file .= '.'.extension
                                endif
                            
                                " Write file from index to temporary file.
                                let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
                                let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
                              let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'
                            
                              let cmd .= ')'
                            
                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
                                return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  gitgutter#diff#handler()
Called 2 times
Total time:   0.003109
 Self time:   0.000504

count  total (s)   self (s)
    2   0.000091   0.000009   call gitgutter#debug#log(a:diff)
                            
    2              0.000005   if !bufexists(a:bufnr)
                                return
                              endif
                            
    2   0.001294   0.000202   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    2   0.000077   0.000022   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    2              0.000006   let signs_count = len(modified_lines)
    2              0.000004   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    2              0.000004     if g:gitgutter_signs || g:gitgutter_highlight_lines
    2   0.001510   0.000193       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    2              0.000001     endif
    2              0.000001   endif
                            
    2   0.000068   0.000010   call s:save_last_seen_change(a:bufnr)
    2              0.000009   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  gitgutter#utility#file()
Called 2 times
Total time:   0.000126
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000125   0.000012   return s:abs_path(a:bufnr, 1)

FUNCTION  gitgutter#utility#supports_overscore_sign()
Called 1 time
Total time:   0.000018
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000014   0.000006   if gitgutter#utility#windows()
                                return &encoding ==? 'utf-8'
                              else
    1              0.000003     return &termencoding ==? &encoding || &termencoding == ''
                              endif

FUNCTION  gitgutter#utility#getbufvar()
Called 19 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
   19              0.000106   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   19              0.000049   if has_key(dict, a:varname)
   17              0.000035     return dict[a:varname]
                              else
    2              0.000002     if a:0
                                  return a:1
                                endif
    2              0.000001   endif

FUNCTION  gitgutter#highlight#define_sign_text_highlights()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                              " Once a sign's text attribute has been defined, it cannot be undefined or
                              " set to an empty value.  So to make signs' text disappear (when toggling
                              " off or disabling) we make them invisible by setting their foreground colours
                              " to the background's.
    1              0.000001   if g:gitgutter_signs
    1              0.000002     sign define GitGutterLineAdded                 texthl=GitGutterAdd
    1              0.000001     sign define GitGutterLineModified              texthl=GitGutterChange
    1              0.000001     sign define GitGutterLineRemoved               texthl=GitGutterDelete
    1              0.000001     sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDelete
    1              0.000001     sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDelete
    1              0.000001     sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDelete
    1              0.000001   else
                                sign define GitGutterLineAdded                 texthl=GitGutterAddInvisible
                                sign define GitGutterLineModified              texthl=GitGutterChangeInvisible
                                sign define GitGutterLineRemoved               texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineRemovedFirstLine      texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineRemovedAboveAndBelow  texthl=GitGutterDeleteInvisible
                                sign define GitGutterLineModifiedRemoved       texthl=GitGutterChangeDeleteInvisible
                              endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 2 times
Total time:   0.000141
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000072   0.000014   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    2   0.000068   0.000011   call s:reset_summary(a:bufnr)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.121821   0.000321  gitgutter#process_buffer()
    2   0.012132   0.011172  gitgutter#diff#run_diff()
    1   0.008939   0.000088  gitgutter#all()
    2   0.003691   0.000074  gitgutter#init_buffer()
    2   0.003109   0.000504  gitgutter#diff#handler()
    2   0.003007   0.000335  gitgutter#utility#set_repo_path()
    2   0.002327   0.002051  gitgutter#async#execute()
    2   0.000831   0.000111  gitgutter#sign#update_signs()
    4   0.000546   0.000067  gitgutter#utility#is_active()
   18   0.000420             gitgutter#utility#setbufvar()
    1   0.000268   0.000155  gitgutter#highlight#define_highlights()
   19   0.000220             gitgutter#utility#getbufvar()
    6   0.000217             gitgutter#debug#log()
   10   0.000216             gitgutter#utility#shellescape()
    8   0.000190   0.000087  gitgutter#utility#repo_path()
    2   0.000141   0.000026  gitgutter#hunk#set_hunks()
    2   0.000132   0.000025  gitgutter#utility#cd_cmd()
    2   0.000126   0.000013  gitgutter#utility#file()
    1   0.000077   0.000021  gitgutter#highlight#define_signs()
    2   0.000039             gitgutter#diff#parse_diff()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.012132   0.011172  gitgutter#diff#run_diff()
    2   0.002327   0.002051  gitgutter#async#execute()
    2   0.003109   0.000504  gitgutter#diff#handler()
   18              0.000420  gitgutter#utility#setbufvar()
    2   0.003007   0.000335  gitgutter#utility#set_repo_path()
    2   0.121821   0.000321  gitgutter#process_buffer()
   19              0.000220  gitgutter#utility#getbufvar()
    6              0.000217  gitgutter#debug#log()
   10              0.000216  gitgutter#utility#shellescape()
    1   0.000268   0.000155  gitgutter#highlight#define_highlights()
    2   0.000831   0.000111  gitgutter#sign#update_signs()
    1   0.008939   0.000088  gitgutter#all()
    8   0.000190   0.000087  gitgutter#utility#repo_path()
    2   0.003691   0.000074  gitgutter#init_buffer()
    4   0.000546   0.000067  gitgutter#utility#is_active()
    2              0.000039  gitgutter#diff#parse_diff()
    4              0.000032  gitgutter#utility#windows()
    2   0.000141   0.000026  gitgutter#hunk#set_hunks()
    2   0.000132   0.000025  gitgutter#utility#cd_cmd()
    2              0.000023  gitgutter#diff#process_hunks()

